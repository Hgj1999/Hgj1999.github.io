

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Glimmering Stars">
  <meta name="keywords" content="技术博客">
  
    <meta name="description" content="HTTP 报文结构header + body1起始行+头部+空行+实体  请求报文的结构起始行1GET &#x2F;home HTTP&#x2F;1.1  方法 + 路径 + http 版本 实体请求体 请求方法 GET  通常用来获取资源   HEAD  获取资源的元信息   POST  上传数据 会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP">
<meta property="og:url" content="https://hgj1999.github.io/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/index.html">
<meta property="og:site_name" content="点点星光的技术博客">
<meta property="og:description" content="HTTP 报文结构header + body1起始行+头部+空行+实体  请求报文的结构起始行1GET &#x2F;home HTTP&#x2F;1.1  方法 + 路径 + http 版本 实体请求体 请求方法 GET  通常用来获取资源   HEAD  获取资源的元信息   POST  上传数据 会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png">
<meta property="og:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network02.png">
<meta property="og:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network03.png">
<meta property="og:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network04.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051317419-92d7195d-319d-4ea4-9bb4-b3eef2690ff4.png#clientId=u7f18fa48-0703-4&from=paste&height=362&id=uda0be836&originHeight=723&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=373737&status=done&style=none&taskId=u1e40ef98-7257-4c53-a715-16170bc6d04&title=&width=619.5">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051333485-a5a5a556-b0f5-44c1-b37a-eaa54527d4aa.png#clientId=u7f18fa48-0703-4&from=paste&height=281&id=u08e3d079&originHeight=561&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277759&status=done&style=none&taskId=u953f5c9b-2efa-4284-8c63-8926ac95bf5&title=&width=602">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051343631-ba73351b-a10d-47f2-8c24-c5f3193c0cec.png#clientId=u7f18fa48-0703-4&from=paste&height=302&id=u3f786ce7&originHeight=603&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86917&status=done&style=none&taskId=u1c52aedb-496a-4781-a698-ddd6755933e&title=&width=611.5">
<meta property="og:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png">
<meta property="article:published_time" content="2023-04-26T02:05:41.000Z">
<meta property="article:modified_time" content="2023-04-26T07:31:52.203Z">
<meta property="article:author" content="Glimmering Stars">
<meta property="article:tag" content="network">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hgj1999.github.io/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png">
  
  
  
  <title>HTTP - 点点星光的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"hgj1999.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Glimmering Stars&#39; Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="HTTP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-26 10:05" pubdate>
          2023年4月26日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          124 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="网络"
        id="heading-7ddbe15c845fa27a2bab496183042ca6" role="tab" data-toggle="collapse" href="#collapse-7ddbe15c845fa27a2bab496183042ca6"
        aria-expanded="true"
      >
        网络
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-7ddbe15c845fa27a2bab496183042ca6"
           role="tabpanel" aria-labelledby="heading-7ddbe15c845fa27a2bab496183042ca6">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="HTTP"
        id="heading-293c9ea246ff9985dc6f62a650f78986" role="tab" data-toggle="collapse" href="#collapse-293c9ea246ff9985dc6f62a650f78986"
        aria-expanded="true"
      >
        HTTP
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-293c9ea246ff9985dc6f62a650f78986"
           role="tabpanel" aria-labelledby="heading-293c9ea246ff9985dc6f62a650f78986">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/" title="HTTP"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">HTTP</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">HTTP</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="header-body"><a href="#header-body" class="headerlink" title="header + body"></a>header + body</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">起始行+头部+空行+实体<br></code></pre></td></tr></table></figure>

<h4 id="请求报文的结构"><a href="#请求报文的结构" class="headerlink" title="请求报文的结构"></a>请求报文的结构</h4><h5 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/home</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure>

<p>方法 + 路径 + http 版本</p>
<h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>请求体</p>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><ul>
<li>GET <ul>
<li>通常用来获取资源</li>
</ul>
</li>
<li>HEAD <ul>
<li>获取资源的元信息</li>
</ul>
</li>
<li>POST <ul>
<li>上传数据</li>
<li>会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body 部分。(火狐浏览器除外，他的 POST 请求只发一个 TCP 包)</li>
</ul>
</li>
<li>PUT <ul>
<li>修改完整数据</li>
</ul>
</li>
<li>PATCH <ul>
<li>修改部分数据</li>
</ul>
</li>
<li>DELETE <ul>
<li>删除资源</li>
</ul>
</li>
<li>CONNECT <ul>
<li>建立连接隧道，用于代理服务器</li>
</ul>
</li>
<li>OPTIONS <ul>
<li>列出可对资源实行的请求方法，用来跨域请求</li>
</ul>
</li>
<li>TRACE <ul>
<li>追求请求-响应传输的路径</li>
</ul>
</li>
</ul>
<h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p>URI(Uniform Resource Identifier) 统一资源标识符，作用：区分互联网上不同的资源</p>
<p>网址：URL，URI 包含了 URL 和 URN 两个部分，</p>
<h6 id="URI的结构："><a href="#URI的结构：" class="headerlink" title="URI的结构："></a>URI的结构：</h6><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>scheme</strong> 表示协议名，比如 http, https, file 等等。后面必须和:&#x2F;&#x2F;连在一起</p>
<p>**user:password@**表示登录主机时的用户信息，很不安全，不推荐使用，不常用</p>
<p><strong>host:port</strong>表示主机名和端口</p>
<p><strong>path</strong>表示请求路径，标记资源所在位置。</p>
<p><strong>query</strong>表示查询参数，为key&#x3D;val这种形式，多个键值对之间用&amp;隔开</p>
<p><strong>fagment</strong>表示 URI 所定位的资源内的一个 <strong>锚点</strong>，浏览器可以通过这个锚点跳转到对于的 位置</p>
<h5 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h5><p><strong>URI</strong> 只能使用 <strong>ASCII</strong>，<strong>ASCLII</strong>之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错</p>
<p>因此，<strong>URI</strong> 引入了编码机制，将所有 <strong>非 ASSCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个 <strong>%</strong></p>
<p>例：空格转义为**%20**</p>
<h4 id="响应报文的结构"><a href="#响应报文的结构" class="headerlink" title="响应报文的结构"></a>响应报文的结构</h4><h5 id="起始行也叫状态行"><a href="#起始行也叫状态行" class="headerlink" title="起始行也叫状态行"></a>起始行也叫状态行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure>

<p>http 版本 + 状态码 + 原因</p>
<h5 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h5><ul>
<li><strong>1xx：</strong>表示目前是协议处理中的中间状态，还需要后续操作。 <ul>
<li><strong>101 Switching Protocols</strong> 在 HTTP 升级为 webSocket 的时候，如果服务器同意变更，就会发送状态码 101</li>
</ul>
</li>
<li><strong>2xx：</strong>  表示成功状态。 <ul>
<li><strong>200 OK</strong> 成功状态码，响应体中有数据。</li>
<li><strong>204 No Content</strong> 成功状态码，响应体中无数据。</li>
<li><strong>206 Partial Content</strong> 表示部分内容，使用场景为：HTTP 分块下载和断点续传，会带上相应的响应头字段 Content-Range。</li>
</ul>
</li>
<li><strong>3xx：</strong>重定向状态，资源位置发生变动，需要重新请求 <ul>
<li><strong>301 Moved Permanently</strong> 永久重定向 </li>
<li><strong>302 Found</strong> 临时重定向<br>例：<br> 以前的站点再也不用了返回 301，浏览器会默认做优化缓存，在第二次访问的时候自动访问重定向的那个地址。<br> 以前的站点暂时不可用，直接返回 302 ，浏览器不会做缓存优化 </li>
<li><strong>304 Not Modified</strong> 当协商缓存命中时会返回这个状态码。</li>
</ul>
</li>
<li><strong>4xx：</strong>请求报文有误 <ul>
<li><strong>400 Bad Request</strong> 服务器无法理解该请求 可能是语法错误。</li>
<li><strong>403 Forbidden</strong> 服务器禁止访问。</li>
<li><strong>404 Not Found</strong> 资源未找到，没在服务器上找到相应的资源。</li>
<li><strong>405 Method Not Allowed</strong> 请求方法不被服务器允许。</li>
<li><strong>406 Not Acceptable</strong> 资源无法满足客户端的条件。</li>
<li><strong>408 Request Timeout</strong> 服务器等待了太长时间。</li>
<li><strong>409 Conflict</strong> 多个请求发生了冲突。</li>
<li><strong>413 Request Entity Too Large</strong> 请求体的数据过大。</li>
</ul>
</li>
<li><strong>5xx</strong> <ul>
<li><strong>500 Internal Server Error</strong> 服务器出错</li>
<li><strong>501 Not Implemented</strong> 客户端请求的功能还不支持。</li>
<li><strong>502 Bad Gateway</strong> 服务器自身是正常的，但是访问的时候出错了。</li>
<li><strong>503 Service Unavailable</strong> 服务器当前很忙，暂时无法响应服务。</li>
</ul>
</li>
<li><strong>5xx：</strong>服务端发生错误</li>
</ul>
<h3 id="HTTP特点以及缺点"><a href="#HTTP特点以及缺点" class="headerlink" title="HTTP特点以及缺点"></a>HTTP特点以及缺点</h3><h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><ol>
<li>灵活可拓展 <ol>
<li>语义上自由，只有基本格式没有严格限制</li>
<li>传输形式多样性，可以传输文本、图片、视频等任意数据</li>
</ol>
</li>
<li>可靠传输，HTTP基于 TCP&#x2F;IP ，这是 TCP 的特性</li>
<li>请求-应答，一发一收、有来有回。</li>
<li>无状态，状态：通信过程的上下文信息，每次 http 请求都是独立、无关的，默认不需要保留状态信息</li>
</ol>
<h4 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h4><ol>
<li>无状态</li>
</ol>
<ul>
<li>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，此时是缺点</li>
<li>在只是获取一些数据的场景中，不需要保存连接上下文信息，无状态减少了网络开销，此时是优点</li>
</ul>
<ol start="2">
<li>明文传输<br>协议里的报文（主要指头部）不使用二进制数据，而是文本形式<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<strong>WIFI陷阱</strong> 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。 </li>
<li>队头阻塞问题</li>
</ol>
<p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p>
<h3 id="Accept-系列字段"><a href="#Accept-系列字段" class="headerlink" title="Accept 系列字段"></a>Accept 系列字段</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>发送端：Content-Type 字段</p>
<p>接收端：Accept 字段</p>
<p>取值：</p>
<pre><code class="hljs">text： text/html, text/plain, text/css 等

image: image/gif, image/jpeg, image/png 等

audio/video: audio/mpeg, video/mp4 等

application: application/json, application/javascript, application/pdf, application/octet-stream
</code></pre>
<h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>发送方：Content-Encoding</p>
<p>接受方：Accept-Encoding</p>
<p>取值:</p>
<pre><code class="hljs">gzip:最流行的压缩格式

deflate:另一种著名的压缩格式

br:一种专门为 HTTP 发明的压缩算法
</code></pre>
<h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>发送端：Content-Language</p>
<p>接收方：Accept-Language</p>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>发送方：Content-Type:charset&#x3D;utf-8</p>
<p>接收端：Accept-Charset:charset&#x3D;utf-8</p>
<h3 id="HTTP对定长和不定长数据传输的处理"><a href="#HTTP对定长和不定长数据传输的处理" class="headerlink" title="HTTP对定长和不定长数据传输的处理"></a>HTTP对定长和不定长数据传输的处理</h3><h4 id="定长包"><a href="#定长包" class="headerlink" title="定长包"></a>定长包</h4><p>发送端带上Content-length</p>
<h4 id="不定长包"><a href="#不定长包" class="headerlink" title="不定长包"></a>不定长包</h4><p>发送端带上 Transfer-Encoding: chunked</p>
<p>表示分块传输数据，设置这个字段后会自动产生两个效果</p>
<ul>
<li>Content-Length 字段会被忽略</li>
<li>基于长连接持续推动动态内容</li>
</ul>
<h3 id="HTTP-处理大文件传输"><a href="#HTTP-处理大文件传输" class="headerlink" title="HTTP 处理大文件传输"></a>HTTP 处理大文件传输</h3><p>采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分</p>
<p>服务端发送：</p>
<p>添加上 Accept-Ranges:none 响应头，来告诉客户端这边年支持范围请求</p>
<p>客户端：</p>
<p>Range 字段拆解，客户端需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes&#x3D;x-y</p>
<p>Range 的书写格式：</p>
<pre><code class="hljs">0-499 表示从开始到第 499 个字节。

500- 表示从第 500 字节到文件终点。

-100 表示文件最后 100 个字节。
</code></pre>
<p>服务端接收：</p>
<pre><code class="hljs">接受到请求之后，先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码

同时服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同而又所差异
</code></pre>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// 单段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9<br>// 多段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9, 30-39<br></code></pre></td></tr></table></figure>

<h3 id="HTTP1-1解决HTTP队头阻塞问题"><a href="#HTTP1-1解决HTTP队头阻塞问题" class="headerlink" title="HTTP1.1解决HTTP队头阻塞问题"></a>HTTP1.1解决HTTP队头阻塞问题</h3><p>HTTP传输基于 请求-应答的模式进行，传输任务是放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p>
<h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p>
<h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>一个域名可以并发 6 个长连接，多分几个域名</p>
<p>这样一个 baidu.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>
<h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>HTTP是无状态的协议，需要保存状态就引入了Cookie</p>
<p>Cookie 本身是浏览器里面存储的一个很小的本地文件，内部以键值对的方式存储。同一个域名下发送请求，都会携带相同的 Cookie ，服务器拿到 Cookie 进行解析，就可以拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 请求头<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>a=xxx;b=xxx<br>// 响应头<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>a=xxx<br><span class="hljs-attribute">set-Cookie</span><span class="hljs-punctuation">: </span>b=xxx<br></code></pre></td></tr></table></figure>

<h4 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h4><p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置</p>
<ul>
<li>Expires 即过期时间</li>
<li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算</li>
</ul>
<p>若Cookie过期，则这个Cookie会被删除，并不会发送给服务端</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域有两个属性：Domain和path，都给Cookie绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上Cookie。对于路径来说，&#x2F;表示域名下的任意路径都允许使用Cookie。</p>
<h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果带上Secure，说明只能通过 HTTPS 传输 cookie。</p>
<p>如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p>
<p>CSRF攻击的预防可以通过SameSite属性。</p>
<p>SameSite 可以设置为三个值：Strict、Lax和None。</p>
<ol>
<li>在 Strict 模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>baidu.com</code>网站只能在<code>baidu.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</li>
<li>在 Lax 模式下，宽松一点，只能在 get 方法提交表单 或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li>
<li>在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。</li>
</ol>
<h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ol>
<li>容量缺陷 体积上限是 4kB</li>
<li>性能缺陷 Cookie紧跟域名，不管域名下面的某一个子域名需不需要这个 Cookie 请求都会携带上完整的Cookie，请求数量一多会照成巨大的性能浪费，可以通过 Domain 和 Path 指定作用域来解决。</li>
<li>安全缺陷，由于 Cookie 以纯文本的形式传递很容易被非法用户截获，然后进行一系列篡改，在Cookie的有效期内重新推送给服务器，在 HttpOnly 为 false 的情况下，Cookie信息能直接通过 JS 脚本来读取。</li>
</ol>
<h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><p>HTTP基于请求-响应模型的协议，一般由客户端发请求，服务器来响应</p>
<p>如果有代理服务器，引入代理之后，作为代理的服务器相当与一个中间人的角色，对于客户端表现为服务器进行响应，对于源服务器表现为客户端发起请求，具有双重身份。</p>
<h4 id="HTTP-代理的功能"><a href="#HTTP-代理的功能" class="headerlink" title="HTTP 代理的功能"></a>HTTP 代理的功能</h4><ol>
<li><strong>负载均衡</strong>： <ol>
<li>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li>
</ol>
</li>
<li><strong>保障安全:</strong> <ol>
<li>利用心跳机制监控后台服务器，一旦发现故障机就将其踢出集群，并且对于上下行的数据进行过滤，对于非法IP限流，这些都是代理服务器的工作</li>
</ol>
</li>
<li><strong>缓存代理：</strong> <ol>
<li>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得，而不用到的源服务器那里获得。</li>
</ol>
</li>
</ol>
<h4 id="相关头字段"><a href="#相关头字段" class="headerlink" title="相关头字段"></a>相关头字段</h4><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><pre><code class="hljs">代理服务器通过 Via 字段在 HTTP 传输中留下自己的痕迹

Via中的代理的顺序即为在 HTTP 传输中报文传达的顺序
</code></pre>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器<br>// 源服务器收到请求后，请求头<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>proxy_server1,proxy_server2<br>// 源服务器响应时候，客户端的响应头<br>Via:proxy_server2,proxr_server1<br></code></pre></td></tr></table></figure>

<h5 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h5><pre><code class="hljs">为谁转发，记录的是请求方的IP地址
</code></pre>
<h5 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h5><pre><code class="hljs">获取用户真实IP的字段，不管中间经过了多少代理，这个字段始终记录最初客户端的IP

对应的有 **X-Forwarded-Host** 和 **X-forwarded-Proto**，分别记录客户端(不包括代理)的域名和协议名
</code></pre>
<h5 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h5><pre><code class="hljs">此字段是记录请求方的IP，意味着每经过一个不同的代理，这个字段的名字都要改变，从客户端到代理1，这个字段是客户端的IP，从代理1到代理2，这个字段变成了代理1的IP
</code></pre>
<p>意味着会产生两个问题：</p>
<ol>
<li>代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降</li>
<li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的</li>
</ol>
<p>由此产生了 <strong>代理协议</strong> ，一般使用明文版本，只需要在HTTP请求行上面加上这样格式的文本即可:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接受端口<br>PREOXY TCP4 0.0.0.1 0.0.0.2 1111 2222<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure>

<p>这样就可以解决X-Forwarded-For产生的问题</p>
<h3 id="HTTP缓存及缓存代理"><a href="#HTTP缓存及缓存代理" class="headerlink" title="HTTP缓存及缓存代理"></a>HTTP缓存及缓存代理</h3><h4 id="关于-强缓存-和-协商缓存"><a href="#关于-强缓存-和-协商缓存" class="headerlink" title="关于 强缓存 和 协商缓存"></a>关于 <strong>强缓存</strong> 和 <strong>协商缓存</strong></h4><p>首先通过 Cache-Control 验证强缓存是否可用</p>
<ul>
<li>如果强缓存可用，直接使用</li>
<li>否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新 <ul>
<li>若资源更新，返回资源和200状态码</li>
<li>否则，返回304，告诉浏览器直接从缓存中获取资源</li>
</ul>
</li>
</ul>
<h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><p>对于服务器来说，也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的</p>
<p>由此引入了缓存代理的机制，让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候就能明显降低源服务器的压力</p>
<h5 id="代理缓存的实现："><a href="#代理缓存的实现：" class="headerlink" title="代理缓存的实现："></a>代理缓存的实现：</h5><ul>
<li>代理缓存的控制分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制</li>
</ul>
<h6 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h6><p><strong>private 和 public</strong></p>
<p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入priivate或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。</p>
<p>对于一些比较私密的数据，如果缓存到代理服务器上，比如直接访问代理就可以直接拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头的Cache-Control设为private，而不是public</p>
<p><strong>proxy-revalidate</strong></p>
<p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取</p>
<p><strong>s-maxage</strong></p>
<p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突</p>
<p>例子：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:public,max-age=1000,s-maxage=2000<br></code></pre></td></tr></table></figure>

<p>相当于源服务器说：我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理服务器中拿，并且客户端的缓存时间为1000秒，在代理服务器中的缓存时间为2000秒</p>
<h6 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h6><h6 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h6><p>在客户端的请求头中，可以加入两个字段，来对代理服务器上的缓存进行宽容和限制的操作</p>
<p>例子：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">max-stale:5<br></code></pre></td></tr></table></figure>

<p>表示客户端到代理服务器上那缓存的时候，即使缓存过期了也不要紧，只要在过期时间在5秒之内，还可以从代理中获取的</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">min-fresh:5<br></code></pre></td></tr></table></figure>

<p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前5秒之前的时间拿，否则拿不到</p>
<h6 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h6><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>因为浏览器遵循同源政策(协议、主机和端口都相同则为同源)。非同源站点有这样一些限制:</p>
<ul>
<li>不能读取和修改对方的DOM</li>
<li>不能访问对方的Cookie、IndexDb和LocalStorage</li>
<li>限制XMLHttpRequest请求。</li>
</ul>
<p>当浏览器向着目标URI发出Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被称为跨域请求。</p>
<p>跨域请求的响应会被浏览器所拦截，响应是成功到达客户端了。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>跨域资源共享</p>
<p>它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头</p>
<p><strong>简单请求</strong></p>
<ul>
<li>请求方法为GET、POST或者HEAD </li>
<li>请求头的取值范围：Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain) </li>
<li>简单请求跨域处理 <ul>
<li><p>请求发出去前，在请求头中添加一个Origin字段，说明请求来自于哪个源。服务器拿到请求之后，在回应时对应地添加<strong>Access-Control-Allow-Origin</strong>字段，如果Origin不在这个字段范围内，浏览器就会将响应拦截。 </p>
</li>
<li><p><strong>Access-Control-Allow-Credentials</strong> 字段 是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器这个字段默认值设为false，如果需要拿到浏览器的Cookie，添加此字段并设置为true，并且在前端也需要设置withCredentials属性：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Access-Control-Expose-Headers</strong> 这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）还能拿到这个字段生命的响应头字段，例子：</p>
</li>
</ul>
</li>
</ul>
<p>前端可以通过XMLHttpRequest.getResponseHeader(‘aaa’)拿到 aaa这个字段的值。 </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: aaa<br></code></pre></td></tr></table></figure>

<p><strong>非简单请求</strong></p>
<ul>
<li>除简单请求之外的请求都是非简单请求 </li>
<li>浏览器以及跨域处理 <ul>
<li>预检请求和响应字段 <ul>
<li>发送非简单请求之前要先发送预检请求<br>预检请求的方法是OPTIONS，同时加上Origin源地址和Host目标地址，同时也加上两个关键字段 <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>当前地址<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure>

<ul>
<li>Access-Control-Request-Method，列出请求用到哪个HTTP方法</li>
<li>Access-Control-Request-Headers，指定CORS请求将要加上什么请求头</li>
</ul>
</li>
<li><h2 id="响应字段-预检查的响应"><a href="#响应字段-预检查的响应" class="headerlink" title="响应字段-  预检查的响应 "></a>响应字段<br>-  预检查的响应 </h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Access-Control-Allow-Origin</strong>: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。<br><strong>Access-Control-Allow-Methods</strong>: 表示允许的请求方法列表。<br><strong>Access-Control-Allow-Credentials</strong>: 简单请求中已经介绍。<br><strong>Access-Control-Allow-Headers</strong>: 表示允许发送的请求头字段<br><strong>Access-Control-Max-Age</strong>: 预检请求的有效期，在此期间，不用发出另外一条预检请求。<br>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS请求</strong>也不会发出去了。 </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">     -  CORS的响应 
        - 现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。
</code></pre>
<h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">jsonp</span> = (<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateURL</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;<br>    &#125;<br>    dataStr += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化回调函数名称</span><br>    callbackName = callbackName || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-property">toString</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <br>    <span class="hljs-comment">// 创建 script 元素并加入到当前文档中</span><br>    <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    scriptEle.<span class="hljs-property">src</span> = <span class="hljs-title function_">generateURL</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(scriptEle);<br>    <span class="hljs-comment">// 绑定到 window 上，为了后面调用</span><br>    <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>      <span class="hljs-comment">// script 执行完了，成为无用元素，需要清除</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(scriptEle);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务器端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; a, b, callback &#125; = req.<span class="hljs-property">query</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 2</span><br>  <span class="hljs-comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>

<p>前端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 拿到数据进行处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 数据包</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p>
<h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>Nginx反向代理<br><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network02.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p>
<p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p>
<p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p>
<p>解决跨域：</p>
<p>例子：客户端域名为client.con，服务器域名为server.com</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server &#123;<br>  listen  <span class="hljs-number">80</span>;<br>  server_name  client.<span class="hljs-property">com</span>;<br>  location /api &#123;<br>    proxy_pass server.<span class="hljs-property">com</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手其实就是建立一个TCP连接时，需要客户端和服务器总共发3个包。</p>
<p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>SYN（Synchronize同步的缩写）表示建立连接</p>
<p>ACK （acknowledge character 确认字符的缩写）表示响应</p>
<p>具体过程：</p>
<p>刚开始客户端处于Closed的状态，服务端处于Listen状态。进行三次握手</p>
<ul>
<li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND（同步已发送）状态。 <ul>
<li>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</li>
</ul>
</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的SYN报文作为答应，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN（初始序列号seq）+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD（同步收到）的状态。 <ul>
<li>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</li>
</ul>
</li>
<li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED（已建立连接）状态。服务器收到ACK报文之后，也处于ESTABLISHED（已建立连接）状态，此时，双方已建立起了连接。 <ul>
<li>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号</li>
</ul>
</li>
</ul>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在 socket 编程中，客户端执行 connect() 时，将触发三次握手</p>
<p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network03.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="半连接队列-x2F-全连接队列"><a href="#半连接队列-x2F-全连接队列" class="headerlink" title="半连接队列&#x2F;全连接队列"></a>半连接队列&#x2F;全连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong></p>
<p>就是已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network04.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<blockquote>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p>
</blockquote>
<blockquote>
<p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSING -等待远程TCP对连接中断的确认；</p>
</blockquote>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>CLOSED - 没有任何连接状态；</p>
</blockquote>
<h3 id="HTTP-x2F-2的改进"><a href="#HTTP-x2F-2的改进" class="headerlink" title="HTTP&#x2F;2的改进"></a>HTTP&#x2F;2的改进</h3><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>在HTTP&#x2F;1.1及以前的时代，请求头一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，如果请求字段非常复杂的时候，尤其是GET请求，请求报文几乎全是请求头，这个时候优化空间很大，</p>
<p>而HTTP&#x2F;2针对头部字段，采用了对应的压缩算法-HPACK，对请求头进行压缩。</p>
<p>HPACK算法的两个亮点</p>
<ul>
<li>首先是在服务端和客户端之前建立哈希表，将用到的字段存放在这张表中，那么在传输的时候，对于之前出现过的值，只需要传递索引给对方即可，对方拿到索引查表就可以了</li>
<li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051317419-92d7195d-319d-4ea4-9bb4-b3eef2690ff4.png#clientId=u7f18fa48-0703-4&from=paste&height=362&id=uda0be836&originHeight=723&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=373737&status=done&style=none&taskId=u1e40ef98-7257-4c53-a715-16170bc6d04&title=&width=619.5" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>HTTP&#x2F;2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><h6 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h6><p>根本原因是HTTP基于<code>请求-响应</code>的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞</p>
<p>虽然<code>并发连接</code>和<code>域名分片</code>的方式来解决这个问题，但是并没有真正从HTTP本身的层面解决问题，只是增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争 <strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理</p>
<p>HTTP&#x2F;2从HTTP协议本身解决了<code>队头阻塞</code>问题。这里指的并不是<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code></p>
<ul>
<li>TCP队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给HTTP</li>
<li>HTTP队头阻塞是在HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住</li>
</ul>
<p><strong>HTTP&#x2F;2解决队头阻塞</strong></p>
<ol>
<li>二进制分帧 <ol>
<li>首先，HTTP&#x2F;2认为明文传输对机器而言解析太麻烦，因为文本有很多多义性的字符串，比如回车换行到底是内容还是分隔符号，在内部需要用到状态机去识别，效率很低，于是HTTP&#x2F;2把报文全部换成二进制格式，全部传输01串，方便了机器的解析</li>
<li>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据，分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也不会排队等待，也就没有了HTTP的队头阻塞问题</li>
<li>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫<code>流(Stream)</code>HTTP&#x2F;2用<code>流</code>来在一个TCP连接上进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念</li>
<li>乱序首发，乱序是指不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按照顺序传输的，二进制帧到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他的字段，实现了 <strong>优先级</strong>和 <strong>流量控制</strong> 等功能。</li>
</ol>
</li>
</ol>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>在HTTP&#x2F;2中，服务器不再是完全被动地接受请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如：在浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP&#x2F;2完全兼容HTTP的语法和语义</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051333485-a5a5a556-b0f5-44c1-b37a-eaa54527d4aa.png#clientId=u7f18fa48-0703-4&from=paste&height=281&id=u08e3d079&originHeight=561&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277759&status=done&style=none&taskId=u953f5c9b-2efa-4284-8c63-8926ac95bf5&title=&width=602" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul>
<li>设置请求优先级</li>
<li>服务器推送</li>
</ul>
<h4 id="二进制帧的设计"><a href="#二进制帧的设计" class="headerlink" title="二进制帧的设计"></a>二进制帧的设计</h4><h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><p>HTTP&#x2F;2中传输的帧结构如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051343631-ba73351b-a10d-47f2-8c24-c5f3193c0cec.png#clientId=u7f18fa48-0703-4&from=paste&height=302&id=u3f786ce7&originHeight=603&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86917&status=done&style=none&taskId=u1c52aedb-496a-4781-a698-ddd6755933e&title=&width=611.5" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>每个帧分为帧头和帧体。显示三个字节的帧长度，这个长度表示的是帧体的长度。</p>
<p>然后是帧的类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧存放HTTP报文，控制帧管理<code>流</code>的传输。</p>
<p>接下来的第一个字节是<strong>帧标志</strong>，这里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束</p>
<p>后4个字节是Stream ID，也就是流标识符，有了它，接收方就能从乱序的二进制帧中选出 ID 相同的帧，然后按照顺序组装成请求&#x2F;响应报文</p>
<h5 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h5><p>根据帧的标志位来实现具体的状态改变。</p>
<p>例子：普通的请求-响应过程</p>
<p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</li>
<li>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</li>
<li>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</li>
<li>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个</li>
</ul>
<h5 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h5><ul>
<li>并发性，一个HTTP&#x2F;2连接上可以同时发多个帧，这一点和HTTP&#x2F;1不同，这也是实现多路复用的基础</li>
<li>自增性，流 ID 是不可重用的，会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li>
<li>双向性，客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</li>
<li>可以设置优先级，可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BD%91%E7%BB%9C/" class="category-chain-item">网络</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BD%91%E7%BB%9C/HTTP/" class="category-chain-item">HTTP</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/network/">#network</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>HTTP</div>
      <div>https://hgj1999.github.io/2023/04/26/网络/01.HTTP/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Glimmering Stars</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/" title="computed">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">computed</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/" title="observe">
                        <span class="hidden-mobile">observe</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      Ever Forward
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

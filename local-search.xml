<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>集成sortablejs实现拖拽功能</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E9%9B%86%E6%88%90sortablejs%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E9%9B%86%E6%88%90sortablejs%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p><code>darg mixins</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs vue">/*<br> * drag mixins<br> */<br>import Sortable from &#x27;sortablejs&#x27;<br>import SIcon from &#x27;@/components/icon&#x27;<br>export default &#123;<br>  props: &#123;<br>    drag: &#123;<br>      type: Boolean,<br>      default: false<br>    &#125;,<br>    rowKey: &#123;<br>      type: String, // 唯一key<br>      default: &#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  data: &#123;<br>    oldData: &#123;&#125;,<br>    curEl: null,<br>  &#125;,<br>  watch: &#123;<br>    data: &#123;<br>      immediate: true,<br>      deep: true,<br>      handler () &#123;<br>        if (!this.drag) &#123;<br>          return;<br>        &#125;<br>        this.initRowDrag();<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  coputed: &#123;<br>    isFixedLeft() &#123;<br>      this.columns.some(col =&gt; col.fixed === &#x27;left&#x27;);<br>    &#125;<br>  &#125;,<br>  beforeDestroy() &#123;<br>    if (this.sortable) &#123;<br>      this.sortable.destroy();<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    initDragColumn(columns) &#123;<br>      if (!this.drag) &#123;<br>        return;<br>      &#125;<br>      columns.unshift(&#123;<br>        title: &#x27;&#x27;,<br>        key: &#x27;drag&#x27;,<br>        width: 52,<br>        resizable: false,<br>        fixed: &#x27;left&#x27;,<br>        type: &#x27;drag&#x27;,<br>        render: (h) =&gt; &#123;<br>          return h(&#x27;span&#x27;, &#123;<br>            class: &#x27;drag-btn&#x27;,<br>          &#125;, [<br>            h(SIcon, &#123;<br>              style: &#123;<br>                cursor: &#x27;pointer&#x27;<br>              &#125;,<br>              props: &#123;<br>                icon: &#x27;sort&#x27;,<br>                size: 16<br>              &#125;<br>            &#125;)<br>          ]);<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    initRowDrag () &#123;<br>      this.$nextTick(() =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          // 固定列采用显示隐藏列的方案<br>          const xTable = this.$refs.sTable<br>          let dragBody = xTable.$el.querySelector(&#x27;.vxe-table--fixed-left-wrapper .vxe-table--body tbody&#x27;)<br>          if (!dragBody) &#123;<br>            dragBody = xTable.$el.querySelector(&#x27;.vxe-table--body-wrapper .vxe-table--body tbody&#x27;)<br>          &#125;<br>          if (this.sortable) &#123;<br>            this.sortable.destroy();<br>          &#125;<br>          this.sortable = Sortable.create(dragBody, &#123;<br>            handle: &#x27;.drag-btn&#x27;,<br>            animation: 150,<br>            onMove: (e, originalEvent) =&gt; &#123;<br>              const classNames = e.related._prevClass.split(&#x27; &#x27;)<br>              this.curEl = xTable.$el.querySelector(&#x27;.ghost&#x27;)<br>              if(~classNames.indexOf(&#x27;row-disabled&#x27;)) &#123;<br>                return false<br>              &#125; else &#123;<br>                return true<br>              &#125;<br>            &#125;,<br>            onStart: (e) =&gt; &#123;<br>              const &#123; oldIndex &#125; = e<br>              const &#123; tableData &#125; = this.$refs.sTable.getTableData();<br>              const &#123; visibleData &#125; = this.$refs.sTable.getTableData();<br>              let oldData = &#123;&#125;<br>              let isVirtualScroll = false<br>              if(visibleData.length &gt; xTable.scrollY.gt) &#123;<br>                // 开启虚拟滚动<br>                isVirtualScroll = true<br>              &#125;<br>              if(isVirtualScroll) &#123;<br>                oldData = visibleData.find(item =&gt; item[this.rowKey] === tableData[oldIndex][this.rowKey])<br>              &#125; else &#123;<br>                oldData = visibleData.filter(item =&gt; item._X_ROW_KEY === tableData[oldIndex]._X_ROW_KEY)[0]<br>              &#125;<br>              console.log(&#x27;dragStart-oldData&#x27;, oldData)<br>              this.oldData = oldData<br>            &#125;,<br>            ghostClass:&quot;ghost&quot;,<br>            onEnd: ( e) =&gt; &#123;<br>              const &#123; newIndex, oldIndex &#125; = e<br><br>              if (newIndex === oldIndex) return <br>              let isVirtualScroll = false<br>              // 考虑长列表情况需要对index做转换<br>              const &#123; tableData &#125; = this.$refs.sTable.getTableData();<br>              let &#123; visibleData &#125; = this.$refs.sTable.getTableData();<br>              let newData = &#123;&#125;<br>              if(visibleData.length &gt; xTable.scrollY.gt) &#123;<br>                // 开启虚拟滚动<br>                isVirtualScroll = true<br>              &#125;<br>              <br>              let fullDataOldIndex, fullDataNewIndex<br>              if(this.rowKey &amp;&amp; isVirtualScroll) &#123;<br>                newData = visibleData.find(item =&gt; item[this.rowKey] === tableData[newIndex][this.rowKey])<br>                fullDataNewIndex = visibleData.findIndex(item =&gt; item[this.rowKey] === newData[this.rowKey])<br>                fullDataOldIndex = visibleData.findIndex(item =&gt; item[this.rowKey] === this.oldData[this.rowKey])<br>              &#125; else &#123;<br>                newData = tableData.filter(item =&gt; item._X_ROW_KEY === tableData[newIndex]._X_ROW_KEY)[0]<br>                fullDataNewIndex = visibleData.findIndex(item =&gt; item._X_ROW_KEY === tableData[newIndex]._X_ROW_KEY)<br>                fullDataOldIndex = visibleData.findIndex(item =&gt; item._X_ROW_KEY === tableData[oldIndex]._X_ROW_KEY)<br>              &#125;<br>              if(this.curEl &amp;&amp; Math.abs(fullDataNewIndex-fullDataOldIndex) &gt; xTable.scrollY.gt ) &#123;<br>                this.curEl.style.display = &#x27;none&#x27;<br>              &#125;<br>              console.log(&#x27;dragEnd-newData&#x27;, newData)<br>              console.log(&#x27;fullDataOldIndex&#x27;, fullDataOldIndex)<br>              console.log(&#x27;fullDataNewIndex&#x27;, fullDataNewIndex)<br>              this.$emit(&#x27;on-row-drag&#x27;, &#123;<br>                oldIndex: fullDataOldIndex,<br>                newIndex: fullDataNewIndex,<br>              &#125;);<br>            &#125;<br>          &#125;)<br>        &#125;, 300);<br>      &#125;)<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
      <category>drag</category>
      
      <category>sortablejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mixins 实现方案</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/Mixins%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/Mixins%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Mixins"><a href="#什么是-Mixins" class="headerlink" title="什么是 Mixins"></a>什么是 Mixins</h1><p>VueJS的混入方式，把可复用的代码混入当前的代码里面。<br>VueJS中使用Mixins</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">// define a mixin object<br>var myMixin = &#123;<br>created: funtion() &#123;<br>this.hello()<br>&#125;,<br>methods: &#123;<br>hello: funtion() &#123;<br>console.log(&#x27;hello from mixin!&#x27;)<br>&#125;<br>&#125;<br>&#125;<br>// define a component that users this mixin<br>var Component = Vue.extend(&#123;<br>mixins:[myMixin]<br>&#125;)<br>var component = new Component() // =&gt; &quot;hello from mixin!&quot;<br></code></pre></td></tr></table></figure><h1 id="Mixins-的机制"><a href="#Mixins-的机制" class="headerlink" title="Mixins 的机制"></a>Mixins 的机制</h1><h2 id="关于生命周期函数的执行顺序："><a href="#关于生命周期函数的执行顺序：" class="headerlink" title="关于生命周期函数的执行顺序："></a>关于生命周期函数的执行顺序：</h2><p>如果在上一个例子的基础上，在新建组件Component里面也定义一个created()方法，那么是哪个created()先执行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">var Component = Vue.extend(&#123;<br>  mixins: [myMixin],<br>  created: function () &#123;<br>    console.log(&#x27;hello from Component!&#x27;)<br>  &#125;<br>&#125;)<br><br>var component = new Component()<br><br>// Hello from mixin!<br>// Hello from Component!<br></code></pre></td></tr></table></figure><p>说明 Mixins 的生命周期函数先于新建组件的生命周期函数执行</p><h2 id="对象属性的混入结果"><a href="#对象属性的混入结果" class="headerlink" title="对象属性的混入结果"></a>对象属性的混入结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">// define a mixin object<br>const myMixin = &#123;<br>data() &#123;<br>return &#123;<br>mixinData: &#x27;data from mixin&#x27;<br>&#125;<br>&#125;<br>&#125;<br>// define a component that uses this mixin<br>var Component = Vue.extend(&#123;<br>mixins: [myMixin],<br>data () &#123;<br>return &#123;<br>componentData: &#x27;data from component&#x27;<br>&#125;<br>&#125;,<br>mounted () &#123;<br>console.log(this.$data)<br>&#125;<br>&#125;)<br>var component = new Component()<br></code></pre></td></tr></table></figure><p>在 VueJS中，会把来自Mixins和组件的对象属性当中的内容（如data，methods等）混合，以确保两边的数据都同时存在。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>生命周期属性，会优先执行来自Mixins当中的，后执行来自组件当中的</li><li>对象类型属性，来自Mixins和来自组件中的会共存。</li></ol><h1 id="小程序的区别"><a href="#小程序的区别" class="headerlink" title="小程序的区别"></a>小程序的区别</h1><p>但是在小程序中，这套机制会和VueJS的有一点区别。在小程序中，自定义的方法是直接定义在Page的属性当中的，既不属于生命周期类型属性，也不属于对象类型属性，为了不引入奇怪的问题，我们为小程序的Mixins运行机制多加一条：</p><ol><li>小程序中自定义方法，优先级为Page&gt;Mixins，即Page中自定义方法会覆盖Mixins当中的。</li></ol><h1 id="小程序的实现"><a href="#小程序的实现" class="headerlink" title="小程序的实现"></a>小程序的实现</h1><p>在小程序中，每个页面都由Page(options)函数定义，而Mixins则作用于这个函数当中的options对象。因此我们实现Mixins的思路就有了—–劫持并改写Page函数，最后再重新把它释放出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存原生的 Page 函数</span><br><span class="hljs-keyword">const</span> originPage = <span class="hljs-title class_">Page</span><br><span class="hljs-title class_">Page</span> = <span class="hljs-function">(<span class="hljs-params">options</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> mixins = options.<span class="hljs-property">mixins</span><br><span class="hljs-comment">// mixins 必须为数组</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(mixins)) &#123;<br><span class="hljs-keyword">delete</span> options.<span class="hljs-property">mixins</span><br><span class="hljs-comment">// mixins 注入并执行相应逻辑</span><br>options = <span class="hljs-title function_">merge</span>(mixins, options)<br>&#125;<br><span class="hljs-comment">// 释放原生 Page 函数</span><br><span class="hljs-title function_">originPage</span>(options)<br>&#125;<br></code></pre></td></tr></table></figure><p>原理很简单，关键的地方在于merge()函数。merge函数即为小程序Mixins运行机制的具体实现，完全按照上一节总结的三条结论来进行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义小程序内置的属性/方法</span><br><span class="hljs-keyword">const</span> originProperties = [<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;properties&#x27;</span>, <span class="hljs-string">&#x27;options&#x27;</span>]<br><span class="hljs-keyword">const</span> originMethods = [<span class="hljs-string">&#x27;onLoad&#x27;</span>, <span class="hljs-string">&#x27;onReady&#x27;</span>, <span class="hljs-string">&#x27;onShow&#x27;</span>, <span class="hljs-string">&#x27;onHide&#x27;</span>, <span class="hljs-string">&#x27;onUnload&#x27;</span>,<span class="hljs-string">&#x27;onPullDownRefresh&#x27;</span>,<span class="hljs-string">&#x27;onReachBottom&#x27;</span>,<span class="hljs-string">&#x27;onShareAppMessage&#x27;</span>,<span class="hljs-string">&#x27;onPageScroll&#x27;</span>,<span class="hljs-string">&#x27;onTabItemTap&#x27;</span>]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span> (mixins, options) &#123;<br>mixins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">mixin</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(mixin) !== <span class="hljs-string">&#x27;[object Object]&#x27;</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;mixin 类型必须为对象！&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 遍历 mixin 里面的所有属性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(mixin)) &#123;<br><span class="hljs-keyword">if</span> (originProperties.<span class="hljs-title function_">includes</span>(key)) &#123;<br><span class="hljs-comment">// 内置对象属性混入</span><br>options[key] = &#123; ...value, ...options[key] &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originMethods.<span class="hljs-title function_">includes</span>(key)) &#123;<br><span class="hljs-comment">// 内置方法属性混入，优先执行混入部分</span><br><span class="hljs-keyword">const</span> originFunc = options[key]<br>options[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, arges)<br><span class="hljs-keyword">return</span> originFunc &amp;&amp; originFunc.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 自定义方法混入</span><br>options = &#123; ...mixin, ...options &#125;<br>&#125;<br>&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> options<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Mixins使用"><a href="#Mixins使用" class="headerlink" title="Mixins使用"></a>Mixins使用</h1><ol><li>在小程序的 app.js 里面引入mixins.js <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mixins.js&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>写一个myMixin.js <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">someData</span>: <span class="hljs-string">&#x27;myMixin&#x27;</span> &#125;,<br>  onShow () &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Log from mixin!&#x27;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在page&#x2F;index&#x2F;index.js 中使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">mixins</span>: [<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../myMixin.js&#x27;</span>)]<br>&#125;)<br></code></pre></td></tr></table></figure>具体实现代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义Minxin</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 保存原生的 Page 函数</span><br><span class="hljs-keyword">const</span> originPage = <span class="hljs-title class_">Page</span><br><br><span class="hljs-comment">// 局部使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Page01</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mixins = options.<span class="hljs-property">mixins</span><br>  <span class="hljs-comment">// mixins 必须为数组</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(mixins)) &#123;<br>    <span class="hljs-keyword">delete</span> options.<span class="hljs-property">mixins</span><br>    <span class="hljs-comment">// mixins 注入并执行相应逻辑</span><br>    options = <span class="hljs-title function_">merge</span>(mixins, options)<br>  &#125;<br>  <span class="hljs-comment">// 释放原生 Page 函数</span><br>  <span class="hljs-title function_">originPage</span>(options)<br>&#125;<br><span class="hljs-comment">// 定义小程序内置的属性/方法</span><br><span class="hljs-keyword">const</span> originProperties = [<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;properties&#x27;</span>, <span class="hljs-string">&#x27;options&#x27;</span>]<br><span class="hljs-keyword">const</span> originMethods = [<span class="hljs-string">&#x27;onLoad&#x27;</span>, <span class="hljs-string">&#x27;onReady&#x27;</span>, <span class="hljs-string">&#x27;onShow&#x27;</span>, <span class="hljs-string">&#x27;onHide&#x27;</span>, <span class="hljs-string">&#x27;onUnload&#x27;</span>, <span class="hljs-string">&#x27;onPullDownRefresh&#x27;</span>, <span class="hljs-string">&#x27;onReachBottom&#x27;</span>, <span class="hljs-string">&#x27;onShareAppMessage&#x27;</span>, <span class="hljs-string">&#x27;onPageScroll&#x27;</span>, <span class="hljs-string">&#x27;onTabItemTap&#x27;</span>]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span> (mixins, options) &#123;<br>  mixins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">mixin</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(mixin) !== <span class="hljs-string">&#x27;[object Object]&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;mixin 类型必须为对象！&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 遍历 mixin 里面的所有属性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(mixin)) &#123;<br>      <span class="hljs-keyword">if</span> (originProperties.<span class="hljs-title function_">includes</span>(key)) &#123;<br>        <span class="hljs-comment">// 内置对象属性混入</span><br>        options[key] = &#123; ...value, ...options[key] &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originMethods.<span class="hljs-title function_">includes</span>(key)) &#123;<br>        <span class="hljs-comment">// 内置方法属性混入，优先执行混入的部分</span><br>        <span class="hljs-keyword">const</span> originFunc = options[key]<br>        options[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>          value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>          <span class="hljs-keyword">return</span> originFunc &amp;&amp; originFunc.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 自定义方法混入</span><br>        options = &#123; ...mixin, ...options &#125;<br>        <span class="hljs-comment">// options[key] = value</span><br>      &#125;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> options<br>&#125;<br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">Page01</span> &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/uniapp/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/uniapp/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="upload-组件"><a href="#upload-组件" class="headerlink" title="upload 组件"></a>upload 组件</h2><p>ios真机一次最多可选择9个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&quot;scss&quot; scoped&gt;<br>.upload &#123;<br>&amp;__list &#123;<br>display: flex;<br>flex-wrap: wrap;<br>background: #fff;<br><br>&amp;--items &#123;<br>margin-right: 36rpx;<br>margin-bottom: 36rpx;<br>position: relative;<br><br>.value &#123;<br>width: 138rpx;<br>height: 138rpx;<br>border-radius: 6rpx;<br>vertical-align: top;<br>&#125;<br>.value2 &#123;<br>width: 246rpx;<br>height: 138rpx;<br>border-radius: 6rpx;<br>&#125;<br><br>.close &#123;<br>width: 30rpx;<br>height: 30rpx;<br>right: -10rpx;<br>top: -10rpx;<br>position: absolute;<br>&#125;<br><br>&amp;:nth-child(4n) &#123;<br>margin-right: 0;<br>&#125;<br>&#125;<br><br>&amp;--card &#123;<br>width: 138rpx;<br>height: 138rpx;<br>margin-bottom: 20rpx;<br>border-radius: 6rpx;<br>background: #f5f5f5;<br>display: flex;<br>flex-flow: column;<br>align-items: center;<br>justify-content: center;<br>border: 1rpx solid #e6e6e6;<br><br>.iconfont &#123;<br>font-size: 70rpx;<br>color: #8e8e8e;<br>&#125;<br>&#125;<br>&#125;<br><br>&amp;__tips &#123;<br>font-size: 30rpx;<br>font-weight: 400;<br>font-size: 24rpx;<br>font-family: PingFangSC-Regular, PingFang SC;<br>font-weight: 400;<br>color: #909090;<br>&#125;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;template&gt;<br>&lt;view class=&quot;upload&quot;&gt;<br>&lt;view class=&quot;upload__list&quot;&gt;<br>&lt;view<br>class=&quot;upload__list--items&quot;<br>v-for=&quot;(item, index) in tempFilePaths&quot;<br>:key=&quot;index&quot;<br>&gt;<br>&lt;image<br>v-if=&quot;uploadType === &#x27;img&#x27;&quot;<br>class=&quot;value&quot;<br>:src=&quot;item&quot;<br>@click=&quot;handlePreview(item)&quot;<br>&gt;&lt;/image&gt;<br>&lt;video v-else class=&quot;value2&quot; :src=&quot;item&quot;&gt;&lt;/video&gt;<br>&lt;img<br>class=&quot;close&quot;<br>v-if=&quot;isEdit&quot;<br>src=&quot;./images/close.png&quot;<br>alt=&quot;&quot;<br>@click=&quot;handleRemove(index)&quot;<br>/&gt;<br>&lt;/view&gt;<br>&lt;view<br>class=&quot;upload__list--card&quot;<br>@click=&quot;handleClick&quot;<br>v-if=&quot;tempFilePaths.length &lt; len &amp;&amp; isEdit&quot;<br>&gt;<br>&lt;u-icon name=&quot;plus&quot; size=&quot;34&quot; color=&quot;#999999&quot;&gt;&lt;/u-icon&gt;<br>&lt;/view&gt;<br>&lt;/view&gt;<br>&lt;view class=&quot;upload__tips&quot; v-if=&quot;isEdit&quot;&gt;&#123;&#123; tips &#125;&#125;&lt;/view&gt;<br>&lt;/view&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name: &quot;s-upload&quot;,<br>data() &#123;<br>return &#123;<br>tempFilePaths: [],<br>formData: [],<br>curUploadIndex: 0<br>&#125;;<br>&#125;,<br>props: &#123;<br>imgsData: &#123;<br>type: Array,<br>default: () =&gt; []<br>&#125;,<br>len: &#123;<br>type: Number,<br>default: 9<br>&#125;,<br>isEdit: &#123;<br>type: Boolean,<br>default: true<br>&#125;,<br>extraData: &#123;<br>type: Object,<br>default: () =&gt; &#123;&#125;<br>&#125;,<br>tips: &#123;<br>type: String,<br>default: &quot;&quot;<br>&#125;,<br>uploadType: &#123;<br>type: String,<br>default: &quot;img&quot;<br>&#125;,<br>maxSize: &#123;<br>type: String || Number,<br>default: &quot;3&quot;<br>&#125;<br>&#125;,<br>watch: &#123;<br>imgsData: &#123;<br>handler(value) &#123;<br>this.tempFilePaths = value<br>.filter(item =&gt; item.cdn_url)<br>.map(item =&gt; item.cdn_url);<br>this.formData = value;<br>console.log(&quot;imgsData---&quot;, this.tempFilePaths);<br>console.log(&quot;formData---&quot;, this.formData);<br>&#125;,<br>immediate: true<br>&#125;<br>&#125;,<br>methods: &#123;<br>async handleUpload(tempFilePath) &#123;<br>const result = await this.uploadFile(<br>&quot;your oss upload url&quot;,<br>&#123;<br>name: tempFilePath.split(&quot;/&quot;).pop(),<br>ext_name: tempFilePath.split(&quot;.&quot;).pop()<br>&#125;,<br>tempFilePath<br>);<br>return result;<br>&#125;,<br>async uploadFile(url, params, tempFilePath) &#123;<br>console.log(&quot;uploadFile---------------&quot;);<br>const res = await this.$post(url, params, false, true);<br>const action = res.url.replace(&quot;http&quot;, &quot;https&quot;);<br>let that = this;<br>return new Promise((resolve, reject) =&gt; &#123;<br>uni.uploadFile(&#123;<br>url: action,<br>filePath: tempFilePath,<br>name: &quot;file&quot;,<br>formData: &#123;<br>...res.params<br>&#125;,<br>success: function(result) &#123;<br>if (result.statusCode === 200) &#123;<br>that.formData.push(&#123;<br>cdn_url: tempFilePath,<br>url: res.params.key<br>&#125;);<br>resolve(true);<br>&#125;<br>&#125;,<br>fail: function(err) &#123;<br>reject(false);<br>&#125;<br>&#125;);<br>&#125;);<br>&#125;,<br>handleRemove(index) &#123;<br>this.tempFilePaths.splice(index, 1);<br>this.formData.splice(index, 1);<br>console.log(&quot;handleRemove-index&quot;, index);<br>console.log(&quot;handleRemove-formData&quot;, this.formData);<br>this.$emit(&quot;uploadSuccess&quot;, this.formData);<br>&#125;,<br>handlePreview(url) &#123;<br>uni.previewImage(&#123;<br>current: url, // 当前显示图片的http链接<br>urls: this.tempFilePaths // 需要预览的图片http链接列表<br>&#125;);<br>&#125;,<br>handleClick() &#123;<br>let that = this,<br>mediaType = [&quot;image&quot;];<br>if (this.uploadType === &quot;video&quot;) &#123;<br>mediaType = [&quot;video&quot;];<br>&#125;<br>uni.chooseMedia(&#123;<br>count: that.len &gt; 9 ? 9 : that.len, // ios 最大为 9<br>sizeType: [&quot;original&quot;, &quot;compressed&quot;], // 可以指定是原图还是压缩图，默认二者都有<br>sourceType: [&quot;album&quot;, &quot;camera&quot;], // 可以指定来源是相册还是相机，默认二者都有<br>mediaType: mediaType,<br>maxDuration: 60,<br>success: async res =&gt; &#123;<br>this.$emit(&quot;on-start-upload&quot;);<br>uni.showLoading(&#123; title: &quot;上传中&quot;, mask: true &#125;);<br>// 如果单次选择大于最大上传数量的时. 直接把多余的给截取<br>let tempFilePaths = res.tempFiles;<br>let showLimitLenTip = false;<br>if (res.tempFiles.length + that.tempFilePaths.length &gt; that.len) &#123;<br>showLimitLenTip = true;<br>tempFilePaths = tempFilePaths.slice(<br>0,<br>that.len - that.tempFilePaths.length<br>);<br>&#125;<br>let showLimitTip = false;<br>tempFilePaths = tempFilePaths<br>.filter(file =&gt; &#123;<br>let maxSize = that.maxSize * 1024 * 1024; // 大小限制<br>if (file.size &gt; maxSize) &#123;<br>showLimitTip = true;<br>&#125;<br>return file.size &lt;= maxSize;<br>&#125;)<br>.map(file =&gt; file.tempFilePath);<br><br>if (tempFilePaths.length &lt; 0) &#123;<br>uni.hideLoading();<br>return;<br>&#125;<br>tempFilePaths = await Promise.all(<br>tempFilePaths.map(async tempFilePath =&gt; &#123;<br>const result = await that.handleUpload(tempFilePath);<br>return result ? tempFilePath : null;<br>&#125;)<br>);<br>tempFilePaths = tempFilePaths.filter(<br>tempFilePath =&gt; tempFilePath !== null<br>);<br>if (showLimitTip) &#123;<br>uni.hideLoading();<br>setTimeout(() =&gt; &#123;<br>uni.showToast(&#123;<br>title: `上传$&#123;<br>that.uploadType === &quot;video&quot; ? &quot;视频&quot; : &quot;图片&quot;<br>&#125;太大，超过$&#123;that.maxSize&#125;M限制`,<br>icon: &quot;none&quot;,<br>duration: 2000,<br>&#125;);<br>&#125;);<br>&#125;<br>if (showLimitLenTip) &#123;<br>uni.hideLoading();<br>setTimeout(() =&gt; &#123;<br>uni.showToast(&#123;<br>title: `上传$&#123;<br>that.uploadType === &quot;video&quot; ? &quot;视频&quot; : &quot;图片&quot;<br>&#125;数量，超过$&#123;that.len&#125;个长度限制`,<br>icon: &quot;none&quot;,<br>duration: 2000,<br>&#125;);<br>&#125;);<br>&#125;<br>that.$emit(&quot;uploadSuccess&quot;, that.formData);<br>that.tempFilePaths = that.tempFilePaths.concat(tempFilePaths);<br>&#125;,<br>fail: err =&gt; &#123;&#125;<br>&#125;);<br>&#125;,<br>handleReset() &#123;<br>Object.assign(this.$data, this.$options.data());<br>&#125;<br>&#125;,<br>mounted() &#123;&#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="textarea-组件"><a href="#textarea-组件" class="headerlink" title="textarea 组件"></a>textarea 组件</h2><p>真机bug，可以输入超过<code>maxlength</code>的字符，并且会在<code>count</code>上显示出来<br>解决办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&#x27;scss&#x27; scoped&gt;<br>.u-textarea &#123;<br>background-color: #f5f5f5;<br>border-radius: 6rpx;<br>padding: 12rpx 12rpx 40rpx 12rpx;<br>position: relative;<br>&amp;__field &#123;<br>flex: 1;<br>font-size: 15px;<br>// color: #C5C5C5;<br>width: 100%;<br>&#125;<br>&amp;__count &#123;<br>position: absolute;<br>right: 12rpx;<br>bottom: 8rpx;<br>font-size: 20rpx;<br>color: #999999;<br>padding: 1rpx 4rpx;<br>&#125;<br>&#125;<br>&lt;/style&gt;<br>&lt;template&gt;<br>&lt;div class=&quot;s-textarea u-textarea&quot;&gt;<br>&lt;textarea<br>:style=&quot;&#123;<br>height: `$&#123;height&#125;rpx`<br>&#125;&quot;<br>class=&quot;u-textarea__field&quot;<br>placeholder-style=&quot;#C5C5C5&quot;<br>@input=&quot;input&quot;<br>:disabled=&quot;disabled&quot;<br>:maxlength=&quot;maxlength&quot;<br>v-model=&quot;valueCopy&quot;<br>:placeholder=&quot;placeholder&quot;<br>&gt;<br>&lt;/textarea&gt;<br>&lt;text v-if=&quot;count&quot; class=&quot;u-textarea__count&quot;&gt;<br>&#123;&#123; valueCopy.length &#125;&#125;/&#123;&#123; maxlength &#125;&#125;<br>&lt;/text&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name: &quot;s-textarea&quot;,<br>components: &#123;&#125;,<br><br>props: &#123;<br>value: &#123;<br>type: String,<br>default: &quot;&quot;<br>&#125;,<br>placeholder: &#123;<br>type: String,<br>default: &quot;请输入&quot;<br>&#125;,<br>maxlength: &#123;<br>type: String || Number,<br>default: &#x27;-1&#x27;<br>&#125;,<br>disabled: &#123;<br>type: Boolean,<br>default: false<br>&#125;,<br>count: &#123;<br>type: Boolean,<br>default: false<br>&#125;,<br>height: &#123;<br>type: String,<br>default: &#x27;120&#x27;<br>&#125;<br>&#125;,<br>data() &#123;<br>return &#123;<br>valueCopy: &quot;&quot;<br>&#125;;<br>&#125;,<br><br>computed: &#123;&#125;,<br><br>watch: &#123;<br>value: &#123;<br>handler(val) &#123;<br>this.valueCopy = val;<br>&#125;,<br>immediate: true<br>&#125;,<br>valueCopy: &#123;<br>handler(val) &#123;<br>this.$emit(&quot;input&quot;, val);<br>this.$emit(&quot;change&quot;, val);<br>&#125;<br>&#125;<br>&#125;,<br><br>created() &#123;&#125;,<br><br>mounted() &#123;&#125;,<br><br>methods: &#123;<br>input(e) &#123;<br>let value = e.detail.value;<br>console.log(&quot;value-------&quot;, value);<br>if (this.maxlength &gt; 0 &amp;&amp; value.length &gt; this.maxlength) &#123;<br>this.$nextTick(() =&gt; &#123;<br>this.valueCopy = value.substr(0, this.maxlength);<br>&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>uniapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul><li><code>undefined</code></li><li><code>Null</code></li><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code> (ES6)</li><li><code>Bigint</code> (ES6)</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li><code>Object</code><ul><li><code>Object</code> (<code>Array</code>, <code>Date</code>…)</li><li><code>Function</code></li></ul></li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>在发生转换的时候，js其实都是会将操作对象转化为原始的对象</p><h2 id="ToPrimitive-原始值转换算法"><a href="#ToPrimitive-原始值转换算法" class="headerlink" title="ToPrimitive(原始值转换算法)"></a>ToPrimitive(原始值转换算法)</h2><p>注意：<code>Date</code>类型按照<code>String</code>去调用</p><ol><li>输入为原始类型，直接返回</li><li>输入非原始类型，调用该对象的<code>valueOf()</code>方法，如果结果是原始类型，返回</li><li>调用<code>valueOf()</code>结果不是原始类型，再对结果，调用<code>toString()</code>方法，如果结果为原始类型，返回</li><li>如果返回不是原始类型，抛出异常<code>TypeError</code></li></ol><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> srt = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-keyword">let</span> num = str - <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = =<span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> str = num + <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这种类似的数学运算会做类型转换<br><code>*</code>，<code>/</code>和<code>-</code>操作符都是数字运算专用的。当这些运算符与字符串一起使用时，会强制转换字符串为数字类型的值。<br><code>+</code>的特殊之处 </p><ul><li><code>+</code>作为双目运算符，例如<code>a + b</code><ul><li>计算两个操作数的原始类型<code>prima = Toprimitive(a), prima = ToPrimitive(b)</code></li><li>如果原始类型有<code>String</code>,全部转换为<code>String</code>，返回<code>String</code>相加后的结果</li><li>如果原始类型没有<code>String</code>，则全部转换为<code>Number</code>，返回<code>Number</code>相加后的结果</li></ul></li><li><code>+</code>作为单目运算符，例如<code>+a</code><ul><li>将<code>a</code>转换为<code>Number</code>，<code>Number(a)</code></li></ul></li></ul><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id=""><a href="#" class="headerlink" title="[]+[]"></a><code>[]+[]</code></h2><ol><li>转换为原始类型 <code>toPrimitive([])</code><ol><li><code>[].valueOf()</code>返回<code>[]</code>不是原始类型</li><li><code>[].toString()</code>返回<code>&#39;&#39;</code></li></ol></li><li>都为<code>String</code>所以返回字符串相加的结果</li><li><code>return &#39;&#39; + &#39;&#39;</code></li></ol><h2 id="-1"><a href="#-1" class="headerlink" title="{} + []"></a><code>&#123;&#125; + []</code></h2><ol><li>在浏览器中，<code>JS</code>引擎认为第一个<code>&#123;&#125;</code>为空代码，所以 这里的<code>+</code>是单目运算符<ol><li><code>node</code>中认为是对象，解析为<code>&quot;[object Object]&quot;</code></li></ol></li><li>转换为原始类型<code>toPrimitive([])</code>返回<code>&#39;&#39;</code></li><li><code>Number(&#39;&#39;)</code>返回<code>0</code></li></ol><h2 id="-2"><a href="#-2" class="headerlink" title="[] + {}"></a><code>[] + &#123;&#125;</code></h2><p>注意： <code>[].valueOf</code> 为<code>[]</code>, 但在ES6中JS会优先调用<code>[Symbol ToPrimitive]</code>来转换为原始类型。</p><ol><li>转换为原始类型<ol><li><code>[].toString()</code>返回<code>&#39;&#39;</code></li><li><code>&#123;&#125;.toString()</code>返回<code>&quot;[object Object]&quot;</code></li></ol></li><li>都为<code>String</code>返回字符串相加的结果<code>&quot;[object Object]&quot;</code></li></ol><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等==="></a>严格相等<code>===</code></h2><p>首先判断类型，类型一致，再判断值，都一致才会<code>return true</code>，否则<code>return false</code></p><h2 id="宽松相等"><a href="#宽松相等" class="headerlink" title="宽松相等=="></a>宽松相等<code>==</code></h2><p>先将操作数转换为相同类型，再做比较<br>例如<code>x == y</code></p><ol><li><code>x,y</code>都为<code>Null</code>或<code>undefined</code>，<code>return true</code></li><li><code>x</code>或<code>y</code>为<code>NaN</code>，<code>return false</code></li><li>如果<code>x</code>和<code>y</code>为<code>String``Number``Boolean</code>并且类型不一致，都转为<code>Number</code>再进行比较</li><li>如果存在<code>Object</code>，则转换为原始类型比较</li></ol><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><h3 id="false"><a href="#false" class="headerlink" title="[] == false"></a><code>[] == false</code></h3><ol><li>存在<code>Object</code>，转换为原始类型<ol><li><code>ToPrimitive([])</code>返回<code>&#39;&#39;</code></li></ol></li><li>存在一个<code>String</code>，另一个是<code>Boolean</code>；都转为<code>Number</code></li><li>都转为<code>Number</code><ol><li><code>Number(&#39;&#39;)</code>返回<code>0</code></li><li><code>Number(false)</code>返回<code>0</code></li></ol></li><li>再进行比较<ol><li><code>return 0 == 0</code>返回<code>true</code></li></ol></li></ol><h1 id="ToPrimitive转换规则"><a href="#ToPrimitive转换规则" class="headerlink" title="ToPrimitive转换规则"></a>ToPrimitive转换规则</h1><table><thead><tr><th>value</th><th>toNumber</th><th>toString</th><th>toBoolean</th></tr></thead><tbody><tr><td>NaN</td><td>NaN</td><td>“NaN”</td><td>false</td></tr><tr><td>Infinity</td><td>Infinity</td><td>“Infinity”</td><td>true</td></tr><tr><td>[]</td><td>0</td><td>‘“”</td><td>true</td></tr><tr><td>[1]</td><td>1</td><td>“1”</td><td>true</td></tr><tr><td>null</td><td>0</td><td>“null”</td><td>false</td></tr><tr><td>undefined</td><td>NaN</td><td>“undefined”</td><td>false</td></tr><tr><td>{}</td><td>NaN</td><td>“[object Object]”</td><td>true</td></tr><tr><td>function()</td><td>NaN</td><td>“function”</td><td>true</td></tr></tbody></table><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>NaN</td></tr><tr><td>null</td><td>0</td></tr><tr><td>Boolean值</td><td>true转换为1，false转换为+0</td></tr><tr><td>Number</td><td>无需转换</td></tr><tr><td>String</td><td>例如”1.1”转换成1.1</td></tr></tbody></table><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td></tr><tr><td>null</td><td>“null”</td></tr><tr><td>Boolean值</td><td>“true”或者”false”</td></tr><tr><td>String</td><td>无需转换</td></tr><tr><td>Number</td><td>例如1.1转换成”1.1”</td></tr></tbody></table><blockquote><p><code>toPrimitive([]) = &#39;&#39;</code>，可以想成<code>[].join()</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用堆栈与this</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02.%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E4%B8%8Ethis/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02.%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E4%B8%8Ethis/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的执行上下文和执行栈"><a href="#JavaScript-中的执行上下文和执行栈" class="headerlink" title="JavaScript 中的执行上下文和执行栈"></a>JavaScript 中的执行上下文和执行栈</h1><p>执行上下文是当前 Javascript 代码被解析和执行时所在环境的抽象概念。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><ul><li><strong>全局执行上下文：</strong>只有一个，浏览器中的全局对象：window ，<code>this</code>指向这个全局对象。</li><li><strong>函数执行上下文：</strong>函数每被调用一次，就会创建一个函数执行上下文。</li><li><strong>Eval 函数执行上下文：</strong>运行在<code>eval</code>函数中的代码，不常用</li></ul><h3 id="执行上下文的三个重要属性"><a href="#执行上下文的三个重要属性" class="headerlink" title="执行上下文的三个重要属性"></a>执行上下文的三个重要属性</h3><ul><li>变量对象（Variable Object，VO）</li><li>作用域链（Scope chain）</li><li>this</li></ul><h3 id="执行上下文的创建阶段"><a href="#执行上下文的创建阶段" class="headerlink" title="执行上下文的创建阶段"></a>执行上下文的创建阶段</h3><ul><li>确定 this 的值，This Binding</li><li>LexicalEnvironment（词法环境）组件被创建</li><li>VariableEnvironment（变量环境）组件被创建</li></ul><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ExecutionContext</span> = &#123;<br>  <span class="hljs-title class_">ThisBinding</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">this</span> <span class="hljs-attr">value</span>&gt;</span>, // 确定 this</span><br><span class="language-xml">  LexicalEnvironment = &#123;...&#125;, // 词法环境</span><br><span class="language-xml">  VariableEnvironment = &#123;...&#125;, // 变量环境</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h4><ul><li><strong>全局</strong>执行上下文中，<code>this</code> 指向全局对象，在浏览器指向 <code>window</code>，在<code>nodejs</code>中指向这个文件的<code>module</code>对象。</li><li><strong>函数</strong>执行上下文中，<code>this</code>的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定（硬绑定）、<code>new</code>绑定、箭头函数</li></ul><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><ul><li><strong>环境记录：</strong>存储变量和函数声明的实际位置</li><li><strong>对外部环境的引用：</strong>可以访问其外部词法环境</li></ul><p>词法环境又分为：</p><ul><li><strong>全局环境：</strong>没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</li><li><strong>函数环境：</strong>用户在函数中定义的变量被存储在<strong>环境记录</strong>中，包含了<code>arguments</code>对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li></ul><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GlobalExectionContext</span> = &#123; <span class="hljs-comment">// 全局执行上下文</span><br>  <span class="hljs-title class_">LexicalEnvironment</span>: &#123; <span class="hljs-comment">// 词法环境</span><br>  <span class="hljs-title class_">EnvironmentRecord</span>: &#123; <span class="hljs-comment">// 环境记录</span><br>    <span class="hljs-title class_">Type</span>: <span class="hljs-string">&quot;Object&quot;</span>,    <span class="hljs-comment">// 全局环境</span><br>      <span class="hljs-comment">// 标识符绑定在这里</span><br>      <span class="hljs-attr">outer</span>:&lt;<span class="hljs-literal">null</span>&gt;       <span class="hljs-comment">// 对外部环境的引用</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">FunctionExectionContext</span> = &#123; <span class="hljs-comment">// 函数执行上下文</span><br>  <span class="hljs-title class_">LexicalEnvironment</span>: &#123; <span class="hljs-comment">// 词法环境</span><br>  <span class="hljs-title class_">EnvironmentRecord</span>: &#123; <span class="hljs-comment">// 环境记录</span><br>  <span class="hljs-title class_">Type</span>: <span class="hljs-string">&quot;Declarative&quot;</span>, <span class="hljs-comment">// 函数环境</span><br>  <span class="hljs-comment">// 标识符绑定在这里     // 对外部环境的引用</span><br>  <span class="hljs-attr">outer</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Global</span> <span class="hljs-attr">or</span> <span class="hljs-attr">outer</span> <span class="hljs-attr">function</span> <span class="hljs-attr">environment</span> <span class="hljs-attr">reference</span>&gt;</span></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，<strong>词法</strong>环境和<strong>变量</strong>环境的区别在于<strong>前者用于存储函数声明和变量（</strong><code>**let**</code><strong>和</strong><code>**const**</code><strong>）绑定，而后者仅用于存储变量（</strong><code>**var**</code><strong>）绑定</strong></p><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> c;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">e, f</span>) &#123;<br>  <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">return</span> e * f * g;<br>&#125;<br>c = <span class="hljs-title function_">multiply</span>(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>执行上下文如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GlobalExectionContext</span> = &#123;<br>  <span class="hljs-title class_">ThisBinding</span>: &lt;Global Object&gt;,<br>  <br>  LexicalEnvironment: &#123;<br>  EnvironmentRecord: &#123;<br>  Type: &quot;Object&quot;,<br>  // 标识符绑定在这里<br>  a: &lt; uninitialized&gt;,<br>  b: &lt; uninitialized&gt;,<br>  multiply: &lt; func &gt;<br>&#125;<br>outer: &lt;null&gt;<br>&#125;,<br><br>VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 标识符绑定在这里<br>      c: undefined,<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  ThisBinding: &lt;Global Object&gt;,<br>  <br>  LexicalEnvironment: &#123;<br>  EnvironmentRecord: &#123;<br>  Type: &quot;Declarative&quot;,<br>  // 标识符绑定在这里<br>  Arguments: &#123;0: 20, 1: 30, length: 2&#125;,<br>&#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>&#125;,<br>  <br>  VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 标识符绑定在这里<br>      g: undefined<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 <code>undefined</code>（在 <code>var</code> 的情况下）或保持未初始化（在 <code>let</code> 和 <code>const</code> 的情况下）。所以这就是为什么可以在声明之前访问 <code>var</code> 定义的变量（尽管是 <code>undefined</code> ），但如果在声明之前访问 <code>let</code> 和 <code>const</code> 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h3 id="执行上下文的执行阶段"><a href="#执行上下文的执行阶段" class="headerlink" title="执行上下文的执行阶段"></a>执行上下文的执行阶段</h3><p>此阶段，完成对所有变量的分配，最后执行代码。</p><p>如果 JS 引擎在源代码中声明的实际位置找不到 <code>let</code> 变量的值，那么为其分配 <code>undefined</code> 值。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>是一个 LIFO（后进先出）的栈结构的数据类型，用于存储在代码执行期间所创建的执行上下文。</p><p>在 JS 的环境中：</p><p>首次运行 JS 代码时，会创建一个<strong>全局</strong>执行上下文并 push 到当前的执行栈中，每当发生函数调用，JS引擎都会为该函数创建一个新的函数执行上下文并且 push 到当前执行栈的栈顶。</p><p>当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中 pop 出，上下文控制权会交到当前执行栈的下一个执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside Global Exection Context&#x27;</span>)<br><span class="hljs-comment">// Inside first function</span><br><span class="hljs-comment">// Inside second function</span><br><span class="hljs-comment">// Again inside first function</span><br><span class="hljs-comment">// Inside Global Execution Context</span><br></code></pre></td></tr></table></figure><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/stack.png" alt="image.png"></p><h1 id="JavaScript-中的执行上下文栈和变量对象"><a href="#JavaScript-中的执行上下文栈和变量对象" class="headerlink" title="JavaScript 中的执行上下文栈和变量对象"></a>JavaScript 中的执行上下文栈和变量对象</h1><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>JS 引擎创建了很多的执行上下文，所以 JS 引擎创建了<strong>执行上下文栈</strong>（Execution context stack，ECS）来<strong>管理</strong>执行上下文。</p><p>当 JavaScript 初始化的时候会向执行上下文栈压入一个<strong>全局执行上下文</strong>，可以用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前，执行栈最底部永远有个 globalContext。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span> = [ <span class="hljs-comment">// 使用数组模拟栈</span><br>  globalContext<br>];<br></code></pre></td></tr></table></figure><p>demo1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> scope;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br></code></pre></td></tr></table></figure><p>demo2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> scope;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure><p>demo1 的执行上下文栈的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure><p>deno2 的执行上下文栈的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，用活动对象（activation object，AO）来表示变量对象</p><p>活动对象和变量对象的区别在于</p><ul><li>变量对象（VO）是规范上或者是 JS 引擎上实现的，并不能在 JS 环境中直接访问。</li><li>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。</li></ul><p>调用函数时，会为其创建一个 <strong>Arguments 对象</strong>，并且自动初始化局部变量 arguments，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象数组元素。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ul><li>进入执行上下文</li><li>代码执行</li></ul><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li>函数所有形参（函数上下文）：没有实参，属性值设为 undefined。</li><li>函数声明：如果变量对象已经存在相同名称的属性，则完全<strong>替换</strong>这个属性。</li><li>变量声明：如果变量名称和已经声明的形成或函数相同，则变量声明不会干扰已经存在的这类属性。</li></ul><p>demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-title function_">funcion</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>  b = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>此时的 AO：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">AO</span> = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>形参 arguments 这时候已经有赋值了，但是变量还是 undefined，只是初始化的值</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">AO</span> = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">d</span>: reference to <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>全局上下文的变量对象初始化时全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象<strong>添加形参、函数声明、变量声明</strong>等初始的属性</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ul><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>调用位置就是函数在代码中<strong>被调用的位置</strong>（而不是声明的位置）。</p><p>查找方法：</p><ul><li><p>分析调用栈：调用位置就是当前正在执行的函数的<strong>前一个调用</strong>中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz</span><br>    <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;baz&quot;</span> );<br>    <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar的调用位置</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz --&gt; bar</span><br>    <span class="hljs-comment">// 因此，当前调用位置在baz中</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;bar&quot;</span> );<br>    <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo的调用位置</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span><br>    <span class="hljs-comment">// 因此，当前调用位置在bar中</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> );<br>&#125;<br><br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz的调用位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用开发者工具得到调用栈：<br>设置断点或者插入<code>debugger;</code>语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是<strong>调用栈</strong>。找到栈中的<strong>第二个元素</strong>，这就是真正的调用位置。</p></li></ul><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul><li><strong>独立函数调用</strong>，无法应用其他规则时的默认规则，this 指向<strong>全局对象</strong>。</li><li><strong>严格模式</strong>下，不能将全局对象用于默认绑定，this 会绑定到 <code>undefined</code>。只有函数<strong>运行</strong>在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下<strong>调用</strong>函数则不影响默绑定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 运行在严格模式下，this会绑定到undefined</span><br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 调用</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span><br><br><span class="hljs-comment">// --------------------------------------</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 运行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 严格模式下调用函数则不影响默认绑定</span><br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>当函数引用有<strong>上下文对象</strong>时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><blockquote><p>隐式丢失</p></blockquote><p>被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span><br><span class="hljs-comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a是全局对象的属性</span><br><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">// fn其实引用的是foo</span><br>    <br>    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a是全局对象的属性</span><br><br><span class="hljs-title function_">doFoo</span>( obj.<span class="hljs-property">foo</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br><br><span class="hljs-comment">// ----------------------------------------</span><br><br><span class="hljs-comment">// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-comment">// 等待delay毫秒</span><br>    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>通过<code>call()</code>或者<code>apply()</code>方法。一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2  调用foo时强制把foo的this绑定到obj上</span><br></code></pre></td></tr></table></figure><p>显示绑定无法解决丢失绑定问题</p><p>解决方案：</p><ul><li>硬绑定</li></ul><p> 创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>foo.<span class="hljs-title function_">call</span>(obj)<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this</span><br></code></pre></td></tr></table></figure><p>应用场景：创建一个包裹函数，负责接收参数并返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p> 创建一个可以重复使用的辅助函数。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something );<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>( foo, obj );<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p> ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something );<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj );<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li>API 调用的”上下文“</li></ul><p> JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。<br>例如：forEach</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">// 调用foo(..)时把this绑定到obj</span><br>myArray.<span class="hljs-title function_">forEach</span>( foo, obj );<br><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span><br></code></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><ul><li>JS 中 <code>构造函数</code>只是使用 <code>new</code>操作符时被调用的<code>普通</code>函数</li><li>包括内置对象函数（比如<code>String(...)</code>）在内的所有函数都可以用<code>new</code>来调用，这种函数调用被称为构造函数调用</li><li>实际上不存在<code>构造函数</code>，只存在<code>对函数的构造调用</code></li></ul><h4 id="new-发生了什么"><a href="#new-发生了什么" class="headerlink" title="new 发生了什么"></a>new 发生了什么</h4><ul><li>创建（或者说构造）一个新对象</li><li>这个新对象会被执行<code>[[Prototype]]</code>连接</li><li>这个新对象会绑定到函数调用的<code>this</code></li><li>如果这个函数没有返回其他的对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 粗糙版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 创建一个空对象</span><br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-comment">// 获得构造函数 arguments 中第一个参数（即构造函数）</span><br>  <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 链接到原型， obj 可以访问到构造函数中的属性</span><br>  obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Con</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 优先返回构造函数返回的对象</span><br>  <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? ret : obj;<br>&#125;<br><span class="hljs-comment">// 精简版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">__new</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-keyword">const</span> ret = fn.<span class="hljs-title function_">apply</span>(obj, args);<br>  <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? ret : obj;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h3><p>以上四种都是<strong>this总是指向调用该函数的对象</strong></p><p>但是箭头函数是根据外层（函数或者全局）作用域（<strong>词法作用域</strong>）来决定this。<br>对于箭头函数的this总结如下：</p><ol><li>箭头函数不绑定this，箭头函数中的this相当于普通变量。</li><li>箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。</li><li>箭头函数的this<strong>无法通过bind，call，apply来直接修改</strong>（可以间接修改）。</li><li>改变作用域中this的指向可以改变箭头函数的this。</li><li><code>eg. function closure()&#123;()=&gt;&#123;//code &#125;&#125;</code>，在此例中，我们通过改变封包环境<code>closure.bind(another)()</code>，来改变箭头函数this的指向。</li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的内存空间"><a href="#JavaScript-的内存空间" class="headerlink" title="JavaScript 的内存空间"></a>JavaScript 的内存空间</h1><p>调用堆栈溢出：</p><p>调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.png" alt="image.png"></p><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈的结构就是后进先出（LIFO）</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.png" alt="image.png"></p><h2 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h2><p>堆数据结构是一种树状结构。它是以 <code>key-value</code> 的形式存取数据的，是无序的，只需要知道 <code>key</code> ，就可以取出 <code>value</code></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）的数据结构，是事件循环（Event Loop）的基础结构</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.png" alt="image.png"></p><h2 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h2><ul><li>基本数据类型：存放在<strong>栈</strong>内存中<strong>（不包含闭包中的变量）</strong>，因为这些类型在内存中分别占有固定大小的空间，通过<strong>按值访问</strong>。基本数据类型一共有 6 种：Undefined、Null、Bolleam、Number、String 和 Symbol</li><li>引用数据类型：<strong>值</strong>存放在<strong>堆</strong>内存中，因为这些类型所占的空间不确定，但是对应的<strong>引用地址</strong>存放在<strong>栈</strong>内存中。当查询引用类型的变量时，先从<strong>栈中读取相应的引用地址</strong>，然后再通过地址<strong>找到堆中对应的值</strong>，这种叫做<strong>按引用访问</strong>。</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.png" alt="image.png"></p><p>栈比堆的运算速度快，Object 是一个复杂结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将它们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中实际对象再进行操作。</p><h2 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h2><p>JavaScript 的内存生命周期：</p><ul><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放、归还</li></ul><p>JavaScript 有自动垃圾回收机制，最常用的是通过<strong>标记清除</strong>的算法来找到不再继续使用的对象，使用 <code>obj = null</code> 其实仅仅只是做了一个释放引用的操作，让 obj 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并且释放。</p><p>在函数作用域中，当函数执行完毕，函数作用域中的变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局的变量什么时候需要自动释放内存空间则很难判断，因此在开发中，尽量避免使用全局变量。</p><p>demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> b = a;<br>a.<span class="hljs-property">x</span> = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">x</span>)  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">x</span>)  <span class="hljs-comment">// &#123;n: 2&#125;</span><br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>优先级<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>&#123;n:1&#125;</code>就会变成<code>&#123;n: 1, x: undefined&#125;</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li><li>赋值操作是<code>从右到左</code>，所以先执行<code>a = &#123;n: 2&#125;</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，<strong>需要注意</strong>此时的<code>a.x</code>是第一步中的<code>&#123;n: 1, x: undefined&#125;</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = &#123;n:2&#125;</code></li></ul><h1 id="JavaScript-的内存机制"><a href="#JavaScript-的内存机制" class="headerlink" title="JavaScript 的内存机制"></a>JavaScript 的内存机制</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>:::info<br>对垃圾回收来说，核心思想就是如何判断对象已经不再具有<code>可达性</code>。<br>:::<br>JavaScript 有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值（不具有<code>可达性</code>的对象），然后释放其占用的内存。</p><ul><li>变量的销毁 <ul><li><strong>局部变量：</strong>局部作用域中，当函数执行完毕，局部变量就被垃圾收集器回收</li><li><strong>全局变量：</strong>全局变量什么时候需要自动释放内存空间很难判断，所以要尽量<strong>避免</strong>使用全局变量</li></ul></li><li>V8 引擎中所有的 JS 对象都是通过<strong>堆</strong>来进行内存分配的 <ul><li><strong>初始分配：</strong>当声明变量并赋值时，V8 引擎就会在堆内存中分配给这个变量。</li><li><strong>继续申请：</strong>当已申请的内存不足以存储这个变量时，V8 引擎就会继续申请内存，直到堆的大小达到了 V8 引擎的内存上限为止。</li></ul></li><li>V8 引擎对堆内存中的 JS 对象进行 <strong>分代管理</strong> <ul><li><strong>新生代：</strong>存活周期较短的 JS 对象，如临时变量、字符串等。</li><li><strong>老生代：</strong>经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul></li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>常用垃圾回收算法有下面两种。</p><ul><li>引用计数（现代浏览器不再使用）</li><li>标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>看一个对象是否有指向它的<strong>引用</strong>。如果没有其他对象指向它了，说明该对象需要被回收了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个对象 person，它有两个指向属性 age 和 name 的引用</span><br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bob&#x27;</span><br>&#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 虽然 name 设置为 null，但因为 person 对象还有指向 name 的引用，因此 name 不会被回收</span><br><span class="hljs-keyword">var</span> p = person;<br>person = <span class="hljs-number">1</span>; <span class="hljs-comment">// 原来的 person 对象被赋值为1，但因为有新引用 p 指向原 person 对象，因此它不会被回收</span><br>p = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 原 person 对象已经没有引用，很快会被回收</span><br></code></pre></td></tr></table></figure><h5 id="引用计数致命缺点-循环引用"><a href="#引用计数致命缺点-循环引用" class="headerlink" title="引用计数致命缺点-循环引用"></a>引用计数致命缺点-循环引用</h5><p>如果两个对象相互引用，尽管它们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cycle</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br>  <span class="hljs-keyword">var</span> o2 = &#123;&#125;;<br>  o1.<span class="hljs-property">a</span> = o2;<br>  o2.<span class="hljs-property">a</span> = o1;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cycle reference!&quot;</span><br>&#125;<br><span class="hljs-title function_">cycle</span>();<br></code></pre></td></tr></table></figure><p><code>cycle</code>函数执行完成之后，对象<code>o1</code>和<code>o2</code>实际上已经不再需要了，但根据引用计数的原则，它们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器<strong>不再使用</strong>这个垃圾回收算法。</p><p>但是 IE 依旧使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>div.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;click&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>变量 div 有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为<strong>“无法到达的对象”（不具有可达性的对象）</strong>。即从根部（全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象就认为<strong>此对象具有可达性，保留</strong>；那些从根部出发无法到达的对象就被标记为<strong>此对象不具有可达性</strong>，稍后进行回收。</p><p>无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。</p><p>所以上面的例子就可以正确被垃圾回收处理了。</p><p>所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">email.<span class="hljs-property">message</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>)<br>displayList.<span class="hljs-title function_">appendChild</span>(email.<span class="hljs-property">message</span>)<br><span class="hljs-comment">// 稍后从 displayList 中清除 DOM 元素</span><br>displayList.<span class="hljs-title function_">removeAllChildren</span>();<br></code></pre></td></tr></table></figure><p>上面代码中，<code>div</code>元素已经从DOM树中清除，但是该<code>div</code>元素还绑定在email对象中，所以如果email对象存在，那么该<code>div</code>元素就会一直保存在内存中。<br><strong>缺点：</strong></p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块， 还可能会出现分配所需内存过大的对象时找不到合适的块</li></ul><h4 id="标记整理（有效解决内存碎片化）"><a href="#标记整理（有效解决内存碎片化）" class="headerlink" title="标记整理（有效解决内存碎片化）"></a>标记整理（有效解决内存碎片化）</h4><p> 它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.png" alt="image.png"></p><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><ul><li><strong>新生代：</strong>存活周期较短的 JS 对象，如临时变量、字符串等。（1-8M）</li><li><strong>老生代：</strong>经过新生代垃圾回收后还存活下的对象，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><p>内存分代管理图<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/06.png" alt="image.png"><br> 对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控  </p><h4 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h4><p>通过<code>Scavenge</code>的算法进行垃圾回收，主要采用其中的<code>Cheney</code>算法<br><code>Cheney算法</code>中将堆内存分成：处于使用状态的空间（使用区），处于闲置状态的空间（空闲区）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/07.png" alt="image.png"><br>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作  </p><p>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段（将非活动对象占用的空间清理掉）。最后把原来的使用区和空闲区互换。<br><strong>情况一：</strong><br>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理  。<br><strong>情况二：</strong><br>如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配  </p><h4 id="老生代垃圾回收"><a href="#老生代垃圾回收" class="headerlink" title="老生代垃圾回收"></a>老生代垃圾回收</h4><ul><li>垃圾收集器创建一个“<strong>roots</strong>”列表。<strong>roots</strong>通常是代码中全局变量的引用。在浏览器中 <strong>window</strong> 对象就被当作是 <strong>root</strong>。<strong>window</strong>对象总是存在的，因此垃圾收集器可以检查它和它的所有子对象是否存在（即是不是垃圾，需不需要回收）。</li><li>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是<strong>可达</strong>的，它就不被当作垃圾。</li><li>所有未被标记的内存会被当作垃圾，垃圾收集器现在可以释放内存，归还给操作系统了。</li></ul><h3 id="并行回收（Parallel）"><a href="#并行回收（Parallel）" class="headerlink" title="并行回收（Parallel）"></a>并行回收（Parallel）</h3><p>因为 <code>JavaScript</code>是一门单线程的语言，并且垃圾回收是运行在主线程上的，在进行垃圾回收时会阻塞<code>JavaScript</code>脚本执行，需要等待垃圾回收完毕后再恢复脚本执行（<code>全停顿标记</code>）。<br>比如一次<code>GC</code>要 60ms，那么 JS 脚本执行就需要等待 60ms，如果一次 <code>GC</code>的时间过长，用户会觉得页面卡顿。<br><code>V8</code>提出了并行<code>GC</code>机制，引入多个辅助线程来执行<code>GC</code>：<br><code>GC</code>再主线程执行的过程中，开启多个辅助线程，同事执行同样的回收工作。<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/08.png" alt="image.png"><br>如图：本来一个线程的的事情交给三个线程来做，大大加速了<code>GC</code>， 对于新生代垃圾回收器能够有很好的优化  </p><h3 id="增量标记与惰性清理"><a href="#增量标记与惰性清理" class="headerlink" title="增量标记与惰性清理"></a>增量标记与惰性清理</h3><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>把一次<code>GC</code>的过程分成很多小步，每执行完一步就让 JS 主线程执行一会儿， 这样交替多次后完成一轮 GC 标记（如下图）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/09.png" alt="image.png"></p><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p><code>V8</code>通过三色标记法来实现增量标记，实现 <code>JS</code> 主线程和 <code>GC</code> 线程的交替执行<br> 三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑 </p><ul><li>白色指的是未被标记的对象</li><li>灰色指自身被标记，成员变量（该对象的引用对象）未被标记</li><li>黑色指自身和成员变量皆被标记</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png" alt="image.png"><br>最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色。就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）<br>可以<strong>直接通过当前内存中有没有灰色节点来判断整个标记是否完成</strong>，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以<br>三色标记法的标记操作是可以渐进执行的而不需要每次都扫描整个内存空间， 可以很好的配合增量回收进行暂停恢复的一些操作，从而减少<code>全停顿</code>的时间  </p><h4 id="惰性清理"><a href="#惰性清理" class="headerlink" title="惰性清理"></a>惰性清理</h4><p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以快速的执行代码，此时是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h2 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h2><h3 id="浏览器方法"><a href="#浏览器方法" class="headerlink" title="浏览器方法"></a>浏览器方法</h3><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的 Select profiling type 字段里面勾选 timeline</li><li>点击左上角的录制按钮。</li><li>在页面进行各种操作，模拟用户的使用情况。</li><li>在一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol><h3 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h3><p>使用 <code>Node</code> 提供的 <code>process.memoryUsage</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">memoryUsage</span>());<br><span class="hljs-comment">// 输出</span><br>&#123;<br>  <span class="hljs-attr">rss</span>: <span class="hljs-number">27709440</span>,<span class="hljs-comment">// resident set size，所有内存占用，包括指令区和堆栈</span><br>  <span class="hljs-attr">heapTotal</span>: <span class="hljs-number">5685248</span>,   <span class="hljs-comment">// &quot;堆&quot;占用的内存，包括用到的和没用到的</span><br>  <span class="hljs-attr">heapUsed</span>: <span class="hljs-number">3449392</span>,<span class="hljs-comment">// 用到的堆的部分</span><br>  <span class="hljs-attr">external</span>: <span class="hljs-number">8772</span> <span class="hljs-comment">// V8 引擎内部的 C++ 对象占用的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断内存泄漏，以<code>heapUsed</code>字段为准。</p><h2 id="WeakMap-WeakSet"><a href="#WeakMap-WeakSet" class="headerlink" title="WeakMap WeakSet"></a>WeakMap WeakSet</h2><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的；因此，只要所引用的对象的其他引用被清除，垃圾回收机制就会释放该对象所占用的内存，不再需要手动删除引用。</p><p>demo1：没用 WeakMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> e1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">const</span> e2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-keyword">const</span> arr = [<br>  [e1, <span class="hljs-string">&#x27;foo 元素&#x27;</span>],<br>  [e2, <span class="hljs-string">&#x27;bar 元素&#x27;</span>],<br>];<br></code></pre></td></tr></table></figure><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不需要 e1 和 e2 的时候</span><br><span class="hljs-comment">// 必须手动删除引用</span><br>arr [<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br>arr [<span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><strong>一旦忘了手动删除引用，就会造成内存泄漏</strong>。</p><p>demo2：用了 WeakMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>);<br><br>wm.<span class="hljs-title function_">set</span>(element, <span class="hljs-string">&#x27;some information&#x27;</span>);<br>wm.<span class="hljs-title function_">get</span>(element) <span class="hljs-comment">// &quot;some information&quot;</span><br></code></pre></td></tr></table></figure><p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。<strong>不需要手动删除引用</strong>。</p><h2 id="javaScript-四类常见的内存泄漏及如何避免"><a href="#javaScript-四类常见的内存泄漏及如何避免" class="headerlink" title="javaScript 四类常见的内存泄漏及如何避免"></a>javaScript 四类常见的内存泄漏及如何避免</h2><h3 id="四类常见的-JS-内存泄漏"><a href="#四类常见的-JS-内存泄漏" class="headerlink" title="四类常见的 JS 内存泄漏"></a>四类常见的 JS 内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg</span>) &#123;<br>  bar = <span class="hljs-string">&quot;this is a hidden global variable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>foo</code> 内部忘记使用 <code>var</code> ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&quot;this is an explicit global variable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个意外的全局变量可能由 <code>this</code> 创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">varible</span> = <span class="hljs-string">&quot;potential accidental global&quot;</span>;<br>&#125;<br><span class="hljs-comment">// Foo 调用自己，this 指向了全局对象（window）</span><br><span class="hljs-comment">// 而不是 undefined</span><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，使用严格模式避免意外的全局变量，此时<strong>上例中的this指向</strong><code>**undefined**</code>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> someResource = <span class="hljs-title function_">getData</span>();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;Node&#x27;</span>);<br>  <span class="hljs-keyword">if</span>(node) &#123;<br>    <span class="hljs-comment">// 处理 node 和 someResource</span><br>    node.<span class="hljs-property">innerHTML</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(someResource)<br>  &#125;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。</p><p><strong>但是</strong>，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 <code>removeEventListener</code> 了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> elements = &#123;<br>    <span class="hljs-attr">button</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>),<br>    <span class="hljs-attr">image</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;image&#x27;</span>),<br>    <span class="hljs-attr">text</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>)<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStuff</span>(<span class="hljs-params"></span>) &#123;<br>    image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://some.url/image&#x27;</span>;<br>    button.<span class="hljs-title function_">click</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-property">innerHTML</span>);<br>    <span class="hljs-comment">// 更多逻辑</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeButton</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 按钮是 body 的后代元素</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>));<br>    <span class="hljs-comment">// 此时，仍旧存在一个全局的 #button 的引用</span><br>    <span class="hljs-comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果代码中保存了表格某一个 <code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <code>&lt;td&gt;</code> 以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码<strong>保留了 <strong><code>**&lt;td&gt;**</code></strong> 的引用</strong>，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键在于匿名函数可以访问父级作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> replaceThing = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> originalThing = theThing;<br>  <span class="hljs-keyword">var</span> unused = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (originalThing)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>    <br>  theThing = &#123;<br>    <span class="hljs-attr">longStr</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;*&#x27;</span>),<br>    <span class="hljs-attr">someMethod</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(someMessage);<br>    &#125;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-built_in">setInterval</span>(replaceThing, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>每次调用 <code>replaceThing</code> ，<code>theThing</code> 得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量 <code>unused</code> 是一个引用 <code>originalThing</code> 的闭包（先前的 <code>replaceThing</code> 又调用了 <code>theThing</code> ）。<code>someMethod</code> 可以通过 <code>theThing</code> 使用，<code>someMethod</code> 与 <code>unused</code> 分享闭包作用域，尽管 <code>unused</code> 从未使用，它引用的 <code>originalThing</code> 迫使它保留在内存中（防止被回收）。</p><p><strong>解决方法</strong>：</p><p>在 <code>replaceThing</code> 的最后添加 <code>originalThing = null</code> 。</p><h3 id="从内存的角度来看-null-和-undefined-本质的区别是什么？"><a href="#从内存的角度来看-null-和-undefined-本质的区别是什么？" class="headerlink" title="从内存的角度来看 null 和 undefined 本质的区别是什么？"></a>从内存的角度来看 null 和 undefined 本质的区别是什么？</h3><p>给一个全局变量赋值为 null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性赋值为 null，或者局部变量赋值为 null，相当于给这个属性分配了一块空的内存，然后值为 null，JS 回收全局变量为 null 的对象。</p><p>给一个全局变量赋值为 undefined，相当于将这个对象的值清空，但是这个对象依旧存在，如果是给对象的属性赋值为 undefined，说明这个值为空值。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链和闭包</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>执行上下文定义了变量或者函数访问其他数据的权限，和它们各自的行为。每个执行上下文环境都有有一个与之关联的当前活动对象（AO），环境中定义的所有变量和函数都保存在这个对象中。</p><p><strong>作用域链：</strong>当访问一个变量时，JS 解释器会首先在当前上下文中的变量对象查找标识符，如果没有找到，就去父级（词法层面上的父级）执行上下文中的变量对象中查找，一直找到全局上下文中的变量对象（全局对象），这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p><strong>作用域链和原型链查找的区别：</strong>如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 <strong>undefined</strong>；但查找的属性在作用域链中不存在的话就会抛出 <strong>ReferenceError</strong>。</p><p>作用域链的顶端是全局对象，在全局环境中定义的变量就会绑定到全局对象中。</p><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><h3 id="无嵌套的函数"><a href="#无嵌套的函数" class="headerlink" title="无嵌套的函数"></a>无嵌套的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// my_script.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) &#123;<br>  <br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">3</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inside myFunc&quot;</span>);<br>  <br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br><span class="hljs-title function_">myFunc</span>();<br></code></pre></td></tr></table></figure><p>定义时：当 myFunc 被定义的时候，myFunc 的标识符（identifier）就被加到了全局对象中，这个标识符所引用的是一个函数对象（myFunc function object）。</p><p>内部属性<code>[[scope]]</code>指向当前的作用域对象，也就是函数的标识符被创建的时候，我们所能够直接访问的那个作用域对象（即全局对象）。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/01.png" alt="image.png"></p><p>myFunc 所引用的函数对象，其实本身不仅仅含有函数的代码，并且还含有指向其被创建的时候的作用域对象。</p><p><strong>调用时：</strong>当 myFunc 函数被调用的时候，一个新的作用域对象（执行上下文中的变量对象）被创建了。新的作用域对象中包含 myFunc 函数所定义的本地变量，以及其参数（arguments）。这个新的作用域对象的父作用域对象就是运行 myFunc 时能够直接访问的那个作用域对象（即全局对象）。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/02.png" alt="image.png"></p><h3 id="有嵌套的函数"><a href="#有嵌套的函数" class="headerlink" title="有嵌套的函数"></a>有嵌套的函数</h3><p>当函数返回没有被引用的时候，就会被垃圾收集器回收。但是对于闭包，即使外部函数返回了，函数对象仍会引用它被<strong>创建时</strong>的作用域对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-keyword">var</span> counter = initial;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">value</span>) &#123;<br>    counter += value;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">get</span>: get<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> myCounter = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 100</span><br><br>myCounter.<span class="hljs-title function_">increment</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 105</span><br></code></pre></td></tr></table></figure><p>当调用 createCounter(100) 时，内嵌函数increment和get都有指向createCounter(100) scope的引用。<strong>假设</strong>createCounter(100)没有任何返回值，那么createCounter(100) scope不再被引用，于是就可以被垃圾回收。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/03.png" alt="image.png"></p><p>但是 createCounter(100) 实际上是有返回值的，并且返回值被存储在了 myCounter 中，所以对象之间的引用关系如下图：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/04.png" alt="image.png"></p><p>即使createCounter(100)已经返回，但是其作用域仍在，并且只能被内联函数访问。可以通过调用myCounter.increment() 或 myCounter.get()来直接访问createCounter(100)的作用域。</p><p>当myCounter.increment() 或 myCounter.get()被调用时，新的作用域对象会被创建，并且该作用域对象的父作用域对象会是当前可以直接访问的作用域对象。</p><p>调用<code>get()</code>时，当执行到<code>return counter</code>时，在get()所在的作用域并没有找到对应的标示符，就会沿着作用域链往上找，直到找到变量<code>counter</code>，然后返回该变量。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/05.png" alt="image.png"></p><p>单独调用increment(5)时，参数value保存在当前的作用域对象。当函数要访问counter时，没有找到，于是沿着作用域链向上查找，在createCounter(100)的作用域找到了对应的标示符，increment()就会修改counter的值。除此之外，没有其他方式来修改这个变量。闭包的强大也在于此，能够存贮私有数据。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/06.png" alt="image.png"></p><p>创建两个函数：<code>myCounter1</code>和<code>myCounter2</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//my_script.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">/* ... see the code from previous example ... */</span><br>&#125;<br><br><span class="hljs-comment">//-- create counter objects</span><br><span class="hljs-keyword">var</span> myCounter1 = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">var</span> myCounter2 = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>关系图如下：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/07.png" alt="image.png"></p><p>myCounter1.increment和myCounter2.increment的函数对象拥有着一样的代码以及一样的属性值（name，length等等），但是它们的[[scope]]指向的是不一样的作用域对象。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的定义：<code>有权访问另一个函数作用域中的变量的函数</code></p><ul><li>是一个函数（比如，内部函数从父函数中返回）</li><li>能够访问另一个函数作用域中的变量（哪怕上级函数上下文已经销毁）</li></ul><p>简单概括：<strong>本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。</strong></p><p>这也是闭包保存的自由变量（即使是原始类型）存放在堆内存里面的原因</p><p><strong>闭包的三个特性：</strong></p><ul><li><p>闭包可以访问当前函数以外的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOuter</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bob&#x27;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str + name) <span class="hljs-comment">// 访问外部的 name</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getName</span>(<span class="hljs-string">&#x27;名字是：&#x27;</span>) <span class="hljs-comment">// &quot;名字是：bob&quot;</span><br>&#125;<br><span class="hljs-title function_">getOuter</span>();<br></code></pre></td></tr></table></figure></li><li><p>即使外部函数已经返回，闭包仍然能访问外部函数定义的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOuter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bob&#x27;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str + name) <span class="hljs-comment">// 访问外部的 name</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> getName; <span class="hljs-comment">// 外部函数返回</span><br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getOuter</span>();<br><span class="hljs-title function_">today</span>(<span class="hljs-string">&#x27;名字是：&#x27;</span>); <span class="hljs-comment">// &quot;名字是：bob&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>闭包可以更新外部变量的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateCount</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCount</span>(<span class="hljs-params">val</span>) &#123;<br>    count = val;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;<br>  <span class="hljs-keyword">return</span> getCount; <span class="hljs-comment">// 外部函数返回</span><br>&#125;<br><span class="hljs-keyword">var</span> count = <span class="hljs-title function_">updateCount</span>()<br><span class="hljs-title function_">count</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123</span><br><span class="hljs-title function_">count</span>(<span class="hljs-number">1234</span>) <span class="hljs-comment">// 1234</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="结合作用域链分析闭包"><a href="#结合作用域链分析闭包" class="headerlink" title="结合作用域链分析闭包"></a>结合作用域链分析闭包</h2><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> scope;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-title function_">checkscope</span>(); <span class="hljs-comment">// foo 指向函数f</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 调用函数f()</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><ul><li>进入全局代码，创建全局执行上下文，全局执行上下文<strong>压入执行上下文栈</strong></li><li>全局执行<strong>上下文初始化</strong></li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行山下文被压入执行上下文栈</li><li>f 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈弹出</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/08.png" alt="image.png"></p><p>函数 f 执行上下文维护了一个作用域链，会指向<code>checkscope</code>作用域，作用域链是一个数组，结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fContext = &#123;<br>  <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, checkscopeContext.<span class="hljs-property">AO</span>, globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>指向关系是：当前作用域 –&gt; <code>checkscope</code>作用域–&gt;全局作用域</p><p>即使 checkscopeContext 被销毁了，但是 Javascript 依然会让 checkscopeContext.AO（活动对象）活在内存中，f 函数依然可以通过自身的作用域链找到它，<strong>这就是闭包实现的关键</strong></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器与js</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器与JS"><a href="#浏览器与JS" class="headerlink" title="浏览器与JS"></a>浏览器与JS</h1><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p>进程是 cpu 资源分配的最小单位（系统会给他分配内存），进程之间相互独立（也可以相互通信，但是代价很大）。</p><p>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程），线程之间有共享空间。</p><p>区别：</p><ol><li>每启动一个进程，这个进程至少得有一个线程。</li><li>进程本身只是一个资源单位，并不是真正执行，进程内的线程才是执行单位。</li><li>一个进程内可以有多个线程，进程在内存中相互隔离，而同一个进程内的线程是共享资源的，各线程之间地位平等。</li><li>进程更消耗资源，而线程开销小，是在已有的进程内占用。</li></ol><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2><h3 id="1-包含以下主要进程"><a href="#1-包含以下主要进程" class="headerlink" title="1.包含以下主要进程"></a>1.包含以下主要进程</h3><ol><li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个，作用有： <ul><li>负责浏览器的界面展示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将 Render 进程得到的内存中的 Bitmap ，绘制到到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程：每个类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D 绘制等</li><li>浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每一个 Tab 页面一个进程，互不影响。主要作用 <ul><li>页面渲染，脚本执行，事件处理等等</li></ul></li></ol><p>在浏览器打开一个网页，就相当于新启了一个进程（可以通过Chrome的更多工具-》任务管理器自行验证）</p><h3 id="2-浏览器多进程的优势"><a href="#2-浏览器多进程的优势" class="headerlink" title="2.浏览器多进程的优势"></a>2.浏览器多进程的优势</h3><ul><li>避免单个 page crash 影响整个浏览器 </li><li>避免第三方插件 crash 影响整个浏览器 </li><li>多进程充分利用多核优势 </li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<br>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></li></ul><h3 id="3-浏览器内核（渲染进程）"><a href="#3-浏览器内核（渲染进程）" class="headerlink" title="3.浏览器内核（渲染进程）"></a>3.浏览器内核（渲染进程）</h3><p>渲染进程是多线程的，常驻线程如下：</p><ol><li>GUI 渲染线程</li></ol><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行</li><li>GUI渲染进程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><ol start="2"><li>JS引擎线程</li></ol><ul><li>也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>GUI渲染进程和JS引擎线程是互斥的，如果JS执行的时间过长，就会阻塞页面的渲染。</li></ul><ol start="3"><li>事件触发线程</li></ol><ul><li>归属于浏览器而不是JS引擎，用来控制四件循环（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>注意，由于JS的单线程的关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲的时候才会去执行）</li></ul><ol start="4"><li>定时器触发线程</li></ol><ul><li>setInterval 与 setTimeout 所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的（因为Javascript引擎时单线程的，如果处于阻塞线程状态就会影响定时计数器的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li></ul><ol start="5"><li>异步http请求线程</li></ol><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由Javascript引擎执行。</li></ul><p><strong>浏览器内核</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/core.png" alt="image.png"></p><h3 id="4-Browser进程和浏览器内核（Render进程）的通信过程"><a href="#4-Browser进程和浏览器内核（Render进程）的通信过程" class="headerlink" title="4.Browser进程和浏览器内核（Render进程）的通信过程"></a>4.Browser进程和浏览器内核（Render进程）的通信过程</h3><ul><li>Browser 进程收到了用户请求，首先需要获取页面内容（通过网络下载资源），随后将该任务通过RenderHost接口传递给Render进程</li><li>Render进程的Render接口收到消息，简单解释后，交给渲染线程（Render），然后开始渲染 <ul><li>渲染线程（Render）接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM</li><li>最后 Render 进程将结果传递给Browser进程</li></ul></li><li>Browser进程接收到结果并将结果绘制出来</li></ul><h3 id="5-WebWorker"><a href="#5-WebWorker" class="headerlink" title="5.WebWorker"></a>5.WebWorker</h3><p>HTML5 支持了 Web Worker</p><p>MDN 解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Web</span> <span class="hljs-title class_">Worker</span>为<span class="hljs-title class_">Web</span>内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面<br><br>一个worker是使用一个构造函数创建的一个对象(e.<span class="hljs-property">g</span>. <span class="hljs-title class_">Worker</span>()) 运行一个命名的<span class="hljs-title class_">JavaScript</span>文件 <br><br>这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的<span class="hljs-variable language_">window</span><br><br>因此，使用 <span class="hljs-variable language_">window</span>快捷方式获取当前全局的范围 (而不是self) 在一个 <span class="hljs-title class_">Worker</span> 内将返回错误<br></code></pre></td></tr></table></figure><ul><li>创建 Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与主线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，单独开一个Worker线程，这样里面不管如何翻天覆地都不影响JS引擎主线程，只等计算出结果后，将结果通信给主线程即可。</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="6-WebWorker-与-SharedWorker"><a href="#6-WebWorker-与-SharedWorker" class="headerlink" title="6.WebWorker 与 SharedWorker"></a>6.WebWorker 与 SharedWorker</h3><ul><li>WebWorker只属于某个页面，不会和其他页面的Renderer进程共享 <ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li><li>SharedWorker是浏览器所有页面共享，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 <ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul><p>SharedWorker由独立的进程管理，WebWorker只属于render进程下的一个线程</p><h3 id="7-浏览器渲染进程"><a href="#7-浏览器渲染进程" class="headerlink" title="7.浏览器渲染进程"></a>7.浏览器渲染进程</h3><ul><li>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</li><li>浏览器渲染流程开始</li></ul><p>渲染：</p><ol><li>解析html建立dom树</li><li>解析css构建 render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>渲染完成之后就是 load 事件</p><h4 id="1-load事件与DOMContentLoaded事件的先后"><a href="#1-load事件与DOMContentLoaded事件的先后" class="headerlink" title="1.load事件与DOMContentLoaded事件的先后"></a>1.load事件与DOMContentLoaded事件的先后</h4><ul><li>当 DOMContentLoaded 事件出发时，仅当DOM加载完成，不包括样式表，图片。（例如如果有async加载的脚本就不一定完成）</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><p>DOMContentLoaded -&gt; load</p><h4 id="2-css加载是否会阻塞dom树渲染"><a href="#2-css加载是否会阻塞dom树渲染" class="headerlink" title="2.css加载是否会阻塞dom树渲染"></a>2.css加载是否会阻塞dom树渲染</h4><p>此处说的是头部引入css的情况下</p><p>css是由单独的下载线程异步下载的。</p><ul><li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li><li>但会阻塞render树渲染（渲染时需等待css加载完毕，因为render树需要css信息）</li></ul><p>因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h4 id="3-普通图层和复合图层"><a href="#3-普通图层和复合图层" class="headerlink" title="3.普通图层和复合图层"></a>3.普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p><ul><li>普通文档流内可以理解为一个复合图层（这里称为默认复合图层，里面不管添加多少元素，其实都是在同一个复合图层中）</li><li>absolute布局和flex布局，虽然脱离普通文档流，但是仍然属于默认复合层。</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合图层中的回流重绘）</li></ul><p>GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p><h5 id="1-如何变成复合图层（硬件加速）"><a href="#1-如何变成复合图层（硬件加速）" class="headerlink" title="1.如何变成复合图层（硬件加速）"></a>1.如何变成复合图层（硬件加速）</h5><p>将该元素变成一个复合图层，就是硬件加速技术</p><ul><li><p>最常用的方式：translate3d、translateZ </p></li><li><p>opacity 属性&#x2F;过渡动画（需要动画执行过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） </p></li><li><p>will-chang属性，一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）。<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） </p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">webgl</span>&gt;</span>等元素<br></code></pre></td></tr></table></figure></li><li><p>其它，譬如以前的flash插件</p></li></ul><h5 id="2-absolute和硬件加速的区别"><a href="#2-absolute和硬件加速的区别" class="headerlink" title="2.absolute和硬件加速的区别"></a>2.absolute和硬件加速的区别</h5><p>absolute 虽然脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中的render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><h5 id="3-复合图层的作用"><a href="#3-复合图层的作用" class="headerlink" title="3.复合图层的作用"></a>3.复合图层的作用</h5><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但是尽量不要大量使用复合图层，否则由于资源消耗过渡，页面反而会变得更卡</p><h5 id="4-硬件加速时使用index"><a href="#4-硬件加速时使用index" class="headerlink" title="4.硬件加速时使用index"></a>4.硬件加速时使用index</h5><p>使用硬件加速时，尽可能使用z-index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体原理：webkit css3 中，如果整个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其他元素（层级比这个元素高的，或者相同的，并且releative或者absolute属性相同的），会默认变成复合图层渲染，如果处理不当会极大的影响性能</p><p>简单理解：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</p><h2 id="从-Event-Loop谈JS的运行机制"><a href="#从-Event-Loop谈JS的运行机制" class="headerlink" title="从 Event Loop谈JS的运行机制"></a>从 Event Loop谈JS的运行机制</h2><ul><li>JS分为同步任务和异步任务 </li><li>同步任务都在主线程上执行，形成一个执行栈 </li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 </li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到主执行栈中，开始执行 </li><li>异步队列里分为宏任务和微任务 <ul><li>宏任务（macrotask）每次执行栈执行后的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放入执行栈中执行） <ul><li>每一个宏任务都会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始之前，对页面进行重新渲染</li></ul></li><li>微任务（microtask），可以理解是在当前宏任务执行结束后立即执行的任务 <ul><li>在当前宏任务之后，在渲染之前，下一个宏任务之前</li><li>在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（渲染之前）</li></ul></li><li>宏任务：script(整体代码)、setTimeout、setInterval、I&#x2F;O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</li><li>微任务：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</li></ul></li></ul><p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 </p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setTimeout、setInterval是由定时器线程计时的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin&#x27;</span>);<br></code></pre></td></tr></table></figure><p>虽然代码是0毫秒后推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="更新动态列"><a href="#更新动态列" class="headerlink" title="更新动态列"></a>更新动态列</h1><p>在Vue2中使用vxetable组件时，如果不调用clearSort方法而直接修改columns，可能会出现渲染问题。这是因为vxetable组件内部维护了一个状态，用于记录表格的排序状态，当columns发生变化时，如果不正确地更新这个状态，就会导致渲染问题的出现。<br>调用clearSort方法的作用是清除表格的排序状态，这样在更新columns后，vxetable组件会重新根据新的columns进行排序，从而避免渲染问题的出现。<br>具体地，如果不调用clearSort方法，可能会出现以下两种情况：</p><ol><li>表格数据显示不正确：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致表格数据显示不正确，这是因为vxetable组件仍然保留着原来的排序状态，导致新的columns无法正确应用到表格数据上。</li><li>列表头显示异常：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致列表头显示异常，这是因为vxetable组件内部维护的排序状态没有正确更新，导致列表头的渲染出现问题。</li></ol><p>因此，在修改columns时，建议先调用clearSort方法清除排序状态，再进行列属性的更新。这样可以避免渲染问题的出现，确保vxetable组件能够正确地更新和显示数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInViewAnimate</span> = (<span class="hljs-params">el, binding</span>) =&gt; &#123;<br>  <span class="hljs-comment">// check if browser supports IntersectionObserver API</span><br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;IntersectionObserver&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) &#123;<br>    <span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInView</span>(el)) &#123;<br>        el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>        timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// use IntersectionObserver for supported browser</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">[entry]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;<br>      el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>    &#125;<br>  &#125;, &#123;<br>    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span><br>  &#125;);<br>  observer.<span class="hljs-title function_">observe</span>(el);<br><br>  <span class="hljs-comment">// clean up</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    observer.<span class="hljs-title function_">disconnect</span>();<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>      observer.<span class="hljs-title function_">disconnect</span>();<br>    &#125;,<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isInView</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> rect = el.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span> &gt; <span class="hljs-number">100</span>;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>注意点：</p><ul><li>获取排序后的数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; visibleData &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">xxxRef</span>.<span class="hljs-title function_">getTableData</span>()<br><span class="hljs-comment">// visibleData 处理条件之后的全量表体数据（排序后的全量数据）</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精确四则运算</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/JavaScript/%E7%B2%BE%E7%A1%AE%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/JavaScript/%E7%B2%BE%E7%A1%AE%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accAdd</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>    <br>    <span class="hljs-keyword">return</span> ((arg1 * m + arg2 * m) / m).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>&#125; <br><br><span class="hljs-comment">//加法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accAddInt</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>    <br>    <span class="hljs-keyword">return</span> (arg1 * m + arg2 * m) / m;<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个add方法，，使用时直接用 .add 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accAdd</span>(arg, <span class="hljs-variable language_">this</span>);<br>&#125;;<br><br><span class="hljs-comment">//减法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Subtr</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m, n;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>     <span class="hljs-comment">//last modify by deeka</span><br>     <span class="hljs-comment">//动态控制精度长度</span><br>    n = (r1 &gt;= r2) ? r1 : r2;<br>    <span class="hljs-keyword">return</span> ((arg1 * m - arg2 * m) / m).<span class="hljs-title function_">toFixed</span>(n);<br>&#125;<br><br><span class="hljs-comment">//给Number类型增加一个add方法，，使用时直接用 .sub 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Subtr</span>(<span class="hljs-variable language_">this</span>, arg);<br>&#125;;<br><br><span class="hljs-comment">//乘法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accMul</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-number">0</span>, s1 = arg1.<span class="hljs-title function_">toString</span>(), s2 = arg2.<span class="hljs-title function_">toString</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        m += s1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m += s2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-title class_">Number</span>(s1.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) * <span class="hljs-title class_">Number</span>(s2.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, m)).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个mul方法，使用时直接用 .mul 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mul</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accMul</span>(arg, <span class="hljs-variable language_">this</span>);<br>&#125;; <br><br><span class="hljs-comment">//除法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accDiv</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>, r1, r2;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">with</span> (<span class="hljs-title class_">Math</span>) &#123;<br>        r1 = <span class="hljs-title class_">Number</span>(arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>        r2 = <span class="hljs-title class_">Number</span>(arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-keyword">return</span> ((r1 / r2) * <span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, t2 - t1)).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个div方法，，使用时直接用 .div 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">div</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accDiv</span>(<span class="hljs-variable language_">this</span>, arg);<br>&#125;; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/CSS/%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/CSS/%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="瀑布流布局"><a href="#瀑布流布局" class="headerlink" title="瀑布流布局"></a>瀑布流布局</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">4</span>;<span class="hljs-comment">// 想要排列的列数</span><br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">0px</span>;每一列之间的距离<br>  <span class="hljs-selector-class">.item</span> &#123;<br>    agr-<span class="hljs-attribute">break-inside</span>: avoid; <span class="hljs-comment">//禁止在元素内部产生分页行为，防止item元素被分割</span><br>    -webkit-column-<span class="hljs-attribute">break-inside</span>: avoid; <span class="hljs-comment">// 兼容</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="0-5px-完美解决方案"><a href="#0-5px-完美解决方案" class="headerlink" title="0.5px 完美解决方案"></a>0.5px 完美解决方案</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br><span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br><span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>; // 指定变换的原点，防止虚化<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h1><h2 id="cover-view"><a href="#cover-view" class="headerlink" title="cover-view"></a>cover-view</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*  需要添加换行 */</span><br>&#123;<br>  <span class="hljs-attribute">word-break</span>: break-all;<br>  <span class="hljs-attribute">word-wrap</span>: break-word;<br>  <span class="hljs-attribute">white-space</span>: pre-line;<br>&#125;<br></code></pre></td></tr></table></figure><p>不添加有文字重叠或者字符被遮挡一部分的bug</p><h2 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h2><p>不设置 <code>max-length</code> 默认限制140个字符输入</p><h1 id="dom元素"><a href="#dom元素" class="headerlink" title="dom元素"></a>dom元素</h1><h2 id="dom元素获取"><a href="#dom元素获取" class="headerlink" title="dom元素获取"></a>dom元素获取</h2><p>只能获取当前组件或当前页面的dom元素，无法像H5中的<code>document.querySelect()</code>获取整个文档的dom元素<br>滚动demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">uni.<span class="hljs-title function_">createSelectorQuery</span>().<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;.fater&quot;</span>).<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<span class="hljs-comment">//目标节点、也可以是最外层的父级节点</span><br>  uni.<span class="hljs-title function_">createSelectorQuery</span>().<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;.child&quot;</span>).<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<span class="hljs-comment">//最外层盒子节点</span><br>  <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span><br>  uni.<span class="hljs-title function_">pageScrollTo</span>(&#123;<br>  <span class="hljs-attr">duration</span>:<span class="hljs-number">0</span>,<span class="hljs-comment">//过渡时间必须为0，uniapp bug，否则运行到手机会报错</span><br>  <span class="hljs-attr">scrollTop</span>:res.<span class="hljs-property">top</span> - data.<span class="hljs-property">top</span>,<span class="hljs-comment">//滚动到实际距离是元素距离顶部的距离减去最外层盒子的滚动距离</span><br>  &#125;)<br>  &#125;).<span class="hljs-title function_">exec</span>()<br>&#125;).<span class="hljs-title function_">exec</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">111</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">// render(h) &#123;</span><br>  <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span><br>  <span class="hljs-comment">// &#125;,</span><br>  <span class="hljs-comment">// template:`&lt;div id=&quot;a&quot;&gt;hello&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="模板编译入口"><a href="#模板编译入口" class="headerlink" title="模板编译入口"></a>模板编译入口</h1><p>传入的 el 或者 template 选项最后都会被解析成 render 函数 这样才能保持模板解析的一致性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-keyword">import</span> &#123; initState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./state&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; compileToFunctions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./compiler/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 这里的this代表调用_init方法的对象(实例对象)</span><br>    <span class="hljs-comment">//  this.$options就是用户new Vue的时候传入的属性</span><br>    vm.<span class="hljs-property">$options</span> = options;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-title function_">initState</span>(vm);<br><br>    <span class="hljs-comment">// 如果有el属性 进行模板渲染</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 这块代码在源码里面的位置其实是放在entry-runtime-with-compiler.js里面</span><br>  <span class="hljs-comment">// 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br><br>    <span class="hljs-comment">// 如果不存在render属性</span><br>    <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>      <span class="hljs-comment">// 如果存在template属性</span><br>      <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br><br>      <span class="hljs-keyword">if</span> (!template &amp;&amp; el) &#123;<br>        <span class="hljs-comment">// 如果不存在render和template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>        template = el.<span class="hljs-property">outerHTML</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>      <span class="hljs-keyword">if</span> (template) &#123;<br>        <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>        options.<span class="hljs-property">render</span> = render;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br>  <br><br></code></pre></td></tr></table></figure><h1 id="模板转化核心方法-compileToFunctions"><a href="#模板转化核心方法-compileToFunctions" class="headerlink" title="模板转化核心方法 compileToFunctions"></a>模板转化核心方法 compileToFunctions</h1><p> 1.生成 ast 2.优化静态节点 3.根据 ast 生成 render 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/index.js</span><br><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./parse&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./codegen&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-comment">// 把html字符串变成render函数</span><br>  <span class="hljs-comment">// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br>  <span class="hljs-comment">// 很多库都运用到了ast 比如 webpack babel eslint等等</span><br>  <span class="hljs-keyword">let</span> ast = <span class="hljs-title function_">parse</span>(template);<br>  <span class="hljs-comment">// 2.优化静态节点</span><br>  <span class="hljs-comment">//   if (options.optimize !== false) &#123;</span><br>  <span class="hljs-comment">//     optimize(ast, options);</span><br>  <span class="hljs-comment">//   &#125;</span><br><br>  <span class="hljs-comment">// 3.通过ast 重新生成代码</span><br>  <span class="hljs-comment">// 最后生成的代码需要和render函数一样</span><br>  <span class="hljs-comment">// 类似_c(&#x27;div&#x27;,&#123;id:&quot;app&quot;&#125;,_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br>  <span class="hljs-comment">// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解析-html-并生成-ast"><a href="#解析-html-并生成-ast" class="headerlink" title="解析 html 并生成 ast"></a>解析 html 并生成 ast</h1><p>利用正则 匹配 html 字符串 遇到开始标签 结束标签和文本 解析完毕之后生成对应的 ast 并建立相应的父子关联 不断的 advance 截取剩余的字符串 直到 html 全部解析完毕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/parse.js</span><br><br><span class="hljs-comment">// 以下为源码的正则  对正则表达式不清楚的同学可以参考小编之前写的文章(前端进阶高薪必看 - 正则篇);</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; <span class="hljs-comment">//匹配标签名 形如 abc-123</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span>; <span class="hljs-comment">//匹配特殊标签 形如 abc:234 前面的abc:可有可无</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="hljs-comment">// 匹配标签开始 形如 &lt;abc-123 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span>; <span class="hljs-comment">// 匹配标签结束  &gt;</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="hljs-comment">// 匹配标签结尾 如 &lt;/abc-123&gt; 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="hljs-comment">// 匹配属性  形如 id=&quot;app&quot;</span><br><br><span class="hljs-keyword">let</span> root, currentParent; <span class="hljs-comment">//代表根节点 和当前父节点</span><br><span class="hljs-comment">// 栈结构 来表示开始和结束标签</span><br><span class="hljs-keyword">let</span> stack = [];<br><span class="hljs-comment">// 标识元素和文本type</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ELEMENT_TYPE</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 生成ast方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createASTElement</span>(<span class="hljs-params">tagName, attrs</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tag</span>: tagName,<br>    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ELEMENT_TYPE</span>,<br>    <span class="hljs-attr">children</span>: [],<br>    attrs,<br>    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 对开始标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStartTag</span>(<span class="hljs-params">&#123; tagName, attrs &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> element = <span class="hljs-title function_">createASTElement</span>(tagName, attrs);<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    root = element;<br>  &#125;<br>  currentParent = element;<br>  stack.<span class="hljs-title function_">push</span>(element);<br>&#125;<br><br><span class="hljs-comment">// 对结束标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEndTag</span>(<span class="hljs-params">tagName</span>) &#123;<br>  <span class="hljs-comment">// 栈结构 []</span><br>  <span class="hljs-comment">// 比如 &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 当遇到第一个结束标签&lt;/span&gt;时 会匹配到栈顶&lt;span&gt;元素对应的ast 并取出来</span><br>  <span class="hljs-keyword">let</span> element = stack.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-comment">// 当前父元素就是栈顶的上一个元素 在这里就类似div</span><br>  currentParent = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  <span class="hljs-comment">// 建立parent和children关系</span><br>  <span class="hljs-keyword">if</span> (currentParent) &#123;<br>    element.<span class="hljs-property">parent</span> = currentParent;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对文本进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChars</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-comment">// 去掉空格</span><br>  text = text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (text) &#123;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TEXT_TYPE</span>,<br>      text,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析标签生成ast核心</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>) &#123;<br>  <span class="hljs-keyword">while</span> (html) &#123;<br>    <span class="hljs-comment">// 查找&lt;</span><br>    <span class="hljs-keyword">let</span> textEnd = html.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>    <span class="hljs-comment">// 如果&lt;在第一个 那么证明接下来就是一个标签 不管是开始还是结束标签</span><br>    <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果开始标签解析有结果</span><br>      <span class="hljs-keyword">const</span> startTagMatch = <span class="hljs-title function_">parseStartTag</span>();<br>      <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br>        <span class="hljs-comment">// 把解析好的标签名和属性解析生成ast</span><br>        <span class="hljs-title function_">handleStartTag</span>(startTagMatch);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 匹配结束标签&lt;/</span><br>      <span class="hljs-keyword">const</span> endTagMatch = html.<span class="hljs-title function_">match</span>(endTag);<br>      <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>        <span class="hljs-title function_">advance</span>(endTagMatch[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        <span class="hljs-title function_">handleEndTag</span>(endTagMatch[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> text;<br>    <span class="hljs-comment">// 形如 hello&lt;div&gt;&lt;/div&gt;</span><br>    <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 获取文本</span><br>      text = html.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, textEnd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (text) &#123;<br>      <span class="hljs-title function_">advance</span>(text.<span class="hljs-property">length</span>);<br>      <span class="hljs-title function_">handleChars</span>(text);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 匹配开始标签</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseStartTag</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = html.<span class="hljs-title function_">match</span>(startTagOpen);<br><br>    <span class="hljs-keyword">if</span> (start) &#123;<br>      <span class="hljs-keyword">const</span> match = &#123;<br>        <span class="hljs-attr">tagName</span>: start[<span class="hljs-number">1</span>],<br>        <span class="hljs-attr">attrs</span>: [],<br>      &#125;;<br>      <span class="hljs-comment">//匹配到了开始标签 就截取掉</span><br>      <span class="hljs-title function_">advance</span>(start[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br><br>      <span class="hljs-comment">// 开始匹配属性</span><br>      <span class="hljs-comment">// end代表结束符号&gt;  如果不是匹配到了结束标签</span><br>      <span class="hljs-comment">// attr 表示匹配的属性</span><br>      <span class="hljs-keyword">let</span> end, attr;<br>      <span class="hljs-keyword">while</span> (<br>        !(end = html.<span class="hljs-title function_">match</span>(startTagClose)) &amp;&amp;<br>        (attr = html.<span class="hljs-title function_">match</span>(attribute))<br>      ) &#123;<br>        <span class="hljs-title function_">advance</span>(attr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        attr = &#123;<br>          <span class="hljs-attr">name</span>: attr[<span class="hljs-number">1</span>],<br>          <span class="hljs-attr">value</span>: attr[<span class="hljs-number">3</span>] || attr[<span class="hljs-number">4</span>] || attr[<span class="hljs-number">5</span>], <span class="hljs-comment">//这里是因为正则捕获支持双引号 单引号 和无引号的属性值</span><br>        &#125;;<br>        match.<span class="hljs-property">attrs</span>.<span class="hljs-title function_">push</span>(attr);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (end) &#123;<br>        <span class="hljs-comment">//   代表一个标签匹配到结束的&gt;了 代表开始标签解析完毕</span><br>        <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> match;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//截取html字符串 每次匹配到了就往前继续匹配</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">advance</span>(<span class="hljs-params">n</span>) &#123;<br>    html = html.<span class="hljs-title function_">substring</span>(n);<br>  &#125;<br>  <span class="hljs-comment">//   返回生成的ast</span><br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据-ast-重新生成代码"><a href="#根据-ast-重新生成代码" class="headerlink" title="根据 ast 重新生成代码"></a>根据 ast 重新生成代码</h1><p>拿到生成好的 ast 之后 需要把 ast 转化成类似_c(‘div’,{id:”app”},_c(‘div’,undefined,_v(“hello”+_s(name)),_c(‘span’,undefined,_v(“world”))))这样的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/codegen.js</span><br><br><span class="hljs-keyword">const</span> defaultTagRE = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>; <span class="hljs-comment">//匹配花括号 &#123;&#123;  &#125;&#125; 捕获花括号里面的内容</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 判断节点类型</span><br>  <span class="hljs-comment">// 主要包含处理文本核心</span><br>  <span class="hljs-comment">// 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式&#123;&#123;&#125;&#125;的处理</span><br><br>  <span class="hljs-comment">// 如果是元素类型</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//   递归创建</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">generate</span>(node);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   如果是文本节点</span><br>    <span class="hljs-keyword">let</span> text = node.<span class="hljs-property">text</span>;<br>    <span class="hljs-comment">// 不存在花括号变量表达式</span><br>    <span class="hljs-keyword">if</span> (!defaultTagRE.<span class="hljs-title function_">test</span>(text)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(text)&#125;</span>)`</span>;<br>    &#125;<br>    <span class="hljs-comment">// 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug</span><br>    <span class="hljs-keyword">let</span> lastIndex = (defaultTagRE.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> tokens = [];<br>    <span class="hljs-keyword">let</span> match, index;<br><br>    <span class="hljs-keyword">while</span> ((match = defaultTagRE.<span class="hljs-title function_">exec</span>(text))) &#123;<br>      <span class="hljs-comment">// index代表匹配到的位置</span><br>      index = match.<span class="hljs-property">index</span>;<br>      <span class="hljs-keyword">if</span> (index &gt; lastIndex) &#123;<br>        <span class="hljs-comment">//   匹配到的&#123;&#123;位置  在tokens里面放入普通文本</span><br>        tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex, index)));<br>      &#125;<br>      <span class="hljs-comment">//   放入捕获到的变量内容</span><br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-string">`_s(<span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>].trim()&#125;</span>)`</span>);<br>      <span class="hljs-comment">//   匹配指针后移</span><br>      lastIndex = index + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push</span><br>    <span class="hljs-keyword">if</span> (lastIndex &lt; text.<span class="hljs-property">length</span>) &#123;<br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex)));<br>    &#125;<br>    <span class="hljs-comment">// _v表示创建文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;tokens.join(<span class="hljs-string">&quot;+&quot;</span>)&#125;</span>)`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理attrs属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genProps</span>(<span class="hljs-params">attrs</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; attrs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> attr = attrs[i];<br>    <span class="hljs-comment">// 对attrs属性里面的style做特殊处理</span><br>    <span class="hljs-keyword">if</span> (attr.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>      attr.<span class="hljs-property">value</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;;&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>);<br>        obj[key] = value;<br>      &#125;);<br>      attr.<span class="hljs-property">value</span> = obj;<br>    &#125;<br>    str += <span class="hljs-string">`<span class="hljs-subst">$&#123;attr.name&#125;</span>:<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;str.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>&#125;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 生成子节点 调用gen函数进行递归创建</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildren</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> children = el.<span class="hljs-property">children</span>;<br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;children.map((c) =&gt; gen(c)).join(<span class="hljs-string">&quot;,&quot;</span>)&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 递归创建生成code</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title function_">getChildren</span>(el);<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-string">`_c(&#x27;<span class="hljs-subst">$&#123;el.tag&#125;</span>&#x27;,<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    el.attrs.length ? <span class="hljs-string">`<span class="hljs-subst">$&#123;genProps(el.attrs)&#125;</span>`</span> : <span class="hljs-string">&quot;undefined&quot;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;</span><span class="hljs-subst">$&#123;children ? <span class="hljs-string">`,<span class="hljs-subst">$&#123;children&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>)`</span>;<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="code-字符串生成-render-函数"><a href="#code-字符串生成-render-函数" class="headerlink" title="code 字符串生成 render 函数"></a>code 字符串生成 render 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">// 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值 比如 name值就变成了this.name</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="组件挂载入口"><a href="#组件挂载入口" class="headerlink" title="组件挂载入口"></a>组件挂载入口</h1><p>模板编译解析生成了render函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>  el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>  <br>  <span class="hljs-comment">// 如果不存在 render 属性</span><br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>    <span class="hljs-comment">// 如果存在 template 属性</span><br>    <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br>    <br>    <span class="hljs-keyword">if</span> (!templage &amp;&amp; el) &#123;<br>      <span class="hljs-comment">// 如果不存在 render 和 template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>      template = el.<span class="hljs-property">outerHTML</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>    <span class="hljs-keyword">if</span> (template) &#123;<br>      <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>      options.<span class="hljs-property">render</span> = render;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将当前组件实例挂载到真实的el节点上面</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountComponent</span>(vm, el);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-函数-gt-虚拟-dom-render"><a href="#render-函数-gt-虚拟-dom-render" class="headerlink" title="render 函数 -&gt; 虚拟 dom  _render"></a>render 函数 -&gt; 虚拟 dom  _render</h1><p>执行vm._render()方法 调用生成的render函数 生成虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/render.js</span><br><span class="hljs-keyword">import</span> &#123; createElement, createTextNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/index&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取模板编译生成的render方法</span><br>    <span class="hljs-keyword">const</span> &#123; render &#125; = vm.<span class="hljs-property">$options</span>;<br>    <span class="hljs-comment">// 生成 vnode 虚拟dom</span><br>    <span class="hljs-keyword">const</span> vnode = render.<span class="hljs-title function_">call</span>(vm);<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br><br>  <span class="hljs-comment">// render函数里面有_c _v _s方法需要定义</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_c</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(...args);<br>  &#125;;<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_v</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_s</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-comment">// 如果模板里面的是一个对象  需要JSON.stringify</span><br>    <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span><br>      ? <span class="hljs-string">&quot;&quot;</span><br>      : <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;object&quot;</span><br>      ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(val)<br>      : val;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/index.js</span><br><br><span class="hljs-comment">// 定义Vnode类</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vnode</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, data, key, children, text</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建元素vnode 等于render函数里面的 h=&gt;h(App)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag, data = &#123;&#125;, ...children</span>) &#123;<br>  <span class="hljs-keyword">let</span> key = data.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(tag, data, key, children);<br>&#125;<br><br><span class="hljs-comment">// 创建文本vnode</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, text);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="虚拟dom-gt-真实-dom-update"><a href="#虚拟dom-gt-真实-dom-update" class="headerlink" title="虚拟dom -&gt;真实 dom   _update"></a>虚拟dom -&gt;真实 dom   _update</h1><p>_update 核心方法就是 patch 初始渲染和后续更新都是共用这一个方法 只是传入的第一个参数不同 初始渲染总体思路就是根据虚拟 dom(vnode) 调用原生 js 方法创建真实 dom 节点并替换掉 el 选项的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><br><span class="hljs-keyword">import</span> &#123; patch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/patch&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-comment">// 把_update挂载在Vue的原型</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// patch是渲染vnode为真实dom核心</span><br>    vm.<span class="hljs-property">$el</span> = <span class="hljs-title function_">patch</span>(vm.<span class="hljs-property">$el</span>, vnode)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/patch.js</span><br><span class="hljs-comment">// patch 用来渲染和更新视图 （此处仅包含初次渲染的逻辑）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode</span>) &#123;<br>  <span class="hljs-comment">// 判断传入的oldVnode是否是一个真实元素</span><br>  <span class="hljs-comment">// 这里很关键 初次渲染 传入的vm.$el就是咱们传入的el选项  所以是真实dom</span><br>  <span class="hljs-comment">// 如果不是初始渲染而是视图更新的时候  vm.$el就被替换成了更新之前的老的虚拟dom</span><br>  <span class="hljs-keyword">const</span> isRealElement = oldVnode.<span class="hljs-property">nodeType</span>;<br>  <span class="hljs-keyword">if</span> (isRealElement) &#123;<br>    <span class="hljs-comment">// 这里是初次渲染的逻辑</span><br>    <span class="hljs-keyword">const</span> oldElm = oldVnode;<br>    <span class="hljs-keyword">const</span> parentElm = oldElm.<span class="hljs-property">parentNode</span>;<br>    <span class="hljs-comment">// 将虚拟dom转化成真实dom节点</span><br>    <span class="hljs-keyword">let</span> el = <span class="hljs-title function_">createElm</span>(vnode);<br>    <span class="hljs-comment">// 插入到 老的el节点下一个节点的前面 就相当于插入到老的el节点的后面</span><br>    <span class="hljs-comment">// 这里不直接使用父元素appendChild是为了不破坏替换的位置</span><br>    parentElm.<span class="hljs-title function_">insertBefore</span>(el, oldElm.<span class="hljs-property">nextSibling</span>);<br>    <span class="hljs-comment">// 删除老的el节点</span><br>    parentElm.<span class="hljs-title function_">removeChild</span>(oldVnode);<br>    <span class="hljs-keyword">return</span> el;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 虚拟 dom 转成真实 dom 就是调用原生方法生成 dom 树</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; tag, data, key, children, text &#125; = vnode;<br>  <span class="hljs-comment">//   判断虚拟dom 是元素节点还是文本节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   虚拟dom的el属性指向真实dom</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);<br>    <span class="hljs-comment">// 解析虚拟dom属性</span><br>    <span class="hljs-title function_">updateProperties</span>(vnode);<br>    <span class="hljs-comment">// 如果有子节点就递归插入到父节点里面</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElm</span>(child));<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   文本节点</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析vnode的data属性 映射到真实dom上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProperties</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> newProps = vnode.<span class="hljs-property">data</span> || &#123;&#125;;<br>  <span class="hljs-keyword">let</span> el = vnode.<span class="hljs-property">el</span>; <span class="hljs-comment">//真实节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-comment">// style需要特殊处理下</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> newProps.<span class="hljs-property">style</span>) &#123;<br>        el.<span class="hljs-property">style</span>[styleName] = newProps.<span class="hljs-property">style</span>[styleName];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;class&quot;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = newProps.<span class="hljs-property">class</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 给这个元素添加属性 值就是对应的值</span><br>      el.<span class="hljs-title function_">setAttribute</span>(key, newProps[key]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mountComponent-挂载"><a href="#mountComponent-挂载" class="headerlink" title="mountComponent 挂载"></a>mountComponent 挂载</h1><p>使用vm._update()方法把虚拟dom渲染到页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">// 上一步模板编译解析生成了render函数</span><br>  <span class="hljs-comment">// 下一步就是执行vm._render()方法 调用生成的render函数 生成虚拟dom</span><br>  <span class="hljs-comment">// 最后使用vm._update()方法把虚拟dom渲染到页面</span><br>  <span class="hljs-comment">// 真实的el选项赋值给实例的$el属性 为之后虚拟dom产生的新的dom替换老的dom做铺垫</span><br>  vm.<span class="hljs-property">$el</span> = el;<br>  <span class="hljs-comment">// _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-和-update-原型方法的混入"><a href="#render-和-update-原型方法的混入" class="headerlink" title="_render 和 _update 原型方法的混入"></a>_render 和 _update 原型方法的混入</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lifecycle&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./render&quot;</span>;<br><span class="hljs-comment">// Vue就是一个构造函数 通过new关键字进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 这里开始进行Vue初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载需要传入Vue</span><br><span class="hljs-comment">// 此做法有利于代码分割</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><br><span class="hljs-comment">// 混入_render</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-comment">// 混入_update</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello &#123;&#123;a&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们在这里模拟更新</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">a</span> = <span class="hljs-number">456</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 此方法是刷新视图的核心</span></span><br><span class="language-javascript">    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在数据变动的时候自动去更新视图</p><h1 id="定义-Watcher"><a href="#定义-Watcher" class="headerlink" title="定义 Watcher"></a>定义 Watcher</h1><p>在 observer 文件夹下新建 watcher.js 代表和观察者相关 可以把 Watcher 当做观察者 它需要订阅数据的变动 当数据变动之后 通知它去执行某些方法 其实本质就是一个构造函数 初始化的时候会去执行 get 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><span class="hljs-comment">// 全局变量id 每次 new Watcher 都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建渲染-Watcher"><a href="#创建渲染-Watcher" class="headerlink" title="创建渲染 Watcher"></a>创建渲染 Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">//   _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br><br>  <span class="hljs-comment">// 引入watcher的概念 这里注册一个渲染watcher 执行vm._update(vm._render())方法渲染视图</span><br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;刷新页面&quot;</span>);<br>    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>  &#125;;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="定义-Dep"><a href="#定义-Dep" class="headerlink" title="定义 Dep"></a>定义 Dep</h1><p>Dep 也是一个构造函数 可以把他理解为观察者模式里面的被观察者 在 subs 里面收集 watcher 当数据变动的时候通知自身 subs 所有的 watcher 更新<br>Dep.target 是一个全局 Watcher 指向 初始状态是 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h1 id="对象的依赖收集"><a href="#对象的依赖收集" class="headerlink" title="对象的依赖收集"></a>对象的依赖收集</h1><p>依赖收集和派发更新的核心 其实就是在数据被访问的时候 把我们定义好的渲染 Watcher 放到 dep 的 subs 数组里面 同时把 dep 实例对象也放到渲染 Watcher 里面去 数据更新时就可以通知 dep 的 subs 存储的 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value);<br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-watcher"><a href="#完善-watcher" class="headerlink" title="完善 watcher"></a>完善 watcher</h1><p>watcher 在调用 getter 方法前后分别把自身赋值给 Dep.target 方便进行依赖收集 update 方法用来更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dep&quot;</span>;<br><br><span class="hljs-comment">// 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []; <span class="hljs-comment">//存放dep的容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">//用来去重dep</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>(); <span class="hljs-comment">//如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-keyword">let</span> id = dep.<span class="hljs-property">id</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">add</span>(id);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);<br>      <span class="hljs-comment">//   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-dep"><a href="#完善-dep" class="headerlink" title="完善 dep"></a>完善 dep</h1><p>定义相关的方法把收集依赖的同时把自身也放到 watcher 的 deps 容器里面去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   如果当前存在watcher</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 把自身-dep实例存放在watcher里面</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   依次执行subs里面的watcher更新方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">watcher</span>) =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-comment">//   把watcher加入到自身的subs容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的依赖收集"><a href="#数组的依赖收集" class="headerlink" title="数组的依赖收集"></a>数组的依赖收集</h1><p>如果对象属性的值是一个数组 那么执行 childOb.dep.depend()收集数组的依赖 如果数组里面还包含数组 需要递归遍历收集 因为只有访问数据触发了 get 才会去收集依赖 一开始只是递归对数据进行响应式处理无法收集依赖 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// childOb就是Observer实例</span><br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          <span class="hljs-comment">// 这里表示 属性的值依然是一个对象 包含数组和对象 childOb指代的就是Observer实例对象  里面的dep进行依赖收集</span><br>          <span class="hljs-comment">// 比如&#123;a:[1,2,3]&#125; 属性a对应的值是一个数组 观测数组的返回值就是对应数组的Observer实例对象</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果数据结构类似 &#123;a:[1,2,[3,4,[5,6]]]&#125; 这种数组多层嵌套  数组包含数组的情况  那么我们访问a的时候 只是对第一层的数组进行了依赖收集 里面的数组因为没访问到  所以五大收集依赖  但是如果我们改变了a里面的第二层数组的值  是需要更新页面的  所以需要对数组递归进行依赖收集</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>              <span class="hljs-comment">// 如果内部还是数组</span><br>              <span class="hljs-title function_">dependArray</span>(value); <span class="hljs-comment">// 不停的进行依赖收集</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 递归收集数组依赖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dependArray</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e, i = <span class="hljs-number">0</span>, l = value.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    e = value[i];<br>    <span class="hljs-comment">// e.__ob__代表e已经被响应式观测了 但是没有收集依赖 所以把他们收集到自己的Observer实例的dep里面</span><br>    e &amp;&amp; e.<span class="hljs-property">__ob__</span> &amp;&amp; e.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(e)) &#123;<br>      <span class="hljs-comment">// 如果数组里面还有数组  就递归去收集依赖</span><br>      <span class="hljs-title function_">dependArray</span>(e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的派发更新"><a href="#数组的派发更新" class="headerlink" title="数组的派发更新"></a>数组的派发更新</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/array.js</span><br><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">//   这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 这句话是关键</span><br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性代表的是该数据已经被响应式观察过了 __ob__对象指的就是Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted); <span class="hljs-comment">// 对新增的每一项进行观测</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">//数组派发更新 ob指的就是数组对应的Observer实例 我们在get的时候判断如果属性的值还是对象那么就在Observer实例的dep收集依赖 所以这里是一一对应的  可以直接更新</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>watch</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/</url>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>侦听属性的写法很多 可以写成 字符串 函数 数组 以及对象 对于对象的写法自己可以增加一些 options 用来增强功能 侦听属性的特点是监听的值发生了变化之后可以执行用户传入的自定义方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;&#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">aa</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#x27;doSomething&#x27;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: [&#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;]</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">aa</span> = <span class="hljs-number">1111</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 统一初始化数据的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-title function_">initWatch</span>(vm);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 watch</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> watch = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">watch</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> watch) &#123;<br>    <span class="hljs-keyword">const</span> handler = watch[k]; <span class="hljs-comment">// 用户自定义 watch 的写法，可能是数组 对象 函数 字符串</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;<br>      <span class="hljs-comment">// 如果是数组就遍历进行创建</span><br>      handler.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">handle</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, k, handle);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, k, handler);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建watcher的核心</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span>(<span class="hljs-params">vm, exprOrFn, handler, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    options = handler; <span class="hljs-comment">//保存用户传入的对象</span><br>    handler = handler.<span class="hljs-property">handler</span>; <span class="hljs-comment">//这个代表真正用户传入的函数</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   代表传入的是定义好的methods方法</span><br>    handler = vm[handler];<br>  &#125;<br>  <span class="hljs-comment">//   调用vm.$watch创建用户watcher</span><br>  <span class="hljs-keyword">return</span> vm.$watch(exprOrFn, handler, options);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h1><p>原型方法$watch 就是创建自定义 watch 的核心方法 把用户定义的 options 和 user:true 传给构造函数 Watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observer/watcher&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">experOrFn, cb, option</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">let</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, exprOrFn, cb, &#123; ...options, <span class="hljs-attr">user</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-comment">// 如果有immediate属性 代表需要立即执行回调</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">cb</span>(); <span class="hljs-comment">// 如果立刻执行</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; isObject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = options.<span class="hljs-property">user</span>; <span class="hljs-comment">//标识用户watcher</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>        <span class="hljs-keyword">let</span> path = exprOrFn.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">let</span> obj = vm;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>          obj = obj[path[i]]; <span class="hljs-comment">//vm.a.a.a.a.b</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就进行一次取值操作 进行依赖收集过程</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-comment">//   get() &#123;</span><br>  <span class="hljs-comment">//     pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>  <span class="hljs-comment">//     const res = this.getter.call(this.vm); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>  <span class="hljs-comment">//     popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  <span class="hljs-comment">//     return res;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-comment">//   update() &#123;</span><br>  <span class="hljs-comment">//     // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>  <span class="hljs-comment">//     if (this.lazy) &#123;</span><br>  <span class="hljs-comment">//       this.dirty = true;</span><br>  <span class="hljs-comment">//     &#125;else&#123;</span><br>  <span class="hljs-comment">//       // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>  <span class="hljs-comment">//       // 异步队列机制</span><br>  <span class="hljs-comment">//       queueWatcher(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   depend()&#123;</span><br>  <span class="hljs-comment">//     // 计算属性的watcher存储了依赖项的dep</span><br>  <span class="hljs-comment">//     let i=this.deps.length</span><br>  <span class="hljs-comment">//     while(i--)&#123;</span><br>  <span class="hljs-comment">//       this.deps[i].depend() //调用依赖项的dep去收集渲染watcher</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newVal = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">//新值</span><br>    <span class="hljs-keyword">const</span> oldVal = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">//老值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = newVal; <span class="hljs-comment">//现在的新值将成为下一次变化的老值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>      <span class="hljs-comment">// 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址</span><br>      <span class="hljs-keyword">if</span> (newVal !== oldVal || <span class="hljs-title function_">isObject</span>(newVal)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, newVal, oldVal);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 渲染watcher</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>在两秒之后改变了模板里面的 cc 但是计算属性依赖的 aa 和 bb 都没变化 所以计算属性不会重新计算 还是保留的上次计算结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">cc</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;computedName&#125;&#125;&#123;&#123;cc&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">computedName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">aa</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bb</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-comment">// 当我们每一次改变数据的时候  渲染watcher都会执行一次 这个是影响性能的</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">cc</span> = <span class="hljs-number">4</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">2000</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="计算属性的初始化"><a href="#计算属性的初始化" class="headerlink" title="计算属性的初始化"></a>计算属性的初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">const</span> computed = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">computed</span>;<br>  <span class="hljs-keyword">const</span> watchers = (vm.<span class="hljs-property">_computedWatchers</span> = &#123;&#125;); <span class="hljs-comment">// 用来存放计算 watcher</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> coumputed) &#123;<br>    <span class="hljs-keyword">const</span> userEdf = computed[k]; <span class="hljs-comment">// 获取用户定义的计算属性</span><br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span>;<span class="hljs-comment">//创建计算属性watcher使用</span><br>    <span class="hljs-comment">// 创建计算watcher lazy设置为true</span><br>    watchers[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, <span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;);<br>    <span class="hljs-title function_">defineComputed</span>(vm, k, userDef);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对计算属性进行属性劫持"><a href="#对计算属性进行属性劫持" class="headerlink" title="对计算属性进行属性劫持"></a>对计算属性进行属性劫持</h1><p><code>defineComputed</code> 方法主要是重新定义计算属性 其实最主要的是劫持 get 方法 也就是计算属性依赖的值。<br>需要根据依赖值是否发生变化来判断计算属性是否需要重新计算<br><code>createComputedGetter</code> 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 <code>Watcher</code> 增加 <code>dirty</code> 标志位 如果标志变为 <code>true</code> 代表需要调用 <code>watcher.evaluate</code> 来进行重新计算了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 定义普通对象用来劫持计算属性</span><br><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;<br><span class="hljs-comment">// 重新定义计算属性 对 get 和 set 劫持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key, userDef</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果是一个函数  需要手动赋值到get上</span><br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = userDef.<span class="hljs-property">set</span>;<br>  &#125;<br>  <span class="hljs-comment">//   利用Object.defineProperty来对计算属性的get和set进行劫持</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition);<br>&#125;<br><span class="hljs-comment">// 重写计算属性的 get 方法，来判断是否需要进行重新计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]; <span class="hljs-comment">//获取对应的计算属性watcher</span><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;<br>        watcher.evaluate(); <span class="hljs-comment">//计算属性取值的时候 如果是脏的  需要重新求值</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>1.实例化的时候如果是计算属性 不会去调用 get 方法访问值进行依赖收集<br>2.update 方法只是把计算 watcher 的 dirty 标识为 true 只有当下次访问到了计算属性的时候才会重新计算<br>3.新增 evaluate 方法专门用于计算属性重新计算<br>4.新增 depend 方法 让计算属性的依赖值收集外层 watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-comment">// import &#123; pushTarget, popTarget &#125; from &quot;./dep&quot;;</span><br><span class="hljs-comment">// import &#123; queueWatcher &#125; from &quot;./scheduler&quot;;</span><br><span class="hljs-comment">// import &#123;isObject&#125; from &#x27;../util/index&#x27;</span><br><span class="hljs-comment">// // 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-comment">// let id = 0;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br>    <span class="hljs-comment">// this.user = options.user; //标识用户watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//标识计算属性watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//dirty可变  表示计算watcher是否需要重新计算 默认值是true</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-comment">// if (typeof exprOrFn === &quot;function&quot;) &#123;</span><br>    <span class="hljs-comment">//   this.getter = exprOrFn;</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//   this.getter = function () &#123;</span><br>    <span class="hljs-comment">//     //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>    <span class="hljs-comment">//     let path = exprOrFn.split(&quot;.&quot;);</span><br>    <span class="hljs-comment">//     let obj = vm;</span><br>    <span class="hljs-comment">//     for (let i = 0; i &lt; path.length; i++) &#123;</span><br>    <span class="hljs-comment">//       obj = obj[path[i]]; //vm.a.a.a.a.b</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return obj;</span><br>    <span class="hljs-comment">//   &#125;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>); <span class="hljs-comment">//计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>      <span class="hljs-comment">// 异步队列机制</span><br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   计算属性重新进行计算 并且计算完成把dirty置为false</span><br>  <span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性的watcher存储了依赖项的dep</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">//调用依赖项的dep去收集渲染watcher</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   run() &#123;</span><br>  <span class="hljs-comment">//     const newVal = this.get(); //新值</span><br>  <span class="hljs-comment">//     const oldVal = this.value; //老值</span><br>  <span class="hljs-comment">//     this.value = newVal; //跟着之后  老值就成为了现在的值</span><br>  <span class="hljs-comment">//     if (this.user) &#123;</span><br>  <span class="hljs-comment">//       if(newVal!==oldVal||isObject(newVal))&#123;</span><br>  <span class="hljs-comment">//         this.cb.call(this.vm, newVal, oldVal);</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     &#125; else &#123;</span><br>  <span class="hljs-comment">//       // 渲染watcher</span><br>  <span class="hljs-comment">//       this.cb.call(this.vm);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="外层-Watcher-的依赖收集"><a href="#外层-Watcher-的依赖收集" class="headerlink" title="外层 Watcher 的依赖收集"></a>外层 Watcher 的依赖收集</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-comment">//   return function () &#123;</span><br><span class="hljs-comment">//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher</span><br><span class="hljs-comment">//     if (watcher) &#123;</span><br><span class="hljs-comment">//       if (watcher.dirty) &#123;</span><br><span class="hljs-comment">//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-comment">// 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集</span><br>          watcher.<span class="hljs-title function_">depend</span>()<br>        &#125;<br><span class="hljs-comment">//       &#125;</span><br><span class="hljs-comment">//       return watcher.value;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性依赖的值发生了改变 这时候 watcher 的 dirty 为 true 下次访问计算属性 ,此时数据改变了，但是还没触发视图更新<br>因为模板里面只有计算属性 而计算属性的依赖值的 dep 里面只收集了计算 watcher 的依赖 。<br>自身变化也只是通知了计算 watcher 调用 update 把 dirty 置为 true 。<br>所以需要把计算属性的依赖项也添加渲染 watcher 的依赖。<br>让自身变化之后首先通知计算 watcher 进行重新计算 然后通知渲染 watcher 进行视图更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>可见最初设计存放 watcher 的容器就是一个栈结构。<br>因为整个 Vue 生命周期的过程中会存在很多的 watcher 比如渲染 watcher 计算 watcher 侦听 watcher 等。<br>而每个 watcher 在调用了自身的 get 方法前后会分别调用 pushTarget 入栈和 popTarget 出栈。<br>这样子当计算属性重新计算之后就立马会出栈 那么外层的 watcher 就会成为新的 Dep.target。<br>使用 watcher.depend 方法让计算属性依赖的值收集一遍外层的渲染 watcher 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="header-body"><a href="#header-body" class="headerlink" title="header + body"></a>header + body</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">起始行+头部+空行+实体<br></code></pre></td></tr></table></figure><h4 id="请求报文的结构"><a href="#请求报文的结构" class="headerlink" title="请求报文的结构"></a>请求报文的结构</h4><h5 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/home</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p>方法 + 路径 + http 版本</p><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>请求体</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><ul><li>GET <ul><li>通常用来获取资源</li></ul></li><li>HEAD <ul><li>获取资源的元信息</li></ul></li><li>POST <ul><li>上传数据</li><li>会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body 部分。(火狐浏览器除外，他的 POST 请求只发一个 TCP 包)</li></ul></li><li>PUT <ul><li>修改完整数据</li></ul></li><li>PATCH <ul><li>修改部分数据</li></ul></li><li>DELETE <ul><li>删除资源</li></ul></li><li>CONNECT <ul><li>建立连接隧道，用于代理服务器</li></ul></li><li>OPTIONS <ul><li>列出可对资源实行的请求方法，用来跨域请求</li></ul></li><li>TRACE <ul><li>追求请求-响应传输的路径</li></ul></li></ul><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p>URI(Uniform Resource Identifier) 统一资源标识符，作用：区分互联网上不同的资源</p><p>网址：URL，URI 包含了 URL 和 URN 两个部分，</p><h6 id="URI的结构："><a href="#URI的结构：" class="headerlink" title="URI的结构："></a>URI的结构：</h6><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" alt="image.png"></p><p><strong>scheme</strong> 表示协议名，比如 http, https, file 等等。后面必须和:&#x2F;&#x2F;连在一起</p><p>**user:password@**表示登录主机时的用户信息，很不安全，不推荐使用，不常用</p><p><strong>host:port</strong>表示主机名和端口</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为key&#x3D;val这种形式，多个键值对之间用&amp;隔开</p><p><strong>fagment</strong>表示 URI 所定位的资源内的一个 <strong>锚点</strong>，浏览器可以通过这个锚点跳转到对于的 位置</p><h5 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h5><p><strong>URI</strong> 只能使用 <strong>ASCII</strong>，<strong>ASCLII</strong>之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错</p><p>因此，<strong>URI</strong> 引入了编码机制，将所有 <strong>非 ASSCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个 <strong>%</strong></p><p>例：空格转义为**%20**</p><h4 id="响应报文的结构"><a href="#响应报文的结构" class="headerlink" title="响应报文的结构"></a>响应报文的结构</h4><h5 id="起始行也叫状态行"><a href="#起始行也叫状态行" class="headerlink" title="起始行也叫状态行"></a>起始行也叫状态行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><p>http 版本 + 状态码 + 原因</p><h5 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h5><ul><li><strong>1xx：</strong>表示目前是协议处理中的中间状态，还需要后续操作。 <ul><li><strong>101 Switching Protocols</strong> 在 HTTP 升级为 webSocket 的时候，如果服务器同意变更，就会发送状态码 101</li></ul></li><li><strong>2xx：</strong>  表示成功状态。 <ul><li><strong>200 OK</strong> 成功状态码，响应体中有数据。</li><li><strong>204 No Content</strong> 成功状态码，响应体中无数据。</li><li><strong>206 Partial Content</strong> 表示部分内容，使用场景为：HTTP 分块下载和断点续传，会带上相应的响应头字段 Content-Range。</li></ul></li><li><strong>3xx：</strong>重定向状态，资源位置发生变动，需要重新请求 <ul><li><strong>301 Moved Permanently</strong> 永久重定向 </li><li><strong>302 Found</strong> 临时重定向<br>例：<br> 以前的站点再也不用了返回 301，浏览器会默认做优化缓存，在第二次访问的时候自动访问重定向的那个地址。<br> 以前的站点暂时不可用，直接返回 302 ，浏览器不会做缓存优化 </li><li><strong>304 Not Modified</strong> 当协商缓存命中时会返回这个状态码。</li></ul></li><li><strong>4xx：</strong>请求报文有误 <ul><li><strong>400 Bad Request</strong> 服务器无法理解该请求 可能是语法错误。</li><li><strong>403 Forbidden</strong> 服务器禁止访问。</li><li><strong>404 Not Found</strong> 资源未找到，没在服务器上找到相应的资源。</li><li><strong>405 Method Not Allowed</strong> 请求方法不被服务器允许。</li><li><strong>406 Not Acceptable</strong> 资源无法满足客户端的条件。</li><li><strong>408 Request Timeout</strong> 服务器等待了太长时间。</li><li><strong>409 Conflict</strong> 多个请求发生了冲突。</li><li><strong>413 Request Entity Too Large</strong> 请求体的数据过大。</li></ul></li><li><strong>5xx</strong> <ul><li><strong>500 Internal Server Error</strong> 服务器出错</li><li><strong>501 Not Implemented</strong> 客户端请求的功能还不支持。</li><li><strong>502 Bad Gateway</strong> 服务器自身是正常的，但是访问的时候出错了。</li><li><strong>503 Service Unavailable</strong> 服务器当前很忙，暂时无法响应服务。</li></ul></li><li><strong>5xx：</strong>服务端发生错误</li></ul><h3 id="HTTP特点以及缺点"><a href="#HTTP特点以及缺点" class="headerlink" title="HTTP特点以及缺点"></a>HTTP特点以及缺点</h3><h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><ol><li>灵活可拓展 <ol><li>语义上自由，只有基本格式没有严格限制</li><li>传输形式多样性，可以传输文本、图片、视频等任意数据</li></ol></li><li>可靠传输，HTTP基于 TCP&#x2F;IP ，这是 TCP 的特性</li><li>请求-应答，一发一收、有来有回。</li><li>无状态，状态：通信过程的上下文信息，每次 http 请求都是独立、无关的，默认不需要保留状态信息</li></ol><h4 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h4><ol><li>无状态</li></ol><ul><li>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，此时是缺点</li><li>在只是获取一些数据的场景中，不需要保存连接上下文信息，无状态减少了网络开销，此时是优点</li></ul><ol start="2"><li>明文传输<br>协议里的报文（主要指头部）不使用二进制数据，而是文本形式<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<strong>WIFI陷阱</strong> 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。 </li><li>队头阻塞问题</li></ol><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><h3 id="Accept-系列字段"><a href="#Accept-系列字段" class="headerlink" title="Accept 系列字段"></a>Accept 系列字段</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>发送端：Content-Type 字段</p><p>接收端：Accept 字段</p><p>取值：</p><pre><code class="hljs">text： text/html, text/plain, text/css 等image: image/gif, image/jpeg, image/png 等audio/video: audio/mpeg, video/mp4 等application: application/json, application/javascript, application/pdf, application/octet-stream</code></pre><h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>发送方：Content-Encoding</p><p>接受方：Accept-Encoding</p><p>取值:</p><pre><code class="hljs">gzip:最流行的压缩格式deflate:另一种著名的压缩格式br:一种专门为 HTTP 发明的压缩算法</code></pre><h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>发送端：Content-Language</p><p>接收方：Accept-Language</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>发送方：Content-Type:charset&#x3D;utf-8</p><p>接收端：Accept-Charset:charset&#x3D;utf-8</p><h3 id="HTTP对定长和不定长数据传输的处理"><a href="#HTTP对定长和不定长数据传输的处理" class="headerlink" title="HTTP对定长和不定长数据传输的处理"></a>HTTP对定长和不定长数据传输的处理</h3><h4 id="定长包"><a href="#定长包" class="headerlink" title="定长包"></a>定长包</h4><p>发送端带上Content-length</p><h4 id="不定长包"><a href="#不定长包" class="headerlink" title="不定长包"></a>不定长包</h4><p>发送端带上 Transfer-Encoding: chunked</p><p>表示分块传输数据，设置这个字段后会自动产生两个效果</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推动动态内容</li></ul><h3 id="HTTP-处理大文件传输"><a href="#HTTP-处理大文件传输" class="headerlink" title="HTTP 处理大文件传输"></a>HTTP 处理大文件传输</h3><p>采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分</p><p>服务端发送：</p><p>添加上 Accept-Ranges:none 响应头，来告诉客户端这边年支持范围请求</p><p>客户端：</p><p>Range 字段拆解，客户端需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes&#x3D;x-y</p><p>Range 的书写格式：</p><pre><code class="hljs">0-499 表示从开始到第 499 个字节。500- 表示从第 500 字节到文件终点。-100 表示文件最后 100 个字节。</code></pre><p>服务端接收：</p><pre><code class="hljs">接受到请求之后，先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码同时服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同而又所差异</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// 单段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9<br>// 多段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9, 30-39<br></code></pre></td></tr></table></figure><h3 id="HTTP1-1解决HTTP队头阻塞问题"><a href="#HTTP1-1解决HTTP队头阻塞问题" class="headerlink" title="HTTP1.1解决HTTP队头阻塞问题"></a>HTTP1.1解决HTTP队头阻塞问题</h3><p>HTTP传输基于 请求-应答的模式进行，传输任务是放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p><h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>一个域名可以并发 6 个长连接，多分几个域名</p><p>这样一个 baidu.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>HTTP是无状态的协议，需要保存状态就引入了Cookie</p><p>Cookie 本身是浏览器里面存储的一个很小的本地文件，内部以键值对的方式存储。同一个域名下发送请求，都会携带相同的 Cookie ，服务器拿到 Cookie 进行解析，就可以拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 请求头<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>a=xxx;b=xxx<br>// 响应头<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>a=xxx<br><span class="hljs-attribute">set-Cookie</span><span class="hljs-punctuation">: </span>b=xxx<br></code></pre></td></tr></table></figure><h4 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h4><p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置</p><ul><li>Expires 即过期时间</li><li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算</li></ul><p>若Cookie过期，则这个Cookie会被删除，并不会发送给服务端</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域有两个属性：Domain和path，都给Cookie绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上Cookie。对于路径来说，&#x2F;表示域名下的任意路径都允许使用Cookie。</p><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果带上Secure，说明只能通过 HTTPS 传输 cookie。</p><p>如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p><p>CSRF攻击的预防可以通过SameSite属性。</p><p>SameSite 可以设置为三个值：Strict、Lax和None。</p><ol><li>在 Strict 模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>baidu.com</code>网站只能在<code>baidu.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</li><li>在 Lax 模式下，宽松一点，只能在 get 方法提交表单 或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li><li>在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ol><h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ol><li>容量缺陷 体积上限是 4kB</li><li>性能缺陷 Cookie紧跟域名，不管域名下面的某一个子域名需不需要这个 Cookie 请求都会携带上完整的Cookie，请求数量一多会照成巨大的性能浪费，可以通过 Domain 和 Path 指定作用域来解决。</li><li>安全缺陷，由于 Cookie 以纯文本的形式传递很容易被非法用户截获，然后进行一系列篡改，在Cookie的有效期内重新推送给服务器，在 HttpOnly 为 false 的情况下，Cookie信息能直接通过 JS 脚本来读取。</li></ol><h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><p>HTTP基于请求-响应模型的协议，一般由客户端发请求，服务器来响应</p><p>如果有代理服务器，引入代理之后，作为代理的服务器相当与一个中间人的角色，对于客户端表现为服务器进行响应，对于源服务器表现为客户端发起请求，具有双重身份。</p><h4 id="HTTP-代理的功能"><a href="#HTTP-代理的功能" class="headerlink" title="HTTP 代理的功能"></a>HTTP 代理的功能</h4><ol><li><strong>负载均衡</strong>： <ol><li>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li></ol></li><li><strong>保障安全:</strong> <ol><li>利用心跳机制监控后台服务器，一旦发现故障机就将其踢出集群，并且对于上下行的数据进行过滤，对于非法IP限流，这些都是代理服务器的工作</li></ol></li><li><strong>缓存代理：</strong> <ol><li>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得，而不用到的源服务器那里获得。</li></ol></li></ol><h4 id="相关头字段"><a href="#相关头字段" class="headerlink" title="相关头字段"></a>相关头字段</h4><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><pre><code class="hljs">代理服务器通过 Via 字段在 HTTP 传输中留下自己的痕迹Via中的代理的顺序即为在 HTTP 传输中报文传达的顺序</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器<br>// 源服务器收到请求后，请求头<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>proxy_server1,proxy_server2<br>// 源服务器响应时候，客户端的响应头<br>Via:proxy_server2,proxr_server1<br></code></pre></td></tr></table></figure><h5 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h5><pre><code class="hljs">为谁转发，记录的是请求方的IP地址</code></pre><h5 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h5><pre><code class="hljs">获取用户真实IP的字段，不管中间经过了多少代理，这个字段始终记录最初客户端的IP对应的有 **X-Forwarded-Host** 和 **X-forwarded-Proto**，分别记录客户端(不包括代理)的域名和协议名</code></pre><h5 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h5><pre><code class="hljs">此字段是记录请求方的IP，意味着每经过一个不同的代理，这个字段的名字都要改变，从客户端到代理1，这个字段是客户端的IP，从代理1到代理2，这个字段变成了代理1的IP</code></pre><p>意味着会产生两个问题：</p><ol><li>代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降</li><li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的</li></ol><p>由此产生了 <strong>代理协议</strong> ，一般使用明文版本，只需要在HTTP请求行上面加上这样格式的文本即可:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接受端口<br>PREOXY TCP4 0.0.0.1 0.0.0.2 1111 2222<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以解决X-Forwarded-For产生的问题</p><h3 id="HTTP缓存及缓存代理"><a href="#HTTP缓存及缓存代理" class="headerlink" title="HTTP缓存及缓存代理"></a>HTTP缓存及缓存代理</h3><h4 id="关于-强缓存-和-协商缓存"><a href="#关于-强缓存-和-协商缓存" class="headerlink" title="关于 强缓存 和 协商缓存"></a>关于 <strong>强缓存</strong> 和 <strong>协商缓存</strong></h4><p>首先通过 Cache-Control 验证强缓存是否可用</p><ul><li>如果强缓存可用，直接使用</li><li>否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新 <ul><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存中获取资源</li></ul></li></ul><h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><p>对于服务器来说，也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的</p><p>由此引入了缓存代理的机制，让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候就能明显降低源服务器的压力</p><h5 id="代理缓存的实现："><a href="#代理缓存的实现：" class="headerlink" title="代理缓存的实现："></a>代理缓存的实现：</h5><ul><li>代理缓存的控制分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制</li></ul><h6 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h6><p><strong>private 和 public</strong></p><p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入priivate或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。</p><p>对于一些比较私密的数据，如果缓存到代理服务器上，比如直接访问代理就可以直接拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头的Cache-Control设为private，而不是public</p><p><strong>proxy-revalidate</strong></p><p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取</p><p><strong>s-maxage</strong></p><p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:public,max-age=1000,s-maxage=2000<br></code></pre></td></tr></table></figure><p>相当于源服务器说：我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理服务器中拿，并且客户端的缓存时间为1000秒，在代理服务器中的缓存时间为2000秒</p><h6 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h6><h6 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h6><p>在客户端的请求头中，可以加入两个字段，来对代理服务器上的缓存进行宽容和限制的操作</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">max-stale:5<br></code></pre></td></tr></table></figure><p>表示客户端到代理服务器上那缓存的时候，即使缓存过期了也不要紧，只要在过期时间在5秒之内，还可以从代理中获取的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">min-fresh:5<br></code></pre></td></tr></table></figure><p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前5秒之前的时间拿，否则拿不到</p><h6 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h6><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>因为浏览器遵循同源政策(协议、主机和端口都相同则为同源)。非同源站点有这样一些限制:</p><ul><li>不能读取和修改对方的DOM</li><li>不能访问对方的Cookie、IndexDb和LocalStorage</li><li>限制XMLHttpRequest请求。</li></ul><p>当浏览器向着目标URI发出Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被称为跨域请求。</p><p>跨域请求的响应会被浏览器所拦截，响应是成功到达客户端了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>跨域资源共享</p><p>它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头</p><p><strong>简单请求</strong></p><ul><li>请求方法为GET、POST或者HEAD </li><li>请求头的取值范围：Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain) </li><li>简单请求跨域处理 <ul><li><p>请求发出去前，在请求头中添加一个Origin字段，说明请求来自于哪个源。服务器拿到请求之后，在回应时对应地添加<strong>Access-Control-Allow-Origin</strong>字段，如果Origin不在这个字段范围内，浏览器就会将响应拦截。 </p></li><li><p><strong>Access-Control-Allow-Credentials</strong> 字段 是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器这个字段默认值设为false，如果需要拿到浏览器的Cookie，添加此字段并设置为true，并且在前端也需要设置withCredentials属性：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>Access-Control-Expose-Headers</strong> 这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）还能拿到这个字段生命的响应头字段，例子：</p></li></ul></li></ul><p>前端可以通过XMLHttpRequest.getResponseHeader(‘aaa’)拿到 aaa这个字段的值。 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: aaa<br></code></pre></td></tr></table></figure><p><strong>非简单请求</strong></p><ul><li>除简单请求之外的请求都是非简单请求 </li><li>浏览器以及跨域处理 <ul><li>预检请求和响应字段 <ul><li>发送非简单请求之前要先发送预检请求<br>预检请求的方法是OPTIONS，同时加上Origin源地址和Host目标地址，同时也加上两个关键字段 <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>当前地址<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><ul><li>Access-Control-Request-Method，列出请求用到哪个HTTP方法</li><li>Access-Control-Request-Headers，指定CORS请求将要加上什么请求头</li><li>响应字段 </li><li>预检查的响应</li></ul></li></ul></li></ul></li></ul><p><strong>Access-Control-Allow-Origin</strong>: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。<br><strong>Access-Control-Allow-Methods</strong>: 表示允许的请求方法列表。<br><strong>Access-Control-Allow-Credentials</strong>: 简单请求中已经介绍。<br><strong>Access-Control-Allow-Headers</strong>: 表示允许发送的请求头字段<br><strong>Access-Control-Max-Age</strong>: 预检请求的有效期，在此期间，不用发出另外一条预检请求。<br>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS请求</strong>也不会发出去了。 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br></code></pre></td></tr></table></figure><pre><code class="hljs">     -  CORS的响应         - 现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。</code></pre><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">jsonp</span> = (<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateURL</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;<br>    &#125;<br>    dataStr += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化回调函数名称</span><br>    callbackName = callbackName || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-property">toString</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <br>    <span class="hljs-comment">// 创建 script 元素并加入到当前文档中</span><br>    <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    scriptEle.<span class="hljs-property">src</span> = <span class="hljs-title function_">generateURL</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(scriptEle);<br>    <span class="hljs-comment">// 绑定到 window 上，为了后面调用</span><br>    <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>      <span class="hljs-comment">// script 执行完了，成为无用元素，需要清除</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(scriptEle);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; a, b, callback &#125; = req.<span class="hljs-property">query</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 2</span><br>  <span class="hljs-comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>前端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 拿到数据进行处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 数据包</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>Nginx反向代理<br><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network02.png" alt="image.png"></p><p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p><p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p><p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p><p>解决跨域：</p><p>例子：客户端域名为client.con，服务器域名为server.com</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server &#123;<br>  listen  <span class="hljs-number">80</span>;<br>  server_name  client.<span class="hljs-property">com</span>;<br>  location /api &#123;<br>    proxy_pass server.<span class="hljs-property">com</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手其实就是建立一个TCP连接时，需要客户端和服务器总共发3个包。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>SYN（Synchronize同步的缩写）表示建立连接</p><p>ACK （acknowledge character 确认字符的缩写）表示响应</p><p>具体过程：</p><p>刚开始客户端处于Closed的状态，服务端处于Listen状态。进行三次握手</p><ul><li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND（同步已发送）状态。 <ul><li>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</li></ul></li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的SYN报文作为答应，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN（初始序列号seq）+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD（同步收到）的状态。 <ul><li>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</li></ul></li><li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED（已建立连接）状态。服务器收到ACK报文之后，也处于ESTABLISHED（已建立连接）状态，此时，双方已建立起了连接。 <ul><li>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号</li></ul></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在 socket 编程中，客户端执行 connect() 时，将触发三次握手</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network03.png" alt="image.png"></p><h4 id="半连接队列-x2F-全连接队列"><a href="#半连接队列-x2F-全连接队列" class="headerlink" title="半连接队列&#x2F;全连接队列"></a>半连接队列&#x2F;全连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong></p><p>就是已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ol><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network04.png" alt="image.png"></p><p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p><blockquote><p>LISTEN - 侦听来自远方TCP端口的连接请求；</p></blockquote><blockquote><p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p></blockquote><blockquote><p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p></blockquote><blockquote><p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p></blockquote><blockquote><p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><blockquote><p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p></blockquote><blockquote><p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p></blockquote><blockquote><p>CLOSING -等待远程TCP对连接中断的确认；</p></blockquote><blockquote><p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><blockquote><p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><blockquote><p>CLOSED - 没有任何连接状态；</p></blockquote><h3 id="HTTP-x2F-2的改进"><a href="#HTTP-x2F-2的改进" class="headerlink" title="HTTP&#x2F;2的改进"></a>HTTP&#x2F;2的改进</h3><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>在HTTP&#x2F;1.1及以前的时代，请求头一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，如果请求字段非常复杂的时候，尤其是GET请求，请求报文几乎全是请求头，这个时候优化空间很大，</p><p>而HTTP&#x2F;2针对头部字段，采用了对应的压缩算法-HPACK，对请求头进行压缩。</p><p>HPACK算法的两个亮点</p><ul><li>首先是在服务端和客户端之前建立哈希表，将用到的字段存放在这张表中，那么在传输的时候，对于之前出现过的值，只需要传递索引给对方即可，对方拿到索引查表就可以了</li><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network05.png" alt="image.png"></p><p>HTTP&#x2F;2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><h6 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h6><p>根本原因是HTTP基于<code>请求-响应</code>的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞</p><p>虽然<code>并发连接</code>和<code>域名分片</code>的方式来解决这个问题，但是并没有真正从HTTP本身的层面解决问题，只是增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争 <strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理</p><p>HTTP&#x2F;2从HTTP协议本身解决了<code>队头阻塞</code>问题。这里指的并不是<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code></p><ul><li>TCP队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给HTTP</li><li>HTTP队头阻塞是在HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住</li></ul><p><strong>HTTP&#x2F;2解决队头阻塞</strong></p><ol><li>二进制分帧 <ol><li>首先，HTTP&#x2F;2认为明文传输对机器而言解析太麻烦，因为文本有很多多义性的字符串，比如回车换行到底是内容还是分隔符号，在内部需要用到状态机去识别，效率很低，于是HTTP&#x2F;2把报文全部换成二进制格式，全部传输01串，方便了机器的解析</li><li>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据，分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也不会排队等待，也就没有了HTTP的队头阻塞问题</li><li>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫<code>流(Stream)</code>HTTP&#x2F;2用<code>流</code>来在一个TCP连接上进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念</li><li>乱序首发，乱序是指不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按照顺序传输的，二进制帧到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他的字段，实现了 <strong>优先级</strong>和 <strong>流量控制</strong> 等功能。</li></ol></li></ol><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>在HTTP&#x2F;2中，服务器不再是完全被动地接受请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如：在浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP&#x2F;2完全兼容HTTP的语法和语义</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network06.png" alt="image.png"></p><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>设置请求优先级</li><li>服务器推送</li></ul><h4 id="二进制帧的设计"><a href="#二进制帧的设计" class="headerlink" title="二进制帧的设计"></a>二进制帧的设计</h4><h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><p>HTTP&#x2F;2中传输的帧结构如下图</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network07.png" alt="image.png"></p><p>每个帧分为帧头和帧体。显示三个字节的帧长度，这个长度表示的是帧体的长度。</p><p>然后是帧的类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧存放HTTP报文，控制帧管理<code>流</code>的传输。</p><p>接下来的第一个字节是<strong>帧标志</strong>，这里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束</p><p>后4个字节是Stream ID，也就是流标识符，有了它，接收方就能从乱序的二进制帧中选出 ID 相同的帧，然后按照顺序组装成请求&#x2F;响应报文</p><h5 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h5><p>根据帧的标志位来实现具体的状态改变。</p><p>例子：普通的请求-响应过程</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network08.png" alt="image.png"></p><ul><li>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</li><li>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</li><li>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</li><li>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个</li></ul><h5 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h5><ul><li>并发性，一个HTTP&#x2F;2连接上可以同时发多个帧，这一点和HTTP&#x2F;1不同，这也是实现多路复用的基础</li><li>自增性，流 ID 是不可重用的，会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li><li>双向性，客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</li><li>可以设置优先级，可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/</url>
    
    <content type="html"><![CDATA[<h1 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h1><p><code>Vue</code> 实例化过程，<code>Vue</code> 为一个构造函数，传入的参数是一个对象，可称之为 <code>options</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就是初始化 Vue 工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-comment">// Vue 就是一个构造函数 通过 new 关键字 进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 进行 Vue 初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init 方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载，需要传入 Vue 对象</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure><p>initMixin 把 _init 方法挂载在 Vue 原型 供 Vue 实例调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">import</span> &#123; observe &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./observer/index.js&quot;</span>;<br><span class="hljs-comment">// 初始化状态</span><br><span class="hljs-comment">// 初始化的顺序依次是 prop &gt; methods &gt; data &gt; watch</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-title function_">initProps</span>(vm)  <br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) &#123;<br>    <span class="hljs-title function_">initMethod</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) &#123;<br>    <span class="hljs-title function_">initComputed</span>(vm);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 data 数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 实例的_data熟悉就是传入的data</span><br>  <span class="hljs-comment">// vue 组件的 data 之所以要使用函数，是为了私有化数据，js 只有函数作用域</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span> ? data.<span class="hljs-title function_">call</span>(vm) : data || &#123;&#125;;<br>  <br>  <span class="hljs-comment">// 把 data 数据代理到 vm 也就是 Vue实例上面 我们可以使用this.a 来访问 this._data.a</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>  &#125;<br>  <span class="hljs-comment">// 对数据进行观测 -- 响应式数据核心</span><br>  <span class="hljs-title function_">observe</span>(data);<br>&#125;<br><span class="hljs-comment">// 数据代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">object, sourceKey, key</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(object, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> object[sourceKey][key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      object[sourceKey][key] = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的数据劫持"><a href="#对象的数据劫持" class="headerlink" title="对象的数据劫持"></a>对象的数据劫持</h1><p>defineReactive 函数 主要使用<code>Object.defineProperty</code>来对数据 get 和 set 进行劫持 这里知道了为啥数据变动了会自动更新视图 -&gt; 可以在 set 里面去通知视图更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 对象上所有的属性依次进行观测</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> key = keys[i];<br>      <span class="hljs-keyword">let</span> value = data[key];<br>      <span class="hljs-title function_">defineReactive</span>(data, key, value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Object.defineProperty 数据劫持核心 兼容性在 ie9 及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, keym value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归</span><br>  <span class="hljs-comment">// 如果 value 还是对象就递归，直到 value 不是对象为止</span><br>  <span class="hljs-comment">// 如果 Vue 数据嵌套层级过深 会有性能影响</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取值&#x27;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置值&#x27;</span>);<br>      value = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 如果传过来的是对象或者数组，进行属性劫持</span><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ||<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的观测"><a href="#数组的观测" class="headerlink" title="数组的观测"></a>数组的观测</h1><p>数组元素过多，使用递归根据下标直接修改数据太消耗性能了，不可能为每个元素下标都添加 get 和 set 方法。<br />所以通过重写数组原型方法来对数组的七种方法进行拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>     <span class="hljs-comment">// 通过重写数组原型方法来对数组的七种方法进行拦截</span><br>     value.<span class="hljs-property">__proto__</span> = arrayMethods;<br>     <span class="hljs-comment">// 如果数组里面还包含数组 需要递归判断</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>   &#125;<br> &#125;<br>  <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">observe</span>(items[i])  <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这段代码给每个响应式数据增加了一个不可枚举的__ob__属性 并且指向了 Observer 实例 那么我们首先可以根据这个属性来防止已经被响应式观察的数据反复被观测 其次 响应式数据可以使用__ob__来获取 Observer 实例的相关方法 这对数组很关键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, &#123;<br>      <span class="hljs-comment">// 值指 Observer 的实例</span><br>      <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,<br>      <span class="hljs-comment">// 不可枚举</span><br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/array.js</span><br><span class="hljs-comment">// 先保留数据原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 然后将 arrayMethods 继承自数组原型</span><br><span class="hljs-comment">// 这里是面向切片编程思想（AOP）：不破坏封装的前提下，动态扩展功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-keyword">let</span> methodsToPath = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>];<br>methodsToPath.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-comment">// 这里的标志就是代表数组有新增操作</span><br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<br>    <span class="hljs-comment">// 在这里就可以检测到数据变化了</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p><code>**Object.defineProperty(obj, prop, descriptor)**</code>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><ul><li>obj：要定义属性的对象</li><li>prop：要定义或修改的 属性名称 或 Symbol</li><li>descriptor：要定义或修改的 属性描述符</li></ul><h3 id="本身的限制"><a href="#本身的限制" class="headerlink" title="本身的限制"></a>本身的限制</h3><ul><li>目标只是对象的属性，而不是整个对象</li><li>一次只能 定义或者修改一个属性</li></ul><h3 id="在-Vue2-中的缺陷"><a href="#在-Vue2-中的缺陷" class="headerlink" title="在 Vue2 中的缺陷"></a>在 Vue2 中的缺陷</h3><ul><li>只能拦截对象属性的<code>get</code>和<code>set</code>操作，比如无法拦截<code>delete</code>、<code>in</code>、<code>方法调用</code>等操作</li><li>动态添加新属性（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新属性</li></ul></li><li>通过<code>delete</code>删除属性（响应式丢失）<ul><li>使用<code>this.$delete()</code>删除属性</li></ul></li><li>使用数组索引 <code>替换/新增</code>元素（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新元素</li></ul></li><li>使用数组<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>等原生方法改变原数组时（响应式丢失）<ul><li>使用重写后<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>方法</li></ul></li><li>一次只能对一个属性实现 数据劫持，需要遍历对所有属性进行劫持</li><li>数据结构复杂时（属性值为 引用类型数据），需要通过 递归 进行处理</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>**Proxy**</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><code>new Proxy(target, handler)</code>针对整个对象进行代理</li><li>代理对象的属性拥有读取、修改、删除、新增、是否存在属性，等相应的捕捉器<ul><li><code>get()</code>：<code>读取</code>操作的捕捉器</li><li><code>get()</code>：<code>设置</code>操作的捕捉器</li><li><code>deleteProperty()</code>：<code>删除</code>操作的捕捉器</li><li><code>ownKeys()</code>：<code>Object.getOwnPropertyNames</code>方法和<code>Object.getOwnPropertySymbols</code>方法的捕捉器</li><li><code>has()</code>：<code>in</code>操作符的捕捉器</li></ul></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>**Reflect**</code>是一个内置的对象，它提供拦截 <code>**JavaScript**</code> 操作的方法，这些方法与 <code>Proxy handlers</code> 提供的的方法是一一对应的，且 <code>**Reflect**</code> 不是一个函数对象，即不能进行实例化，其所有属性和方法都是静态的（就像是<code>Math</code>对象）。</p><ul><li><code>Reflect.get(target, propertyKey[, receiver]) </code>获取对象身上某个属性的值，类似于 <code>target[name]</code></li><li><code>Reflect.set(target, propertyKey, value[, receiver]) </code>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code></li><li><code>Reflect.deleteProperty(target, propertyKey) </code>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code></li><li><code>Reflect.ownKeys(target) </code>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code> 影响)</li><li><code>Reflect.has(target, propertyKey) </code>判断一个对象是否存在某个属性，和<code>in</code>运算符 的功能完全相同</li></ul><h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span></span>) &#123;<br><span class="hljs-comment">// 若目标对象是响应式的只读对象，则直接返回</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isReadonly</span>(target)) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 否则将目标数据尝试变成响应式数据</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createdReactiveObject</span>(<br>    target,<br>    <span class="hljs-literal">false</span>,<br>    mutableHandlers, <span class="hljs-comment">// 对象类型的 handlers</span><br>    mutableCollectionHandlers, <span class="hljs-comment">// 集合类型的 handlers</span><br>    reacitveMap<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject()"></a>createReactiveObject()</h3><p>主要是做前置处理</p><ul><li>目标数据为 原始值类型，返回 原数据</li><li>目标数据的<code>__v_raw</code>属性为<code>true</code>，且是非响应式数据，或 不是通过调用<code>readonly()</code>方法，则直接返回原数据</li><li>目标数据已存在相应的<code>proxy</code>代理对象，则直接返回代理对象</li><li>目标数据不存在对应的 白名单数据类型中，则直接返回原数据，支持响应式的数据类型如下<ul><li>可扩展的对象（是否可以先加新属性）</li><li><code>__v_skip</code>属性不存在或者值为 false 的对象</li><li>数据类型为<code>Object</code>，<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>WeakMap</code>，<code>WeakSet</code>的对象</li><li>其他数据都统一被认为是无效的响应式数据对象</li></ul></li><li>通过<code>Proxy</code>创建代理对象，根据目标数据类型选择不同的<code>Proxy handlers</code>（捕获器）</li></ul><p>具体的实现在对应数据类型的 捕获器 中，即下面源码中的<code>collectionHandlers</code>和<code>baseHandlers</code>，而它们则对应的是上述<code>reactive()</code>函数中的<code>createReactiveObject()</code>函数传递的<code>mutableCollectionHandlers</code>和<code>mutableHandlers</code>参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: Target,</span><br><span class="hljs-params">  isReadonly: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  baseHanlders: ProxyHandle&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  collectionHandlers: ProxyHandler&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  proxyMap: <span class="hljs-built_in">WeakMap</span>&lt;Target, <span class="hljs-built_in">any</span>&gt;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 非对象类型直接返回</span><br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>    <span class="hljs-keyword">if</span>(__DEV__) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`value cannot be made reactive: <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(target)&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 目标数据的 __v_raw 属性若为 true，且是【非响应式数据】或 不是通过调用 readonly() 方法，则直接返回</span><br>  <span class="hljs-keyword">if</span> (<br>    target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span>] &amp;&amp;<br>    !(isReadonly &amp;&amp; target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>])<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br><br>  <span class="hljs-comment">// 目标对象已存在相应的 proxy 代理对象，则直接返回</span><br>  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>    <span class="hljs-keyword">return</span> existingProxy<br>  &#125;<br>  <br><span class="hljs-comment">// 只有在白名单中的值类型才可以被代理监测，否则直接返回</span><br>  <span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)<br>  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>) &#123;<br>    <span class="hljs-keyword">return</span> target     <br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建代理对象</span><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<br>    target,<br>    <span class="hljs-comment">// 若目标对象是集合类型（Set、Map）则使用集合类型对应的捕获器，否则使用基础捕获器</span><br>    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers <br>  )<br><br>  <span class="hljs-comment">// 将对应的代理对象存储在 proxyMap 中</span><br>  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捕获器-Handles"><a href="#捕获器-Handles" class="headerlink" title="捕获器 Handles"></a>捕获器 Handles</h3><h4 id="对象类型（Object类型不包括Array）的捕获器-mutableHandlers"><a href="#对象类型（Object类型不包括Array）的捕获器-mutableHandlers" class="headerlink" title="对象类型（Object类型不包括Array）的捕获器 mutableHandlers"></a>对象类型（Object类型不包括Array）的捕获器 <code>mutableHandlers</code></h4><p><code>baseHandles.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">mutableHandlers</span>: <span class="hljs-title class_">ProxyHandle</span>&lt;<span class="hljs-built_in">object</span>&gt; = &#123;<br>  get,<br>  set,<br>  deleteProperty,<br>  has,<br>  ownKeys,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get-捕获器"><a href="#get-捕获器" class="headerlink" title="get 捕获器"></a>get 捕获器</h5><ul><li>当前数据对象为 数组，重写 数组对应方法</li><li>当前数据对象为普通对象，且非 只读 的则通过<code>track(target, TrackOptypes.GET, key)</code>进行依赖收集<ul><li>当前数据对象为浅层响应，直接返回其对应的属性值</li><li>当前数据对象为 ref 类型，自动脱 ref</li></ul></li><li>当前数据对象属性值是对象类型<ul><li>当前数据对象为 只读的，则通过 <code>readonly(res)</code>向外返回其结果</li><li>否则将当前属性值以<code>reactive(res)</code>向外返回 proxy 代理对象</li></ul></li><li>否则直接向外返回对应的 属性值 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span>, shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target: Target, key: <span class="hljs-built_in">string</span> | sysbol, receiver: <span class="hljs-built_in">object</span></span>) &#123;<br>    <span class="hljs-comment">// 当直接通过指定 key 访问 vue 内置自定义的对象属性时，返回其对应的值</span><br>    <span class="hljs-keyword">if</span>(key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) &#123;<br>      <span class="hljs-keyword">return</span> !isReadonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_READONLY</span>) &#123;<br>      <span class="hljs-keyword">return</span> isRedaonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFLags</span>.<span class="hljs-property">IS_SHALLOW</span>) &#123;<br>      <span class="hljs-keyword">return</span> shallow<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span> &amp;&amp;<br>      receiver ===<br>        (<br>          isReadonly<br>            ? shallow<br>              ? shallowReadonlyMap<br>              : readonlyMap<br>            : shallow<br>            ? shallowReactiveMap<br>            : reactiveMap<br>        ).<span class="hljs-title function_">get</span>(target)<br>    ) &#123;<br>      <span class="hljs-keyword">return</span> target<br>    &#125;<br>     <span class="hljs-comment">// 判断是否为数组类型</span><br>    <span class="hljs-keyword">const</span> targetIsArray = <span class="hljs-title function_">isArray</span>(target)<br><br>    <span class="hljs-comment">// 数组对象</span><br>    <span class="hljs-keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="hljs-title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;<br>      <span class="hljs-comment">// 重写/增强数组的方法： </span><br>      <span class="hljs-comment">//  - 查找方法：includes、indexOf、lastIndexOf</span><br>      <span class="hljs-comment">//  - 修改原数组的方法：push、pop、unshift、shift、splice</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)<br>    &#125;<br>    <span class="hljs-comment">// 获取对应属性值</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSymbol</span>(key) ? builtInSymbols.<span class="hljs-title function_">has</span>(key) : <span class="hljs-title function_">isNonTrackableKeys</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// 依赖收集</span><br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 浅层响应</span><br>    <span class="hljs-keyword">if</span> (shallow) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 若是 ref 类型响应式数据，会进行【自动脱 ref】，但不支持【数组】+【索引】的访问方式</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(res)) &#123;<br>      <span class="hljs-keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="hljs-title function_">isIntegerKey</span>(key)<br>      <span class="hljs-keyword">return</span> shouldUnwrap ? res.<span class="hljs-property">value</span> : res<br>    &#125;<br>    <span class="hljs-comment">// 属性值是对象类型：</span><br>    <span class="hljs-comment">//  - 是只读属性，则通过 readonly() 返回结果，</span><br>    <span class="hljs-comment">//  - 且是非只读属性，则递归调用 reactive 向外返回 proxy 代理对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(res)) &#123;<br>      <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="set捕获器"><a href="#set捕获器" class="headerlink" title="set捕获器"></a><code>set</code>捕获器</h5><p>边界值处理，以及<strong>更新属性值，并通过</strong><code>**targger()**</code>触发依赖更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span><br><span class="hljs-params">    value: <span class="hljs-built_in">unknown</span>,</span><br><span class="hljs-params">    receiver: <span class="hljs-built_in">object</span></span><br><span class="hljs-params">  </span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-comment">// 保存旧的数据</span><br>    <span class="hljs-keyword">let</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br><br>    <span class="hljs-comment">// 若原数据值属于 只读 且 ref 类型，并且新数据值不属于 ref 类型，则意味着修改失败</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!shallow &amp;&amp; !<span class="hljs-title function_">isReadonly</span>(value)) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isShallow</span>(value)) &#123;<br>        value = <span class="hljs-title function_">toRaw</span>(value)<br>        oldValue = <span class="hljs-title function_">toRaw</span>(oldValue)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>        oldValue.<span class="hljs-property">value</span> = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// in shallow mode, objects are set as-is regardless of reactive or not</span><br>    &#125;<br><br>    <span class="hljs-comment">// 是否存在对应的 key</span><br>    <span class="hljs-keyword">const</span> hadKey =<br>      <span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isIntegerKey</span>(key)<br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span><br>        : <span class="hljs-title function_">hasOwn</span>(target, key)<br><br>    <span class="hljs-comment">// 设置对应值</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br><br>    <span class="hljs-comment">// 若目标对象是原始原型链上的内容（非自定义添加），则不触发依赖更新</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-title function_">toRaw</span>(receiver)) &#123;<br>      <span class="hljs-keyword">if</span> (!hadKey) &#123;<br>        <span class="hljs-comment">// 目标对象不存在对应的 key，则为新增操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>, key, value)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(value, oldValue)) &#123;<br>        <span class="hljs-comment">// 目标对象存在对应的值，则为修改操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>, key, value, oldValue)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回修改结果</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="deleteProperty-amp-has-amp-ownKeys-捕获器"><a href="#deleteProperty-amp-has-amp-ownKeys-捕获器" class="headerlink" title="deleteProperty &amp; has &amp; ownKeys 捕获器"></a><code>deleteProperty</code> &amp; <code>has</code> &amp; <code>ownKeys</code> 捕获器</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> hadKty = <span class="hljs-title function_">hasOwn</span>(target, key)<br>  <span class="hljs-keyword">const</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>  <span class="hljs-comment">// 目标对象存在对应的 key，并且成功删除，才会触发依赖更新</span><br>  <span class="hljs-keyword">if</span> (result &amp;&amp; hadKey) &#123;<br>    <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">DELETE</span>, key, <span class="hljs-literal">undefined</span>, oldValue)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">has</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key)<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSymbol</span>(key) || !builtInSymbols.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">HAS</span>, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span></span>): (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>)[] &#123;<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">ITERATE</span>, <span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">&#x27;length&#x27;</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">REflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="数组类型捕获器-arrayInstrumentations"><a href="#数组类型捕获器-arrayInstrumentations" class="headerlink" title="数组类型捕获器 arrayInstrumentations"></a>数组类型捕获器 <code>arrayInstrumentations</code></h5><p>数组由于<code>index</code>和<code>length</code>会相互影响，所以需要特殊处理</p><ul><li><code>arr[1] = 2</code>会隐式修改<code>length</code>的属性值</li><li><code>arr.lenght = 0</code>会导致原索引位置的值发生变更</li></ul><p>为了能够合理触发和 <code>length</code> 相关副作用函数的执行，在 <code>set()</code> 捕获器中会判断当前操作的类型：</p><ul><li>当<code>Number(key) &lt; target.length</code>证明是修改操作，对应<code>TriggerOptypes.SET</code>类型，即当前操作不会改变<code>length</code>的值，不需要 触发和 <code>length</code>有关副作用函数的执行</li><li>当<code>Number(key) &gt;= target.length</code>证明是新增操作，<code>TriggerOpTypes.ADD</code>类型，即当前操作会改变<code>length</code>的值，需要触发和<code>length</code>相关副作用函数的执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误页面处理</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="error-vue"><a href="#error-vue" class="headerlink" title="error.vue"></a>error.vue</h1><p><code>error.vue</code>必须与项目入口文件<code>app.vue</code>在同级别目录下<br><code>error.vue</code>接受了一个<code>error</code>的<code>props</code></p><h2 id="定制处理"><a href="#定制处理" class="headerlink" title="定制处理"></a>定制处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ErrorPage<br>  :errCode=&quot;error.statusCode&quot;<br>  &gt;<br>  &lt;/ErrorPage&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br><br>const props = defineProps(&#123;<br>  error: Object<br>&#125;)<br>if(props.error.statusCode === 500 &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123;<br>  // 此处可以记录错误日志<br>  useRecordErrorLog(props.error)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>ErrorPage</code>组件为根据错误码定制的页面</p><h2 id="错误日志收集"><a href="#错误日志收集" class="headerlink" title="错误日志收集"></a>错误日志收集</h2><p>存储到项目根目录下的<code>logs/error.log</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> winston <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;winston&#x27;</span>;<br><br><span class="hljs-keyword">const</span> logger = winston.<span class="hljs-title function_">createLogger</span>(&#123;<br>  <span class="hljs-attr">transports</span>: [<br>    <span class="hljs-keyword">new</span> winston.<span class="hljs-property">transports</span>.<span class="hljs-title class_">File</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;logs/error.log&#x27;</span>,<br>      <span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">format</span>: winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">combine</span>(<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">timestamp</span>(&#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;YYYY-MM-DDTHH:mm:ss.SSSZ&#x27;</span> &#125;),<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">json</span>(),<br>      )<br>    &#125;)<br>  ]<br>&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRecordErrorLog</span> = (<span class="hljs-params">error</span>) =&gt; &#123;<br>  logger.<span class="hljs-title function_">error</span>(error)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useRecordErrorLog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航栏锚点</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="导航栏部分"><a href="#导航栏部分" class="headerlink" title="导航栏部分"></a>导航栏部分</h1><ol><li>利用<code>NuxtLink</code>组件实现跳转<ol><li>注意，如果要跳转到其他项目的地址，此时要给<code>link</code>前面拼接上<code>window.location.origin</code></li></ol></li><li><code>link</code>后添加上对应页面，对应锚点的<code>id</code>，此处可以用<code>#targetID</code>这种形式拼接</li></ol><h2 id="对应页面"><a href="#对应页面" class="headerlink" title="对应页面"></a>对应页面</h2><ol><li>每个锚点添加上<code>id=&quot;xxx&quot;</code></li><li>使用<code>useAnchor()</code></li></ol><h1 id="useAnchor实现"><a href="#useAnchor实现" class="headerlink" title="useAnchor实现"></a>useAnchor实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> targetId = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> targetElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(targetId);<br>    <span class="hljs-keyword">if</span> (targetElement) &#123;<br>      targetElement.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onMounted</span>(scrollToAnchor);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useAnchor;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加百度统计代码</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="设置单页面模式"><a href="#设置单页面模式" class="headerlink" title="设置单页面模式"></a>设置单页面模式</h1><ol><li>首先去百度统计PC端首页-&gt;使用规则-&gt;单页设置-&gt;启用单页应用数据统计</li><li>在项目入口文件<code>app.vue</code>引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-title function_">useHead</span>(&#123;<br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span><br>    &#125;<br>  ]<br>&#125;)<br><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (_hmt) &#123;<br>    _hmt.<span class="hljs-title function_">push</span>([<span class="hljs-string">&#x27;_trackPageview&#x27;</span>, route.<span class="hljs-property">path</span>])<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="不设置单页模式"><a href="#不设置单页模式" class="headerlink" title="不设置单页模式"></a>不设置单页模式</h2><ol><li>对应的每个页面引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useHead</span>(&#123;<br><br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span>,<br>      <span class="hljs-attr">bodyClose</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// false 添加到 head标签内</span><br>      <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">defer</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  ]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/02.HTTPS/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/02.HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong><br><strong>HTTP 明文传输，不安全</strong><br><strong>利用 HTTP 传输数据，利用 SSL&#x2F;TLS 加密数据包</strong></p><h2 id="密码学概念"><a href="#密码学概念" class="headerlink" title="密码学概念"></a>密码学概念</h2><p><strong>明文</strong>：明文指的是未被加密过的原始数据。<br><strong>密文</strong>：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。<br><strong>密钥</strong>：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><p><strong>对称加密（私钥加密）：</strong> 信息的发送方和接收方使用同一个密钥去加密和解密数据。<br>其加密过程如下：<strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文</strong><br>解密过程如下： <strong>密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong><br><strong>优点：</strong>加密和解密速度快，适合于对大数据量进行加密 。<br><strong>缺点：</strong>算法公开， 一旦私钥被泄露，那么密文就很容易被破解  ，密钥安全管理困难  </p><p><strong>非对称加密（公钥加密）：</strong>使用一对密钥（公钥和私钥），服务端保存私钥，客户端保存公钥。私钥不能对外泄漏。公钥任何客户端都可以获取到，用公钥或者私钥中的任何一个进行加密，用另一个进行解密。<br>被公钥加密过的密文只能被私钥解密，过程如下：<br><strong>明文 + 加密算法 + 公钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong><br>被私钥加密过的密文只能被公钥解密，过程如下：<br><strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 公钥 &#x3D;&gt; 明文</strong><br><strong>优点：</strong>安全性高（得不到私钥就无法解密）<br><strong>缺点：</strong>算法公开，加密和解密花费时间长、速度慢，只适合对少量数据进行加密。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><strong>SSL</strong>（Secure Sockets Layer）安全套接层和** TLS<strong>（Transport Layer Security）传输层安全协议其实是</strong>一套东西<strong>。</strong>HTTPS** 需要使用一套 <strong>CA 数字证书，</strong>证书附带了一个<strong>公钥Pub，</strong>与之对应的**私钥 Private **保留在服务端不公开。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>用户在浏览器发起 HTTPS 请求，默认使用服务端的443端口进行连接</li><li>服务端收到请求，返回配置好的包含<strong>公钥Pub的</strong>数字证书返回给客户端</li><li>客户端收到<strong>证书，</strong>校验合法性，主要是：是否在有效期内、证书的域名与请求的域名是否匹配， 上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；  </li><li>客户端生成一个用于对称加密的<strong>随机key</strong>，并用证书内的<strong>公钥Pub</strong>进行非对称加密，发送给服务端</li><li>服务端收到<strong>随机key</strong>的密文，使用与<strong>公钥Pub</strong>配对的<strong>私钥Private</strong>进行解密，得到<strong>随机key</strong>的明文</li><li>服务端使用客户端发送过来的<strong>随机key</strong>对要传输的HTTP数据进行对称加密（加密的私钥就是这个<strong>随机key</strong>），将密文返回给客户端</li><li>客户端使用<strong>随机key</strong>对称解密密文，得到HTTP数据明文</li><li>后续HTTPS请求使用之前交换好的<strong>随机Key</strong>进行对称加解密。</li></ol><h1 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h1><h2 id="HTTPS-中间人攻击"><a href="#HTTPS-中间人攻击" class="headerlink" title="HTTPS 中间人攻击"></a>HTTPS 中间人攻击</h2><p>由于非对称加密的算法都是<strong>公开</strong>的，所有人都可以自己生成一对公钥私钥。<br>例子：<br>当服务端向客户端返回公钥 A1 的时候，<strong>中间人截获</strong>公钥 A1 将其<strong>替换</strong>成自己的公钥 B1 传送给浏览器。<br>此时浏览器拿到的是中间人的公钥 B1 加密了密钥 K 发送给服务端，<strong>再次被中间人截获，</strong>中间人利用自己的私钥 B2 解密，得到密钥 K 在使用之前截获到的公钥 A1 加密传送给服务端，完成了通信，而且服务端和客服的没有任何感知。<br>出现中间人攻击的核心原因就是：<strong>客户端无法确认收到的公钥是不是真的是服务端发来的</strong>。  </p><h2 id="CA-颁发机构"><a href="#CA-颁发机构" class="headerlink" title="CA 颁发机构"></a>CA 颁发机构</h2><p>数字证书颁发（CA）机构是受信任的第三方机构，颁发的数字证书为最终用户数据加密的公共密钥。在这个过程中，CA的责任是确保公司或用户接收一个唯一的证书是一个有效的身份的认证  。<br>（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）  </p><p>服务端在使用 HTTPS 前，去经过认证的 CA 机构申请颁发一份 <strong>数字证书，</strong>数字证书里面包含：证书持有者、证书有效期、公钥等明文信息和<strong>数字签名</strong>，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致以及数字签名一致后再进行后续的加密操作。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>防伪技术，验证数字证书是否被修改过<br>数字签名过程：</p><ul><li>CA机构在颁发证书时对证书明文信息进行<strong>哈希运算</strong>得到<strong>摘要</strong></li><li>将<strong>摘要</strong>用私钥进行<strong>加签（加密），</strong>得到<strong>数字签名</strong></li></ul><h3 id="校验数字证书"><a href="#校验数字证书" class="headerlink" title="校验数字证书"></a>校验数字证书</h3><ul><li>客户端得到证书（明文信息和数字签名）， 用浏览器内置的 CA 机构的根证书校验证书有效性 ，有效才进行下一步</li><li>客户端对证书的明文信息进行<strong>哈希运算</strong>得到<strong>摘要1</strong></li><li>用公钥（<strong>内置的CA机构的公钥</strong>）进行<strong>解签（解密）</strong>，得到<strong>摘要2</strong>（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书（根证书）和公钥信息）</li><li>用证书里声明的哈希算法对明文Text部分进行哈希得到T</li><li>当自己计算得到的哈希值<strong>摘要1</strong>与解密服务端的数字签名得到的哈希值<strong>摘要2，相等</strong>，表示证书可信，<strong>没有被篡改，否则被篡改。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="更新动态列"><a href="#更新动态列" class="headerlink" title="更新动态列"></a>更新动态列</h1><p>在Vue2中使用vxetable组件时，如果不调用clearSort方法而直接修改columns，可能会出现渲染问题。这是因为vxetable组件内部维护了一个状态，用于记录表格的排序状态，当columns发生变化时，如果不正确地更新这个状态，就会导致渲染问题的出现。<br>调用clearSort方法的作用是清除表格的排序状态，这样在更新columns后，vxetable组件会重新根据新的columns进行排序，从而避免渲染问题的出现。<br>具体地，如果不调用clearSort方法，可能会出现以下两种情况：</p><ol><li>表格数据显示不正确：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致表格数据显示不正确，这是因为vxetable组件仍然保留着原来的排序状态，导致新的columns无法正确应用到表格数据上。</li><li>列表头显示异常：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致列表头显示异常，这是因为vxetable组件内部维护的排序状态没有正确更新，导致列表头的渲染出现问题。</li></ol><p>因此，在修改columns时，建议先调用clearSort方法清除排序状态，再进行列属性的更新。这样可以避免渲染问题的出现，确保vxetable组件能够正确地更新和显示数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInViewAnimate</span> = (<span class="hljs-params">el, binding</span>) =&gt; &#123;<br>  <span class="hljs-comment">// check if browser supports IntersectionObserver API</span><br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;IntersectionObserver&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) &#123;<br>    <span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInView</span>(el)) &#123;<br>        el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>        timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// use IntersectionObserver for supported browser</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">[entry]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;<br>      el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>    &#125;<br>  &#125;, &#123;<br>    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span><br>  &#125;);<br>  observer.<span class="hljs-title function_">observe</span>(el);<br><br>  <span class="hljs-comment">// clean up</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    observer.<span class="hljs-title function_">disconnect</span>();<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>      observer.<span class="hljs-title function_">disconnect</span>();<br>    &#125;,<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isInView</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> rect = el.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span> &gt; <span class="hljs-number">100</span>;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">111</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">// render(h) &#123;</span><br>  <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span><br>  <span class="hljs-comment">// &#125;,</span><br>  <span class="hljs-comment">// template:`&lt;div id=&quot;a&quot;&gt;hello&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="模板编译入口"><a href="#模板编译入口" class="headerlink" title="模板编译入口"></a>模板编译入口</h1><p>传入的 el 或者 template 选项最后都会被解析成 render 函数 这样才能保持模板解析的一致性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-keyword">import</span> &#123; initState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./state&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; compileToFunctions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./compiler/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 这里的this代表调用_init方法的对象(实例对象)</span><br>    <span class="hljs-comment">//  this.$options就是用户new Vue的时候传入的属性</span><br>    vm.<span class="hljs-property">$options</span> = options;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-title function_">initState</span>(vm);<br><br>    <span class="hljs-comment">// 如果有el属性 进行模板渲染</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 这块代码在源码里面的位置其实是放在entry-runtime-with-compiler.js里面</span><br>  <span class="hljs-comment">// 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br><br>    <span class="hljs-comment">// 如果不存在render属性</span><br>    <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>      <span class="hljs-comment">// 如果存在template属性</span><br>      <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br><br>      <span class="hljs-keyword">if</span> (!template &amp;&amp; el) &#123;<br>        <span class="hljs-comment">// 如果不存在render和template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>        template = el.<span class="hljs-property">outerHTML</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>      <span class="hljs-keyword">if</span> (template) &#123;<br>        <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>        options.<span class="hljs-property">render</span> = render;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br>  <br><br></code></pre></td></tr></table></figure><h1 id="模板转化核心方法-compileToFunctions"><a href="#模板转化核心方法-compileToFunctions" class="headerlink" title="模板转化核心方法 compileToFunctions"></a>模板转化核心方法 compileToFunctions</h1><p> 1.生成 ast 2.优化静态节点 3.根据 ast 生成 render 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/index.js</span><br><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./parse&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./codegen&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-comment">// 把html字符串变成render函数</span><br>  <span class="hljs-comment">// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br>  <span class="hljs-comment">// 很多库都运用到了ast 比如 webpack babel eslint等等</span><br>  <span class="hljs-keyword">let</span> ast = <span class="hljs-title function_">parse</span>(template);<br>  <span class="hljs-comment">// 2.优化静态节点</span><br>  <span class="hljs-comment">//   if (options.optimize !== false) &#123;</span><br>  <span class="hljs-comment">//     optimize(ast, options);</span><br>  <span class="hljs-comment">//   &#125;</span><br><br>  <span class="hljs-comment">// 3.通过ast 重新生成代码</span><br>  <span class="hljs-comment">// 最后生成的代码需要和render函数一样</span><br>  <span class="hljs-comment">// 类似_c(&#x27;div&#x27;,&#123;id:&quot;app&quot;&#125;,_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br>  <span class="hljs-comment">// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解析-html-并生成-ast"><a href="#解析-html-并生成-ast" class="headerlink" title="解析 html 并生成 ast"></a>解析 html 并生成 ast</h1><p>利用正则 匹配 html 字符串 遇到开始标签 结束标签和文本 解析完毕之后生成对应的 ast 并建立相应的父子关联 不断的 advance 截取剩余的字符串 直到 html 全部解析完毕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/parse.js</span><br><br><span class="hljs-comment">// 以下为源码的正则  对正则表达式不清楚的同学可以参考小编之前写的文章(前端进阶高薪必看 - 正则篇);</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; <span class="hljs-comment">//匹配标签名 形如 abc-123</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span>; <span class="hljs-comment">//匹配特殊标签 形如 abc:234 前面的abc:可有可无</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="hljs-comment">// 匹配标签开始 形如 &lt;abc-123 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span>; <span class="hljs-comment">// 匹配标签结束  &gt;</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="hljs-comment">// 匹配标签结尾 如 &lt;/abc-123&gt; 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="hljs-comment">// 匹配属性  形如 id=&quot;app&quot;</span><br><br><span class="hljs-keyword">let</span> root, currentParent; <span class="hljs-comment">//代表根节点 和当前父节点</span><br><span class="hljs-comment">// 栈结构 来表示开始和结束标签</span><br><span class="hljs-keyword">let</span> stack = [];<br><span class="hljs-comment">// 标识元素和文本type</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ELEMENT_TYPE</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 生成ast方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createASTElement</span>(<span class="hljs-params">tagName, attrs</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tag</span>: tagName,<br>    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ELEMENT_TYPE</span>,<br>    <span class="hljs-attr">children</span>: [],<br>    attrs,<br>    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 对开始标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStartTag</span>(<span class="hljs-params">&#123; tagName, attrs &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> element = <span class="hljs-title function_">createASTElement</span>(tagName, attrs);<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    root = element;<br>  &#125;<br>  currentParent = element;<br>  stack.<span class="hljs-title function_">push</span>(element);<br>&#125;<br><br><span class="hljs-comment">// 对结束标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEndTag</span>(<span class="hljs-params">tagName</span>) &#123;<br>  <span class="hljs-comment">// 栈结构 []</span><br>  <span class="hljs-comment">// 比如 &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 当遇到第一个结束标签&lt;/span&gt;时 会匹配到栈顶&lt;span&gt;元素对应的ast 并取出来</span><br>  <span class="hljs-keyword">let</span> element = stack.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-comment">// 当前父元素就是栈顶的上一个元素 在这里就类似div</span><br>  currentParent = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  <span class="hljs-comment">// 建立parent和children关系</span><br>  <span class="hljs-keyword">if</span> (currentParent) &#123;<br>    element.<span class="hljs-property">parent</span> = currentParent;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对文本进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChars</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-comment">// 去掉空格</span><br>  text = text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (text) &#123;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TEXT_TYPE</span>,<br>      text,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析标签生成ast核心</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>) &#123;<br>  <span class="hljs-keyword">while</span> (html) &#123;<br>    <span class="hljs-comment">// 查找&lt;</span><br>    <span class="hljs-keyword">let</span> textEnd = html.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>    <span class="hljs-comment">// 如果&lt;在第一个 那么证明接下来就是一个标签 不管是开始还是结束标签</span><br>    <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果开始标签解析有结果</span><br>      <span class="hljs-keyword">const</span> startTagMatch = <span class="hljs-title function_">parseStartTag</span>();<br>      <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br>        <span class="hljs-comment">// 把解析好的标签名和属性解析生成ast</span><br>        <span class="hljs-title function_">handleStartTag</span>(startTagMatch);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 匹配结束标签&lt;/</span><br>      <span class="hljs-keyword">const</span> endTagMatch = html.<span class="hljs-title function_">match</span>(endTag);<br>      <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>        <span class="hljs-title function_">advance</span>(endTagMatch[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        <span class="hljs-title function_">handleEndTag</span>(endTagMatch[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> text;<br>    <span class="hljs-comment">// 形如 hello&lt;div&gt;&lt;/div&gt;</span><br>    <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 获取文本</span><br>      text = html.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, textEnd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (text) &#123;<br>      <span class="hljs-title function_">advance</span>(text.<span class="hljs-property">length</span>);<br>      <span class="hljs-title function_">handleChars</span>(text);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 匹配开始标签</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseStartTag</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = html.<span class="hljs-title function_">match</span>(startTagOpen);<br><br>    <span class="hljs-keyword">if</span> (start) &#123;<br>      <span class="hljs-keyword">const</span> match = &#123;<br>        <span class="hljs-attr">tagName</span>: start[<span class="hljs-number">1</span>],<br>        <span class="hljs-attr">attrs</span>: [],<br>      &#125;;<br>      <span class="hljs-comment">//匹配到了开始标签 就截取掉</span><br>      <span class="hljs-title function_">advance</span>(start[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br><br>      <span class="hljs-comment">// 开始匹配属性</span><br>      <span class="hljs-comment">// end代表结束符号&gt;  如果不是匹配到了结束标签</span><br>      <span class="hljs-comment">// attr 表示匹配的属性</span><br>      <span class="hljs-keyword">let</span> end, attr;<br>      <span class="hljs-keyword">while</span> (<br>        !(end = html.<span class="hljs-title function_">match</span>(startTagClose)) &amp;&amp;<br>        (attr = html.<span class="hljs-title function_">match</span>(attribute))<br>      ) &#123;<br>        <span class="hljs-title function_">advance</span>(attr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        attr = &#123;<br>          <span class="hljs-attr">name</span>: attr[<span class="hljs-number">1</span>],<br>          <span class="hljs-attr">value</span>: attr[<span class="hljs-number">3</span>] || attr[<span class="hljs-number">4</span>] || attr[<span class="hljs-number">5</span>], <span class="hljs-comment">//这里是因为正则捕获支持双引号 单引号 和无引号的属性值</span><br>        &#125;;<br>        match.<span class="hljs-property">attrs</span>.<span class="hljs-title function_">push</span>(attr);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (end) &#123;<br>        <span class="hljs-comment">//   代表一个标签匹配到结束的&gt;了 代表开始标签解析完毕</span><br>        <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> match;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//截取html字符串 每次匹配到了就往前继续匹配</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">advance</span>(<span class="hljs-params">n</span>) &#123;<br>    html = html.<span class="hljs-title function_">substring</span>(n);<br>  &#125;<br>  <span class="hljs-comment">//   返回生成的ast</span><br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据-ast-重新生成代码"><a href="#根据-ast-重新生成代码" class="headerlink" title="根据 ast 重新生成代码"></a>根据 ast 重新生成代码</h1><p>拿到生成好的 ast 之后 需要把 ast 转化成类似_c(‘div’,{id:”app”},_c(‘div’,undefined,_v(“hello”+_s(name)),_c(‘span’,undefined,_v(“world”))))这样的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/codegen.js</span><br><br><span class="hljs-keyword">const</span> defaultTagRE = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>; <span class="hljs-comment">//匹配花括号 &#123;&#123;  &#125;&#125; 捕获花括号里面的内容</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 判断节点类型</span><br>  <span class="hljs-comment">// 主要包含处理文本核心</span><br>  <span class="hljs-comment">// 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式&#123;&#123;&#125;&#125;的处理</span><br><br>  <span class="hljs-comment">// 如果是元素类型</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//   递归创建</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">generate</span>(node);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   如果是文本节点</span><br>    <span class="hljs-keyword">let</span> text = node.<span class="hljs-property">text</span>;<br>    <span class="hljs-comment">// 不存在花括号变量表达式</span><br>    <span class="hljs-keyword">if</span> (!defaultTagRE.<span class="hljs-title function_">test</span>(text)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(text)&#125;</span>)`</span>;<br>    &#125;<br>    <span class="hljs-comment">// 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug</span><br>    <span class="hljs-keyword">let</span> lastIndex = (defaultTagRE.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> tokens = [];<br>    <span class="hljs-keyword">let</span> match, index;<br><br>    <span class="hljs-keyword">while</span> ((match = defaultTagRE.<span class="hljs-title function_">exec</span>(text))) &#123;<br>      <span class="hljs-comment">// index代表匹配到的位置</span><br>      index = match.<span class="hljs-property">index</span>;<br>      <span class="hljs-keyword">if</span> (index &gt; lastIndex) &#123;<br>        <span class="hljs-comment">//   匹配到的&#123;&#123;位置  在tokens里面放入普通文本</span><br>        tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex, index)));<br>      &#125;<br>      <span class="hljs-comment">//   放入捕获到的变量内容</span><br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-string">`_s(<span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>].trim()&#125;</span>)`</span>);<br>      <span class="hljs-comment">//   匹配指针后移</span><br>      lastIndex = index + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push</span><br>    <span class="hljs-keyword">if</span> (lastIndex &lt; text.<span class="hljs-property">length</span>) &#123;<br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex)));<br>    &#125;<br>    <span class="hljs-comment">// _v表示创建文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;tokens.join(<span class="hljs-string">&quot;+&quot;</span>)&#125;</span>)`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理attrs属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genProps</span>(<span class="hljs-params">attrs</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; attrs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> attr = attrs[i];<br>    <span class="hljs-comment">// 对attrs属性里面的style做特殊处理</span><br>    <span class="hljs-keyword">if</span> (attr.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>      attr.<span class="hljs-property">value</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;;&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>);<br>        obj[key] = value;<br>      &#125;);<br>      attr.<span class="hljs-property">value</span> = obj;<br>    &#125;<br>    str += <span class="hljs-string">`<span class="hljs-subst">$&#123;attr.name&#125;</span>:<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;str.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>&#125;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 生成子节点 调用gen函数进行递归创建</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildren</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> children = el.<span class="hljs-property">children</span>;<br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;children.map((c) =&gt; gen(c)).join(<span class="hljs-string">&quot;,&quot;</span>)&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 递归创建生成code</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title function_">getChildren</span>(el);<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-string">`_c(&#x27;<span class="hljs-subst">$&#123;el.tag&#125;</span>&#x27;,<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    el.attrs.length ? <span class="hljs-string">`<span class="hljs-subst">$&#123;genProps(el.attrs)&#125;</span>`</span> : <span class="hljs-string">&quot;undefined&quot;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;</span><span class="hljs-subst">$&#123;children ? <span class="hljs-string">`,<span class="hljs-subst">$&#123;children&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>)`</span>;<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="code-字符串生成-render-函数"><a href="#code-字符串生成-render-函数" class="headerlink" title="code 字符串生成 render 函数"></a>code 字符串生成 render 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">// 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值 比如 name值就变成了this.name</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="组件挂载入口"><a href="#组件挂载入口" class="headerlink" title="组件挂载入口"></a>组件挂载入口</h1><p>模板编译解析生成了render函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>  el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>  <br>  <span class="hljs-comment">// 如果不存在 render 属性</span><br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>    <span class="hljs-comment">// 如果存在 template 属性</span><br>    <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br>    <br>    <span class="hljs-keyword">if</span> (!templage &amp;&amp; el) &#123;<br>      <span class="hljs-comment">// 如果不存在 render 和 template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>      template = el.<span class="hljs-property">outerHTML</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>    <span class="hljs-keyword">if</span> (template) &#123;<br>      <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>      options.<span class="hljs-property">render</span> = render;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将当前组件实例挂载到真实的el节点上面</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountComponent</span>(vm, el);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-函数-gt-虚拟-dom-render"><a href="#render-函数-gt-虚拟-dom-render" class="headerlink" title="render 函数 -&gt; 虚拟 dom  _render"></a>render 函数 -&gt; 虚拟 dom  _render</h1><p>执行vm._render()方法 调用生成的render函数 生成虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/render.js</span><br><span class="hljs-keyword">import</span> &#123; createElement, createTextNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/index&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取模板编译生成的render方法</span><br>    <span class="hljs-keyword">const</span> &#123; render &#125; = vm.<span class="hljs-property">$options</span>;<br>    <span class="hljs-comment">// 生成 vnode 虚拟dom</span><br>    <span class="hljs-keyword">const</span> vnode = render.<span class="hljs-title function_">call</span>(vm);<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br><br>  <span class="hljs-comment">// render函数里面有_c _v _s方法需要定义</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_c</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(...args);<br>  &#125;;<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_v</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_s</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-comment">// 如果模板里面的是一个对象  需要JSON.stringify</span><br>    <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span><br>      ? <span class="hljs-string">&quot;&quot;</span><br>      : <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;object&quot;</span><br>      ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(val)<br>      : val;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/index.js</span><br><br><span class="hljs-comment">// 定义Vnode类</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vnode</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, data, key, children, text</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建元素vnode 等于render函数里面的 h=&gt;h(App)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag, data = &#123;&#125;, ...children</span>) &#123;<br>  <span class="hljs-keyword">let</span> key = data.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(tag, data, key, children);<br>&#125;<br><br><span class="hljs-comment">// 创建文本vnode</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, text);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="虚拟dom-gt-真实-dom-update"><a href="#虚拟dom-gt-真实-dom-update" class="headerlink" title="虚拟dom -&gt;真实 dom   _update"></a>虚拟dom -&gt;真实 dom   _update</h1><p>_update 核心方法就是 patch 初始渲染和后续更新都是共用这一个方法 只是传入的第一个参数不同 初始渲染总体思路就是根据虚拟 dom(vnode) 调用原生 js 方法创建真实 dom 节点并替换掉 el 选项的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><br><span class="hljs-keyword">import</span> &#123; patch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/patch&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-comment">// 把_update挂载在Vue的原型</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// patch是渲染vnode为真实dom核心</span><br>    vm.<span class="hljs-property">$el</span> = <span class="hljs-title function_">patch</span>(vm.<span class="hljs-property">$el</span>, vnode)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/patch.js</span><br><span class="hljs-comment">// patch 用来渲染和更新视图 （此处仅包含初次渲染的逻辑）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode</span>) &#123;<br>  <span class="hljs-comment">// 判断传入的oldVnode是否是一个真实元素</span><br>  <span class="hljs-comment">// 这里很关键 初次渲染 传入的vm.$el就是咱们传入的el选项  所以是真实dom</span><br>  <span class="hljs-comment">// 如果不是初始渲染而是视图更新的时候  vm.$el就被替换成了更新之前的老的虚拟dom</span><br>  <span class="hljs-keyword">const</span> isRealElement = oldVnode.<span class="hljs-property">nodeType</span>;<br>  <span class="hljs-keyword">if</span> (isRealElement) &#123;<br>    <span class="hljs-comment">// 这里是初次渲染的逻辑</span><br>    <span class="hljs-keyword">const</span> oldElm = oldVnode;<br>    <span class="hljs-keyword">const</span> parentElm = oldElm.<span class="hljs-property">parentNode</span>;<br>    <span class="hljs-comment">// 将虚拟dom转化成真实dom节点</span><br>    <span class="hljs-keyword">let</span> el = <span class="hljs-title function_">createElm</span>(vnode);<br>    <span class="hljs-comment">// 插入到 老的el节点下一个节点的前面 就相当于插入到老的el节点的后面</span><br>    <span class="hljs-comment">// 这里不直接使用父元素appendChild是为了不破坏替换的位置</span><br>    parentElm.<span class="hljs-title function_">insertBefore</span>(el, oldElm.<span class="hljs-property">nextSibling</span>);<br>    <span class="hljs-comment">// 删除老的el节点</span><br>    parentElm.<span class="hljs-title function_">removeChild</span>(oldVnode);<br>    <span class="hljs-keyword">return</span> el;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 虚拟 dom 转成真实 dom 就是调用原生方法生成 dom 树</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; tag, data, key, children, text &#125; = vnode;<br>  <span class="hljs-comment">//   判断虚拟dom 是元素节点还是文本节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   虚拟dom的el属性指向真实dom</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);<br>    <span class="hljs-comment">// 解析虚拟dom属性</span><br>    <span class="hljs-title function_">updateProperties</span>(vnode);<br>    <span class="hljs-comment">// 如果有子节点就递归插入到父节点里面</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElm</span>(child));<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   文本节点</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析vnode的data属性 映射到真实dom上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProperties</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> newProps = vnode.<span class="hljs-property">data</span> || &#123;&#125;;<br>  <span class="hljs-keyword">let</span> el = vnode.<span class="hljs-property">el</span>; <span class="hljs-comment">//真实节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-comment">// style需要特殊处理下</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> newProps.<span class="hljs-property">style</span>) &#123;<br>        el.<span class="hljs-property">style</span>[styleName] = newProps.<span class="hljs-property">style</span>[styleName];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;class&quot;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = newProps.<span class="hljs-property">class</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 给这个元素添加属性 值就是对应的值</span><br>      el.<span class="hljs-title function_">setAttribute</span>(key, newProps[key]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mountComponent-挂载"><a href="#mountComponent-挂载" class="headerlink" title="mountComponent 挂载"></a>mountComponent 挂载</h1><p>使用vm._update()方法把虚拟dom渲染到页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">// 上一步模板编译解析生成了render函数</span><br>  <span class="hljs-comment">// 下一步就是执行vm._render()方法 调用生成的render函数 生成虚拟dom</span><br>  <span class="hljs-comment">// 最后使用vm._update()方法把虚拟dom渲染到页面</span><br>  <span class="hljs-comment">// 真实的el选项赋值给实例的$el属性 为之后虚拟dom产生的新的dom替换老的dom做铺垫</span><br>  vm.<span class="hljs-property">$el</span> = el;<br>  <span class="hljs-comment">// _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-和-update-原型方法的混入"><a href="#render-和-update-原型方法的混入" class="headerlink" title="_render 和 _update 原型方法的混入"></a>_render 和 _update 原型方法的混入</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lifecycle&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./render&quot;</span>;<br><span class="hljs-comment">// Vue就是一个构造函数 通过new关键字进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 这里开始进行Vue初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载需要传入Vue</span><br><span class="hljs-comment">// 此做法有利于代码分割</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><br><span class="hljs-comment">// 混入_render</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-comment">// 混入_update</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>在两秒之后改变了模板里面的 cc 但是计算属性依赖的 aa 和 bb 都没变化 所以计算属性不会重新计算 还是保留的上次计算结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">cc</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;computedName&#125;&#125;&#123;&#123;cc&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">computedName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">aa</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bb</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-comment">// 当我们每一次改变数据的时候  渲染watcher都会执行一次 这个是影响性能的</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">cc</span> = <span class="hljs-number">4</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">2000</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="计算属性的初始化"><a href="#计算属性的初始化" class="headerlink" title="计算属性的初始化"></a>计算属性的初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">const</span> computed = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">computed</span>;<br>  <span class="hljs-keyword">const</span> watchers = (vm.<span class="hljs-property">_computedWatchers</span> = &#123;&#125;); <span class="hljs-comment">// 用来存放计算 watcher</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> coumputed) &#123;<br>    <span class="hljs-keyword">const</span> userEdf = computed[k]; <span class="hljs-comment">// 获取用户定义的计算属性</span><br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span>;<span class="hljs-comment">//创建计算属性watcher使用</span><br>    <span class="hljs-comment">// 创建计算watcher lazy设置为true</span><br>    watchers[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, <span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;);<br>    <span class="hljs-title function_">defineComputed</span>(vm, k, userDef);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对计算属性进行属性劫持"><a href="#对计算属性进行属性劫持" class="headerlink" title="对计算属性进行属性劫持"></a>对计算属性进行属性劫持</h1><p><code>defineComputed</code> 方法主要是重新定义计算属性 其实最主要的是劫持 get 方法 也就是计算属性依赖的值。<br>需要根据依赖值是否发生变化来判断计算属性是否需要重新计算<br><code>createComputedGetter</code> 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 <code>Watcher</code> 增加 <code>dirty</code> 标志位 如果标志变为 <code>true</code> 代表需要调用 <code>watcher.evaluate</code> 来进行重新计算了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 定义普通对象用来劫持计算属性</span><br><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;<br><span class="hljs-comment">// 重新定义计算属性 对 get 和 set 劫持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key, userDef</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果是一个函数  需要手动赋值到get上</span><br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = userDef.<span class="hljs-property">set</span>;<br>  &#125;<br>  <span class="hljs-comment">//   利用Object.defineProperty来对计算属性的get和set进行劫持</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition);<br>&#125;<br><span class="hljs-comment">// 重写计算属性的 get 方法，来判断是否需要进行重新计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]; <span class="hljs-comment">//获取对应的计算属性watcher</span><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;<br>        watcher.evaluate(); <span class="hljs-comment">//计算属性取值的时候 如果是脏的  需要重新求值</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>1.实例化的时候如果是计算属性 不会去调用 get 方法访问值进行依赖收集<br>2.update 方法只是把计算 watcher 的 dirty 标识为 true 只有当下次访问到了计算属性的时候才会重新计算<br>3.新增 evaluate 方法专门用于计算属性重新计算<br>4.新增 depend 方法 让计算属性的依赖值收集外层 watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-comment">// import &#123; pushTarget, popTarget &#125; from &quot;./dep&quot;;</span><br><span class="hljs-comment">// import &#123; queueWatcher &#125; from &quot;./scheduler&quot;;</span><br><span class="hljs-comment">// import &#123;isObject&#125; from &#x27;../util/index&#x27;</span><br><span class="hljs-comment">// // 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-comment">// let id = 0;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br>    <span class="hljs-comment">// this.user = options.user; //标识用户watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//标识计算属性watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//dirty可变  表示计算watcher是否需要重新计算 默认值是true</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-comment">// if (typeof exprOrFn === &quot;function&quot;) &#123;</span><br>    <span class="hljs-comment">//   this.getter = exprOrFn;</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//   this.getter = function () &#123;</span><br>    <span class="hljs-comment">//     //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>    <span class="hljs-comment">//     let path = exprOrFn.split(&quot;.&quot;);</span><br>    <span class="hljs-comment">//     let obj = vm;</span><br>    <span class="hljs-comment">//     for (let i = 0; i &lt; path.length; i++) &#123;</span><br>    <span class="hljs-comment">//       obj = obj[path[i]]; //vm.a.a.a.a.b</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return obj;</span><br>    <span class="hljs-comment">//   &#125;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>); <span class="hljs-comment">//计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>      <span class="hljs-comment">// 异步队列机制</span><br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   计算属性重新进行计算 并且计算完成把dirty置为false</span><br>  <span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性的watcher存储了依赖项的dep</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">//调用依赖项的dep去收集渲染watcher</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   run() &#123;</span><br>  <span class="hljs-comment">//     const newVal = this.get(); //新值</span><br>  <span class="hljs-comment">//     const oldVal = this.value; //老值</span><br>  <span class="hljs-comment">//     this.value = newVal; //跟着之后  老值就成为了现在的值</span><br>  <span class="hljs-comment">//     if (this.user) &#123;</span><br>  <span class="hljs-comment">//       if(newVal!==oldVal||isObject(newVal))&#123;</span><br>  <span class="hljs-comment">//         this.cb.call(this.vm, newVal, oldVal);</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     &#125; else &#123;</span><br>  <span class="hljs-comment">//       // 渲染watcher</span><br>  <span class="hljs-comment">//       this.cb.call(this.vm);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="外层-Watcher-的依赖收集"><a href="#外层-Watcher-的依赖收集" class="headerlink" title="外层 Watcher 的依赖收集"></a>外层 Watcher 的依赖收集</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-comment">//   return function () &#123;</span><br><span class="hljs-comment">//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher</span><br><span class="hljs-comment">//     if (watcher) &#123;</span><br><span class="hljs-comment">//       if (watcher.dirty) &#123;</span><br><span class="hljs-comment">//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-comment">// 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集</span><br>          watcher.<span class="hljs-title function_">depend</span>()<br>        &#125;<br><span class="hljs-comment">//       &#125;</span><br><span class="hljs-comment">//       return watcher.value;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性依赖的值发生了改变 这时候 watcher 的 dirty 为 true 下次访问计算属性 ,此时数据改变了，但是还没触发视图更新<br>因为模板里面只有计算属性 而计算属性的依赖值的 dep 里面只收集了计算 watcher 的依赖 。<br>自身变化也只是通知了计算 watcher 调用 update 把 dirty 置为 true 。<br>所以需要把计算属性的依赖项也添加渲染 watcher 的依赖。<br>让自身变化之后首先通知计算 watcher 进行重新计算 然后通知渲染 watcher 进行视图更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>可见最初设计存放 watcher 的容器就是一个栈结构。<br>因为整个 Vue 生命周期的过程中会存在很多的 watcher 比如渲染 watcher 计算 watcher 侦听 watcher 等。<br>而每个 watcher 在调用了自身的 get 方法前后会分别调用 pushTarget 入栈和 popTarget 出栈。<br>这样子当计算属性重新计算之后就立马会出栈 那么外层的 watcher 就会成为新的 Dep.target。<br>使用 watcher.depend 方法让计算属性依赖的值收集一遍外层的渲染 watcher 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello &#123;&#123;a&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们在这里模拟更新</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">a</span> = <span class="hljs-number">456</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 此方法是刷新视图的核心</span></span><br><span class="language-javascript">    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在数据变动的时候自动去更新视图</p><h1 id="定义-Watcher"><a href="#定义-Watcher" class="headerlink" title="定义 Watcher"></a>定义 Watcher</h1><p>在 observer 文件夹下新建 watcher.js 代表和观察者相关 可以把 Watcher 当做观察者 它需要订阅数据的变动 当数据变动之后 通知它去执行某些方法 其实本质就是一个构造函数 初始化的时候会去执行 get 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><span class="hljs-comment">// 全局变量id 每次 new Watcher 都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建渲染-Watcher"><a href="#创建渲染-Watcher" class="headerlink" title="创建渲染 Watcher"></a>创建渲染 Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">//   _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br><br>  <span class="hljs-comment">// 引入watcher的概念 这里注册一个渲染watcher 执行vm._update(vm._render())方法渲染视图</span><br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;刷新页面&quot;</span>);<br>    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>  &#125;;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="定义-Dep"><a href="#定义-Dep" class="headerlink" title="定义 Dep"></a>定义 Dep</h1><p>Dep 也是一个构造函数 可以把他理解为观察者模式里面的被观察者 在 subs 里面收集 watcher 当数据变动的时候通知自身 subs 所有的 watcher 更新<br>Dep.target 是一个全局 Watcher 指向 初始状态是 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h1 id="对象的依赖收集"><a href="#对象的依赖收集" class="headerlink" title="对象的依赖收集"></a>对象的依赖收集</h1><p>依赖收集和派发更新的核心 其实就是在数据被访问的时候 把我们定义好的渲染 Watcher 放到 dep 的 subs 数组里面 同时把 dep 实例对象也放到渲染 Watcher 里面去 数据更新时就可以通知 dep 的 subs 存储的 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value);<br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-watcher"><a href="#完善-watcher" class="headerlink" title="完善 watcher"></a>完善 watcher</h1><p>watcher 在调用 getter 方法前后分别把自身赋值给 Dep.target 方便进行依赖收集 update 方法用来更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dep&quot;</span>;<br><br><span class="hljs-comment">// 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []; <span class="hljs-comment">//存放dep的容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">//用来去重dep</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>(); <span class="hljs-comment">//如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-keyword">let</span> id = dep.<span class="hljs-property">id</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">add</span>(id);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);<br>      <span class="hljs-comment">//   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-dep"><a href="#完善-dep" class="headerlink" title="完善 dep"></a>完善 dep</h1><p>定义相关的方法把收集依赖的同时把自身也放到 watcher 的 deps 容器里面去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   如果当前存在watcher</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 把自身-dep实例存放在watcher里面</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   依次执行subs里面的watcher更新方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">watcher</span>) =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-comment">//   把watcher加入到自身的subs容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的依赖收集"><a href="#数组的依赖收集" class="headerlink" title="数组的依赖收集"></a>数组的依赖收集</h1><p>如果对象属性的值是一个数组 那么执行 childOb.dep.depend()收集数组的依赖 如果数组里面还包含数组 需要递归遍历收集 因为只有访问数据触发了 get 才会去收集依赖 一开始只是递归对数据进行响应式处理无法收集依赖 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// childOb就是Observer实例</span><br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          <span class="hljs-comment">// 这里表示 属性的值依然是一个对象 包含数组和对象 childOb指代的就是Observer实例对象  里面的dep进行依赖收集</span><br>          <span class="hljs-comment">// 比如&#123;a:[1,2,3]&#125; 属性a对应的值是一个数组 观测数组的返回值就是对应数组的Observer实例对象</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果数据结构类似 &#123;a:[1,2,[3,4,[5,6]]]&#125; 这种数组多层嵌套  数组包含数组的情况  那么我们访问a的时候 只是对第一层的数组进行了依赖收集 里面的数组因为没访问到  所以五大收集依赖  但是如果我们改变了a里面的第二层数组的值  是需要更新页面的  所以需要对数组递归进行依赖收集</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>              <span class="hljs-comment">// 如果内部还是数组</span><br>              <span class="hljs-title function_">dependArray</span>(value); <span class="hljs-comment">// 不停的进行依赖收集</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 递归收集数组依赖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dependArray</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e, i = <span class="hljs-number">0</span>, l = value.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    e = value[i];<br>    <span class="hljs-comment">// e.__ob__代表e已经被响应式观测了 但是没有收集依赖 所以把他们收集到自己的Observer实例的dep里面</span><br>    e &amp;&amp; e.<span class="hljs-property">__ob__</span> &amp;&amp; e.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(e)) &#123;<br>      <span class="hljs-comment">// 如果数组里面还有数组  就递归去收集依赖</span><br>      <span class="hljs-title function_">dependArray</span>(e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的派发更新"><a href="#数组的派发更新" class="headerlink" title="数组的派发更新"></a>数组的派发更新</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/array.js</span><br><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">//   这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 这句话是关键</span><br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性代表的是该数据已经被响应式观察过了 __ob__对象指的就是Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted); <span class="hljs-comment">// 对新增的每一项进行观测</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">//数组派发更新 ob指的就是数组对应的Observer实例 我们在get的时候判断如果属性的值还是对象那么就在Observer实例的dep收集依赖 所以这里是一一对应的  可以直接更新</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>watch</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/</url>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>侦听属性的写法很多 可以写成 字符串 函数 数组 以及对象 对于对象的写法自己可以增加一些 options 用来增强功能 侦听属性的特点是监听的值发生了变化之后可以执行用户传入的自定义方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;&#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">aa</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#x27;doSomething&#x27;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: [&#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;]</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">aa</span> = <span class="hljs-number">1111</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 统一初始化数据的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-title function_">initWatch</span>(vm);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 watch</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> watch = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">watch</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> watch) &#123;<br>    <span class="hljs-keyword">const</span> handler = watch[k]; <span class="hljs-comment">// 用户自定义 watch 的写法，可能是数组 对象 函数 字符串</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;<br>      <span class="hljs-comment">// 如果是数组就遍历进行创建</span><br>      handler.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">handle</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, k, handle);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, k, handler);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建watcher的核心</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span>(<span class="hljs-params">vm, exprOrFn, handler, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    options = handler; <span class="hljs-comment">//保存用户传入的对象</span><br>    handler = handler.<span class="hljs-property">handler</span>; <span class="hljs-comment">//这个代表真正用户传入的函数</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   代表传入的是定义好的methods方法</span><br>    handler = vm[handler];<br>  &#125;<br>  <span class="hljs-comment">//   调用vm.$watch创建用户watcher</span><br>  <span class="hljs-keyword">return</span> vm.$watch(exprOrFn, handler, options);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h1><p>原型方法$watch 就是创建自定义 watch 的核心方法 把用户定义的 options 和 user:true 传给构造函数 Watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observer/watcher&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">experOrFn, cb, option</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">let</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, exprOrFn, cb, &#123; ...options, <span class="hljs-attr">user</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-comment">// 如果有immediate属性 代表需要立即执行回调</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">cb</span>(); <span class="hljs-comment">// 如果立刻执行</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; isObject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = options.<span class="hljs-property">user</span>; <span class="hljs-comment">//标识用户watcher</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>        <span class="hljs-keyword">let</span> path = exprOrFn.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">let</span> obj = vm;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>          obj = obj[path[i]]; <span class="hljs-comment">//vm.a.a.a.a.b</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就进行一次取值操作 进行依赖收集过程</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-comment">//   get() &#123;</span><br>  <span class="hljs-comment">//     pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>  <span class="hljs-comment">//     const res = this.getter.call(this.vm); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>  <span class="hljs-comment">//     popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  <span class="hljs-comment">//     return res;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-comment">//   update() &#123;</span><br>  <span class="hljs-comment">//     // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>  <span class="hljs-comment">//     if (this.lazy) &#123;</span><br>  <span class="hljs-comment">//       this.dirty = true;</span><br>  <span class="hljs-comment">//     &#125;else&#123;</span><br>  <span class="hljs-comment">//       // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>  <span class="hljs-comment">//       // 异步队列机制</span><br>  <span class="hljs-comment">//       queueWatcher(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   depend()&#123;</span><br>  <span class="hljs-comment">//     // 计算属性的watcher存储了依赖项的dep</span><br>  <span class="hljs-comment">//     let i=this.deps.length</span><br>  <span class="hljs-comment">//     while(i--)&#123;</span><br>  <span class="hljs-comment">//       this.deps[i].depend() //调用依赖项的dep去收集渲染watcher</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newVal = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">//新值</span><br>    <span class="hljs-keyword">const</span> oldVal = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">//老值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = newVal; <span class="hljs-comment">//现在的新值将成为下一次变化的老值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>      <span class="hljs-comment">// 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址</span><br>      <span class="hljs-keyword">if</span> (newVal !== oldVal || <span class="hljs-title function_">isObject</span>(newVal)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, newVal, oldVal);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 渲染watcher</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/</url>
    
    <content type="html"><![CDATA[<h1 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h1><p><code>Vue</code> 实例化过程，<code>Vue</code> 为一个构造函数，传入的参数是一个对象，可称之为 <code>options</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就是初始化 Vue 工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-comment">// Vue 就是一个构造函数 通过 new 关键字 进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 进行 Vue 初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init 方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载，需要传入 Vue 对象</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure><p>initMixin 把 _init 方法挂载在 Vue 原型 供 Vue 实例调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">import</span> &#123; observe &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./observer/index.js&quot;</span>;<br><span class="hljs-comment">// 初始化状态</span><br><span class="hljs-comment">// 初始化的顺序依次是 prop &gt; methods &gt; data &gt; watch</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-title function_">initProps</span>(vm)  <br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) &#123;<br>    <span class="hljs-title function_">initMethod</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) &#123;<br>    <span class="hljs-title function_">initComputed</span>(vm);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 data 数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 实例的_data熟悉就是传入的data</span><br>  <span class="hljs-comment">// vue 组件的 data 之所以要使用函数，是为了私有化数据，js 只有函数作用域</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span> ? data.<span class="hljs-title function_">call</span>(vm) : data || &#123;&#125;;<br>  <br>  <span class="hljs-comment">// 把 data 数据代理到 vm 也就是 Vue实例上面 我们可以使用this.a 来访问 this._data.a</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>  &#125;<br>  <span class="hljs-comment">// 对数据进行观测 -- 响应式数据核心</span><br>  <span class="hljs-title function_">observe</span>(data);<br>&#125;<br><span class="hljs-comment">// 数据代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">object, sourceKey, key</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(object, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> object[sourceKey][key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      object[sourceKey][key] = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的数据劫持"><a href="#对象的数据劫持" class="headerlink" title="对象的数据劫持"></a>对象的数据劫持</h1><p>defineReactive 函数 主要使用<code>Object.defineProperty</code>来对数据 get 和 set 进行劫持 这里知道了为啥数据变动了会自动更新视图 -&gt; 可以在 set 里面去通知视图更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 对象上所有的属性依次进行观测</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> key = keys[i];<br>      <span class="hljs-keyword">let</span> value = data[key];<br>      <span class="hljs-title function_">defineReactive</span>(data, key, value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Object.defineProperty 数据劫持核心 兼容性在 ie9 及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, keym value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归</span><br>  <span class="hljs-comment">// 如果 value 还是对象就递归，直到 value 不是对象为止</span><br>  <span class="hljs-comment">// 如果 Vue 数据嵌套层级过深 会有性能影响</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取值&#x27;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置值&#x27;</span>);<br>      value = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 如果传过来的是对象或者数组，进行属性劫持</span><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ||<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的观测"><a href="#数组的观测" class="headerlink" title="数组的观测"></a>数组的观测</h1><p>数组元素过多，使用递归根据下标直接修改数据太消耗性能了，不可能为每个元素下标都添加 get 和 set 方法。<br />所以通过重写数组原型方法来对数组的七种方法进行拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>     <span class="hljs-comment">// 通过重写数组原型方法来对数组的七种方法进行拦截</span><br>     value.<span class="hljs-property">__proto__</span> = arrayMethods;<br>     <span class="hljs-comment">// 如果数组里面还包含数组 需要递归判断</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>   &#125;<br> &#125;<br>  <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">observe</span>(items[i])  <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这段代码给每个响应式数据增加了一个不可枚举的__ob__属性 并且指向了 Observer 实例 那么我们首先可以根据这个属性来防止已经被响应式观察的数据反复被观测 其次 响应式数据可以使用__ob__来获取 Observer 实例的相关方法 这对数组很关键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, &#123;<br>      <span class="hljs-comment">// 值指 Observer 的实例</span><br>      <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,<br>      <span class="hljs-comment">// 不可枚举</span><br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/array.js</span><br><span class="hljs-comment">// 先保留数据原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 然后将 arrayMethods 继承自数组原型</span><br><span class="hljs-comment">// 这里是面向切片编程思想（AOP）：不破坏封装的前提下，动态扩展功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-keyword">let</span> methodsToPath = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>];<br>methodsToPath.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-comment">// 这里的标志就是代表数组有新增操作</span><br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<br>    <span class="hljs-comment">// 在这里就可以检测到数据变化了</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p><code>**Object.defineProperty(obj, prop, descriptor)**</code>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><ul><li>obj：要定义属性的对象</li><li>prop：要定义或修改的 属性名称 或 Symbol</li><li>descriptor：要定义或修改的 属性描述符</li></ul><h3 id="本身的限制"><a href="#本身的限制" class="headerlink" title="本身的限制"></a>本身的限制</h3><ul><li>目标只是对象的属性，而不是整个对象</li><li>一次只能 定义或者修改一个属性</li></ul><h3 id="在-Vue2-中的缺陷"><a href="#在-Vue2-中的缺陷" class="headerlink" title="在 Vue2 中的缺陷"></a>在 Vue2 中的缺陷</h3><ul><li>只能拦截对象属性的<code>get</code>和<code>set</code>操作，比如无法拦截<code>delete</code>、<code>in</code>、<code>方法调用</code>等操作</li><li>动态添加新属性（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新属性</li></ul></li><li>通过<code>delete</code>删除属性（响应式丢失）<ul><li>使用<code>this.$delete()</code>删除属性</li></ul></li><li>使用数组索引 <code>替换/新增</code>元素（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新元素</li></ul></li><li>使用数组<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>等原生方法改变原数组时（响应式丢失）<ul><li>使用重写后<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>方法</li></ul></li><li>一次只能对一个属性实现 数据劫持，需要遍历对所有属性进行劫持</li><li>数据结构复杂时（属性值为 引用类型数据），需要通过 递归 进行处理</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>**Proxy**</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><code>new Proxy(target, handler)</code>针对整个对象进行代理</li><li>代理对象的属性拥有读取、修改、删除、新增、是否存在属性，等相应的捕捉器<ul><li><code>get()</code>：<code>读取</code>操作的捕捉器</li><li><code>get()</code>：<code>设置</code>操作的捕捉器</li><li><code>deleteProperty()</code>：<code>删除</code>操作的捕捉器</li><li><code>ownKeys()</code>：<code>Object.getOwnPropertyNames</code>方法和<code>Object.getOwnPropertySymbols</code>方法的捕捉器</li><li><code>has()</code>：<code>in</code>操作符的捕捉器</li></ul></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>**Reflect**</code>是一个内置的对象，它提供拦截 <code>**JavaScript**</code> 操作的方法，这些方法与 <code>Proxy handlers</code> 提供的的方法是一一对应的，且 <code>**Reflect**</code> 不是一个函数对象，即不能进行实例化，其所有属性和方法都是静态的（就像是<code>Math</code>对象）。</p><ul><li><code>Reflect.get(target, propertyKey[, receiver]) </code>获取对象身上某个属性的值，类似于 <code>target[name]</code></li><li><code>Reflect.set(target, propertyKey, value[, receiver]) </code>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code></li><li><code>Reflect.deleteProperty(target, propertyKey) </code>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code></li><li><code>Reflect.ownKeys(target) </code>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code> 影响)</li><li><code>Reflect.has(target, propertyKey) </code>判断一个对象是否存在某个属性，和<code>in</code>运算符 的功能完全相同</li></ul><h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span></span>) &#123;<br><span class="hljs-comment">// 若目标对象是响应式的只读对象，则直接返回</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isReadonly</span>(target)) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 否则将目标数据尝试变成响应式数据</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createdReactiveObject</span>(<br>    target,<br>    <span class="hljs-literal">false</span>,<br>    mutableHandlers, <span class="hljs-comment">// 对象类型的 handlers</span><br>    mutableCollectionHandlers, <span class="hljs-comment">// 集合类型的 handlers</span><br>    reacitveMap<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject()"></a>createReactiveObject()</h3><p>主要是做前置处理</p><ul><li>目标数据为 原始值类型，返回 原数据</li><li>目标数据的<code>__v_raw</code>属性为<code>true</code>，且是非响应式数据，或 不是通过调用<code>readonly()</code>方法，则直接返回原数据</li><li>目标数据已存在相应的<code>proxy</code>代理对象，则直接返回代理对象</li><li>目标数据不存在对应的 白名单数据类型中，则直接返回原数据，支持响应式的数据类型如下<ul><li>可扩展的对象（是否可以先加新属性）</li><li><code>__v_skip</code>属性不存在或者值为 false 的对象</li><li>数据类型为<code>Object</code>，<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>WeakMap</code>，<code>WeakSet</code>的对象</li><li>其他数据都统一被认为是无效的响应式数据对象</li></ul></li><li>通过<code>Proxy</code>创建代理对象，根据目标数据类型选择不同的<code>Proxy handlers</code>（捕获器）</li></ul><p>具体的实现在对应数据类型的 捕获器 中，即下面源码中的<code>collectionHandlers</code>和<code>baseHandlers</code>，而它们则对应的是上述<code>reactive()</code>函数中的<code>createReactiveObject()</code>函数传递的<code>mutableCollectionHandlers</code>和<code>mutableHandlers</code>参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: Target,</span><br><span class="hljs-params">  isReadonly: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  baseHanlders: ProxyHandle&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  collectionHandlers: ProxyHandler&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  proxyMap: <span class="hljs-built_in">WeakMap</span>&lt;Target, <span class="hljs-built_in">any</span>&gt;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 非对象类型直接返回</span><br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>    <span class="hljs-keyword">if</span>(__DEV__) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`value cannot be made reactive: <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(target)&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 目标数据的 __v_raw 属性若为 true，且是【非响应式数据】或 不是通过调用 readonly() 方法，则直接返回</span><br>  <span class="hljs-keyword">if</span> (<br>    target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span>] &amp;&amp;<br>    !(isReadonly &amp;&amp; target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>])<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br><br>  <span class="hljs-comment">// 目标对象已存在相应的 proxy 代理对象，则直接返回</span><br>  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>    <span class="hljs-keyword">return</span> existingProxy<br>  &#125;<br>  <br><span class="hljs-comment">// 只有在白名单中的值类型才可以被代理监测，否则直接返回</span><br>  <span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)<br>  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>) &#123;<br>    <span class="hljs-keyword">return</span> target     <br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建代理对象</span><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<br>    target,<br>    <span class="hljs-comment">// 若目标对象是集合类型（Set、Map）则使用集合类型对应的捕获器，否则使用基础捕获器</span><br>    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers <br>  )<br><br>  <span class="hljs-comment">// 将对应的代理对象存储在 proxyMap 中</span><br>  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捕获器-Handles"><a href="#捕获器-Handles" class="headerlink" title="捕获器 Handles"></a>捕获器 Handles</h3><h4 id="对象类型（Object类型不包括Array）的捕获器-mutableHandlers"><a href="#对象类型（Object类型不包括Array）的捕获器-mutableHandlers" class="headerlink" title="对象类型（Object类型不包括Array）的捕获器 mutableHandlers"></a>对象类型（Object类型不包括Array）的捕获器 <code>mutableHandlers</code></h4><p><code>baseHandles.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">mutableHandlers</span>: <span class="hljs-title class_">ProxyHandle</span>&lt;<span class="hljs-built_in">object</span>&gt; = &#123;<br>  get,<br>  set,<br>  deleteProperty,<br>  has,<br>  ownKeys,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get-捕获器"><a href="#get-捕获器" class="headerlink" title="get 捕获器"></a>get 捕获器</h5><ul><li>当前数据对象为 数组，重写 数组对应方法</li><li>当前数据对象为普通对象，且非 只读 的则通过<code>track(target, TrackOptypes.GET, key)</code>进行依赖收集<ul><li>当前数据对象为浅层响应，直接返回其对应的属性值</li><li>当前数据对象为 ref 类型，自动脱 ref</li></ul></li><li>当前数据对象属性值是对象类型<ul><li>当前数据对象为 只读的，则通过 <code>readonly(res)</code>向外返回其结果</li><li>否则将当前属性值以<code>reactive(res)</code>向外返回 proxy 代理对象</li></ul></li><li>否则直接向外返回对应的 属性值 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span>, shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target: Target, key: <span class="hljs-built_in">string</span> | sysbol, receiver: <span class="hljs-built_in">object</span></span>) &#123;<br>    <span class="hljs-comment">// 当直接通过指定 key 访问 vue 内置自定义的对象属性时，返回其对应的值</span><br>    <span class="hljs-keyword">if</span>(key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) &#123;<br>      <span class="hljs-keyword">return</span> !isReadonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_READONLY</span>) &#123;<br>      <span class="hljs-keyword">return</span> isRedaonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFLags</span>.<span class="hljs-property">IS_SHALLOW</span>) &#123;<br>      <span class="hljs-keyword">return</span> shallow<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span> &amp;&amp;<br>      receiver ===<br>        (<br>          isReadonly<br>            ? shallow<br>              ? shallowReadonlyMap<br>              : readonlyMap<br>            : shallow<br>            ? shallowReactiveMap<br>            : reactiveMap<br>        ).<span class="hljs-title function_">get</span>(target)<br>    ) &#123;<br>      <span class="hljs-keyword">return</span> target<br>    &#125;<br>     <span class="hljs-comment">// 判断是否为数组类型</span><br>    <span class="hljs-keyword">const</span> targetIsArray = <span class="hljs-title function_">isArray</span>(target)<br><br>    <span class="hljs-comment">// 数组对象</span><br>    <span class="hljs-keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="hljs-title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;<br>      <span class="hljs-comment">// 重写/增强数组的方法： </span><br>      <span class="hljs-comment">//  - 查找方法：includes、indexOf、lastIndexOf</span><br>      <span class="hljs-comment">//  - 修改原数组的方法：push、pop、unshift、shift、splice</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)<br>    &#125;<br>    <span class="hljs-comment">// 获取对应属性值</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSymbol</span>(key) ? builtInSymbols.<span class="hljs-title function_">has</span>(key) : <span class="hljs-title function_">isNonTrackableKeys</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// 依赖收集</span><br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 浅层响应</span><br>    <span class="hljs-keyword">if</span> (shallow) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 若是 ref 类型响应式数据，会进行【自动脱 ref】，但不支持【数组】+【索引】的访问方式</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(res)) &#123;<br>      <span class="hljs-keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="hljs-title function_">isIntegerKey</span>(key)<br>      <span class="hljs-keyword">return</span> shouldUnwrap ? res.<span class="hljs-property">value</span> : res<br>    &#125;<br>    <span class="hljs-comment">// 属性值是对象类型：</span><br>    <span class="hljs-comment">//  - 是只读属性，则通过 readonly() 返回结果，</span><br>    <span class="hljs-comment">//  - 且是非只读属性，则递归调用 reactive 向外返回 proxy 代理对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(res)) &#123;<br>      <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="set捕获器"><a href="#set捕获器" class="headerlink" title="set捕获器"></a><code>set</code>捕获器</h5><p>边界值处理，以及<strong>更新属性值，并通过</strong><code>**targger()**</code>触发依赖更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span><br><span class="hljs-params">    value: <span class="hljs-built_in">unknown</span>,</span><br><span class="hljs-params">    receiver: <span class="hljs-built_in">object</span></span><br><span class="hljs-params">  </span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-comment">// 保存旧的数据</span><br>    <span class="hljs-keyword">let</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br><br>    <span class="hljs-comment">// 若原数据值属于 只读 且 ref 类型，并且新数据值不属于 ref 类型，则意味着修改失败</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!shallow &amp;&amp; !<span class="hljs-title function_">isReadonly</span>(value)) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isShallow</span>(value)) &#123;<br>        value = <span class="hljs-title function_">toRaw</span>(value)<br>        oldValue = <span class="hljs-title function_">toRaw</span>(oldValue)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>        oldValue.<span class="hljs-property">value</span> = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// in shallow mode, objects are set as-is regardless of reactive or not</span><br>    &#125;<br><br>    <span class="hljs-comment">// 是否存在对应的 key</span><br>    <span class="hljs-keyword">const</span> hadKey =<br>      <span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isIntegerKey</span>(key)<br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span><br>        : <span class="hljs-title function_">hasOwn</span>(target, key)<br><br>    <span class="hljs-comment">// 设置对应值</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br><br>    <span class="hljs-comment">// 若目标对象是原始原型链上的内容（非自定义添加），则不触发依赖更新</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-title function_">toRaw</span>(receiver)) &#123;<br>      <span class="hljs-keyword">if</span> (!hadKey) &#123;<br>        <span class="hljs-comment">// 目标对象不存在对应的 key，则为新增操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>, key, value)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(value, oldValue)) &#123;<br>        <span class="hljs-comment">// 目标对象存在对应的值，则为修改操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>, key, value, oldValue)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回修改结果</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="deleteProperty-amp-has-amp-ownKeys-捕获器"><a href="#deleteProperty-amp-has-amp-ownKeys-捕获器" class="headerlink" title="deleteProperty &amp; has &amp; ownKeys 捕获器"></a><code>deleteProperty</code> &amp; <code>has</code> &amp; <code>ownKeys</code> 捕获器</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> hadKty = <span class="hljs-title function_">hasOwn</span>(target, key)<br>  <span class="hljs-keyword">const</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>  <span class="hljs-comment">// 目标对象存在对应的 key，并且成功删除，才会触发依赖更新</span><br>  <span class="hljs-keyword">if</span> (result &amp;&amp; hadKey) &#123;<br>    <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">DELETE</span>, key, <span class="hljs-literal">undefined</span>, oldValue)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">has</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key)<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSymbol</span>(key) || !builtInSymbols.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">HAS</span>, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span></span>): (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>)[] &#123;<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">ITERATE</span>, <span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">&#x27;length&#x27;</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">REflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="数组类型捕获器-arrayInstrumentations"><a href="#数组类型捕获器-arrayInstrumentations" class="headerlink" title="数组类型捕获器 arrayInstrumentations"></a>数组类型捕获器 <code>arrayInstrumentations</code></h5><p>数组由于<code>index</code>和<code>length</code>会相互影响，所以需要特殊处理</p><ul><li><code>arr[1] = 2</code>会隐式修改<code>length</code>的属性值</li><li><code>arr.lenght = 0</code>会导致原索引位置的值发生变更</li></ul><p>为了能够合理触发和 <code>length</code> 相关副作用函数的执行，在 <code>set()</code> 捕获器中会判断当前操作的类型：</p><ul><li>当<code>Number(key) &lt; target.length</code>证明是修改操作，对应<code>TriggerOptypes.SET</code>类型，即当前操作不会改变<code>length</code>的值，不需要 触发和 <code>length</code>有关副作用函数的执行</li><li>当<code>Number(key) &gt;= target.length</code>证明是新增操作，<code>TriggerOpTypes.ADD</code>类型，即当前操作会改变<code>length</code>的值，需要触发和<code>length</code>相关副作用函数的执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误页面处理</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="error-vue"><a href="#error-vue" class="headerlink" title="error.vue"></a>error.vue</h1><p><code>error.vue</code>必须与项目入口文件<code>app.vue</code>在同级别目录下<br><code>error.vue</code>接受了一个<code>error</code>的<code>props</code></p><h2 id="定制处理"><a href="#定制处理" class="headerlink" title="定制处理"></a>定制处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ErrorPage<br>  :errCode=&quot;error.statusCode&quot;<br>  &gt;<br>  &lt;/ErrorPage&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br><br>const props = defineProps(&#123;<br>  error: Object<br>&#125;)<br>if(props.error.statusCode === 500 &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123;<br>  // 此处可以记录错误日志<br>  useRecordErrorLog(props.error)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>ErrorPage</code>组件为根据错误码定制的页面</p><h2 id="错误日志收集"><a href="#错误日志收集" class="headerlink" title="错误日志收集"></a>错误日志收集</h2><p>存储到项目根目录下的<code>logs/error.log</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> winston <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;winston&#x27;</span>;<br><br><span class="hljs-keyword">const</span> logger = winston.<span class="hljs-title function_">createLogger</span>(&#123;<br>  <span class="hljs-attr">transports</span>: [<br>    <span class="hljs-keyword">new</span> winston.<span class="hljs-property">transports</span>.<span class="hljs-title class_">File</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;logs/error.log&#x27;</span>,<br>      <span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">format</span>: winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">combine</span>(<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">timestamp</span>(&#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;YYYY-MM-DDTHH:mm:ss.SSSZ&#x27;</span> &#125;),<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">json</span>(),<br>      )<br>    &#125;)<br>  ]<br>&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRecordErrorLog</span> = (<span class="hljs-params">error</span>) =&gt; &#123;<br>  logger.<span class="hljs-title function_">error</span>(error)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useRecordErrorLog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加百度统计代码</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="设置单页面模式"><a href="#设置单页面模式" class="headerlink" title="设置单页面模式"></a>设置单页面模式</h1><ol><li>首先去百度统计PC端首页-&gt;使用规则-&gt;单页设置-&gt;启用单页应用数据统计</li><li>在项目入口文件<code>app.vue</code>引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-title function_">useHead</span>(&#123;<br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span><br>    &#125;<br>  ]<br>&#125;)<br><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (_hmt) &#123;<br>    _hmt.<span class="hljs-title function_">push</span>([<span class="hljs-string">&#x27;_trackPageview&#x27;</span>, route.<span class="hljs-property">path</span>])<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="不设置单页模式"><a href="#不设置单页模式" class="headerlink" title="不设置单页模式"></a>不设置单页模式</h2><ol><li>对应的每个页面引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useHead</span>(&#123;<br><br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span>,<br>      <span class="hljs-attr">bodyClose</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// false 添加到 head标签内</span><br>      <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">defer</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  ]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航栏锚点</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="导航栏部分"><a href="#导航栏部分" class="headerlink" title="导航栏部分"></a>导航栏部分</h1><ol><li>利用<code>NuxtLink</code>组件实现跳转<ol><li>注意，如果要跳转到其他项目的地址，此时要给<code>link</code>前面拼接上<code>window.location.origin</code></li></ol></li><li><code>link</code>后添加上对应页面，对应锚点的<code>id</code>，此处可以用<code>#targetID</code>这种形式拼接</li></ol><h2 id="对应页面"><a href="#对应页面" class="headerlink" title="对应页面"></a>对应页面</h2><ol><li>每个锚点添加上<code>id=&quot;xxx&quot;</code></li><li>使用<code>useAnchor()</code></li></ol><h1 id="useAnchor实现"><a href="#useAnchor实现" class="headerlink" title="useAnchor实现"></a>useAnchor实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> targetId = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> targetElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(targetId);<br>    <span class="hljs-keyword">if</span> (targetElement) &#123;<br>      targetElement.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onMounted</span>(scrollToAnchor);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useAnchor;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

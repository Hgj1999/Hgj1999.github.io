<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>原理</title>
    <link href="/2023/09/19/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/01.%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/19/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/01.%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="双线程架构"><a href="#双线程架构" class="headerlink" title="双线程架构"></a>双线程架构</h1><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img01.png" alt="image.png"><br>渲染层和逻辑层由两个线程管理<br><strong>逻辑层：</strong>JSCore 运行 js 代码<br><strong>渲染层：</strong>webview 进行渲染，多个页面，多个webview<br><strong>系统层：</strong>逻辑层和渲染层由 Native 层控制：通信、数据传递、网络请求转发</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.wxml</span><br>&lt;view&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span> &#125;)<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><ul><li>渲染层渲染数据</li><li>逻辑层产生、处理数据</li><li>逻辑层通过<code>setData</code>方法通知渲染层渲染数据</li></ul><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p>主要是走的虚拟dom的流程，先把<code>WXML</code>中的模版转成虚拟 dom，然后再由虚拟dom转到真实dom渲染<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img02.png" alt="image.png"><br>通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的。<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img03.png" alt="image.png"><br><strong>注：由于小程序是双线程架构，所以数据传递都是线程之间的通信，会有一定的延时，属于异步操作。</strong></p><h1 id="快速渲染设计原理"><a href="#快速渲染设计原理" class="headerlink" title="快速渲染设计原理"></a>快速渲染设计原理</h1><p>小程序采用多个webview渲染，更加接近原生App的用户体验。<br>如果为单页面应用，单独打开一个页面，需要先卸载当前页面结构，并重新渲染。<br>多页面应用，新页面直接滑动出来并且覆盖在旧页面上即可。这样用户体验更好。</p><h2 id="页面数量限制"><a href="#页面数量限制" class="headerlink" title="页面数量限制"></a>页面数量限制</h2><p>页面得载入是通过创建并插入webview 来实现的。<br>微信小程序做了限制，在微信小程序中打开的页面不能超过10个，达到10个页面后，就不能再打开新的页面。</p><h2 id="PageFrame"><a href="#PageFrame" class="headerlink" title="PageFrame"></a>PageFrame</h2><p>微信小程序在初始化的时候，除了渲染首页之后，会帮我们提前额外的预加载一个 webview ,微信起名为 instanceframe.html ，用来新渲染 webview 的模板。<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img04.png" alt="image.png"></p><h3 id="pageframe-x2F-instanceframe-html"><a href="#pageframe-x2F-instanceframe-html" class="headerlink" title="pageframe&#x2F;instanceframe.html"></a>pageframe&#x2F;instanceframe.html</h3><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img05.png" alt="image.png"></p><h3 id="pageframe-x2F-instanceframe-html中的js"><a href="#pageframe-x2F-instanceframe-html中的js" class="headerlink" title="pageframe&#x2F;instanceframe.html中的js"></a>pageframe&#x2F;instanceframe.html中的js</h3><h4 id="dev-wxconfig-js"><a href="#dev-wxconfig-js" class="headerlink" title="./dev/wxconfig.js"></a><code>./dev/wxconfig.js</code></h4><p>小程序默认总配置项，包括用户自定义与系统默认的整合结果。在控制台输入__wxConfig可以看出具体的配置项<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img06.png" alt="image.png"></p><h4 id="dev-devtoolsconfig-js"><a href="#dev-devtoolsconfig-js" class="headerlink" title="./dev/devtoolsconfig.js"></a><code>./dev/devtoolsconfig.js</code></h4><p>小程序开发者配置，包括navigationBarHeight,标题栏的高度，状态栏高度，等等，控制台输入__devtoolsconfig可以看到其对应的信息<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img07.png" alt="image.png"></p><h4 id="dev-deviceinfo-js"><a href="#dev-deviceinfo-js" class="headerlink" title="./dev/deviceinfo.js"></a><code>./dev/deviceinfo.js</code></h4><p>设备信息，包含尺寸&#x2F;像素点pixelRatio</p><h4 id="dev-jsdebug-js"><a href="#dev-jsdebug-js" class="headerlink" title="./dev/jsdebug.js"></a><code>./dev/jsdebug.js</code></h4><p>debug工具</p><h4 id="dev-WAWebview-js"><a href="#dev-WAWebview-js" class="headerlink" title="./dev/WAWebview.js"></a><code>./dev/WAWebview.js</code></h4><p>渲染层底层基础库</p><h4 id="dev-hls-js"><a href="#dev-hls-js" class="headerlink" title="./dev/hls.js"></a><code>./dev/hls.js</code></h4><p>视频流处理工具</p><h4 id="dev-WARemoteDebug-js"><a href="#dev-WARemoteDebug-js" class="headerlink" title="./dev/WARemoteDebug.js"></a><code>./dev/WARemoteDebug.js</code></h4><p>底层基础库调试工具</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="wxappcode-js"><a href="#wxappcode-js" class="headerlink" title="wxappcode.js"></a>wxappcode.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> decodeJsonPathName = <span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&quot;pages/index/index&quot;</span>)<br>__wxAppCode__[decodeJsonPathName + <span class="hljs-string">&quot;.json&quot;</span>]=&#123;<span class="hljs-string">&quot;usingComponents&quot;</span>:&#123;&#125;&#125;<br><span class="hljs-keyword">var</span> decodeWxmlPathName = <span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&quot;pages/index/index&quot;</span>)<br>__wxAppCode__[decodeWxmlPathName + <span class="hljs-string">&quot;.wxml&quot;</span>]=$gwx(<span class="hljs-string">&quot;./&quot;</span> + decodeWxmlPathName + <span class="hljs-string">&quot;.wxml&quot;</span>)<br><span class="hljs-keyword">var</span> decodeWxssPathName = <span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&quot;pages/index/index&quot;</span>)<br>__wxAppCode__[decodeWxssPathName + <span class="hljs-string">&quot;.wxss&quot;</span>]=((<span class="hljs-variable language_">window</span>.<span class="hljs-property">eval</span> || __global.<span class="hljs-property">__hackEval</span>)(<span class="hljs-string">&#x27;setCssToHead([\x22.\x22,[1],\x22test&#123; height: calc(\x22,[0,100],\x22-2px); ;wxcs_style_height : calc(100rpx-2px); width: \x22,[0,200],\x22; ;wxcs_style_width : 200rpx; ;wxcs_originclass: .test;;wxcs_fileinfo: ./pages/index/index.wxss 2 1; &#125;\n\x22,],undefined,&#123;path:\x22./pages/index/index.wxss\x22&#125;)&#x27;</span>));<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">__mainPageFrameReady__</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__mainPageFrameReady__</span>()<br></code></pre></td></tr></table></figure><p>主要几个重要的函数和属性有</p><ul><li>decodeJsonPathName</li><li>.json配置</li><li>.wxml编译后的$gwx函数。</li><li>.wxss编译后的eval函数。</li></ul><p><strong>当小程序需要打开某个页面的时候，只需要提取页面的者几个属性，注入到预加载的html模版中就可以快速生成一个新的webview</strong></p><h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><p>在视图层内，每个页面都是一个webiew，当小程序启动时只有首页一个webview<br>执行wx.navigateTo新开一个页面的时候，就会创建一个新的webview并插入到视图层<br>wx.navigateBack则为销毁webview<br>小程序每个视图层页面内容都是通过pageframe.html模板来生成的。</p><ul><li>首页启动时，即第一次通过pageframe.html生成内容后，后台服务会缓存pageframe.html模板首次生成的html内容</li><li>非首次新打开页面时，页面请求的pageframe.html内容直接走后台缓存</li><li>非首次新打开页面时，pageframe.html页面引入的外链js资源走本地缓存</li></ul><p>这样在后续新打开页面时，都会走缓存的pageframe的内容，避免重复生成，快速打开一个新页面。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img08.png" alt="image.png"></p><h1 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h1><p> WXML 类似 HTML<br>小程序自行搭建了组件组织框架Exparser框架<br><strong>Exparser的组件模型与WebComponents标准中的ShadowDOM高度相似</strong></p><h2 id="Exparser转换demo"><a href="#Exparser转换demo" class="headerlink" title="Exparser转换demo"></a><strong>Exparser转换demo</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!--index.<span class="hljs-property">wxml</span>--&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="language-xml">  Weixin</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative;&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Exparser 转换后</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;wx-view <span class="hljs-attr">exparser</span>:info-<span class="hljs-keyword">class</span>-prefix=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">exparser</span>:info-component-id=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>  <span class="hljs-title class_">Weixin</span><br>  &lt;wx-text <span class="hljs-attr">exparser</span>:info-<span class="hljs-keyword">class</span>-prefix=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">exparser</span>:info-component-id=<span class="hljs-string">&quot;3&quot;</span> style=<span class="hljs-string">&quot;position:relative;&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&lt;/wx-text&gt;<br>&lt;/wx-view&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">wx-button</span> <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">exparser:info-attr-bindtap</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">aria-disabled</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">  按钮</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">wx-button</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h2 id="WebComponents"><a href="#WebComponents" class="headerlink" title="WebComponents"></a>WebComponents</h2><p>Web Components 是一个浏览器原生支持的组件化方案，允许你创建新的自定义、可封装、可重用的HTML 标记。不用加载任何外部模块，直接就可以在浏览器中跑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user-card</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;userCardId&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--组件的样式与代码封装在一起，只对自定义元素生效，不会影响外部的全局样式。--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.name</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">button</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;</span><br><span class="language-css">    &#125;  </span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span>21312<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">super</span>()</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123; <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;closed&#x27;</span>&#125;);</span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> templateElem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;userCardId&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> content = templateElem.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>)</span><br><span class="language-javascript">      </span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-comment">// this.appendChild(content)</span></span><br><span class="language-javascript">      shadow.<span class="hljs-title function_">appendChild</span>(content)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;user-card&#x27;</span>, <span class="hljs-title class_">UserCard</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li><strong>Custom Elements规范</strong></li></ul><p>可以创建一个自定义标签。根据规范，自定义元素的名称必须包含连词线”-“，用与区别原生的 HTML 元素。<br>可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用。</p><ul><li><strong>templates</strong> <strong>规范</strong></li></ul><p>提供了<code>&lt;template&gt;</code>标签，可以在它里面使用HTML定义DOM结构。</p><ul><li><strong>Shadow DOM规范</strong></li></ul><p>WebComponent 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</p><h2 id="Exparser框架原理"><a href="#Exparser框架原理" class="headerlink" title="Exparser框架原理"></a>Exparser框架原理</h2><p>Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序提供各种各样的组件支撑。<br>内置组件和自定义组件都由Exparser组织管理。<br>Exparser会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的Shadow DOM实现。Exparser的主要特点包括以下几点：</p><ul><li><strong>基于Shadow DOM模型</strong>：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。</li><li><strong>可在纯JS环境中运行</strong>：这意味着逻辑层也具有一定的组件树组织能力。</li><li><strong>高效轻量</strong>：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li></ul><p>小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建和自定义组件特性等。</p><h2 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h2><p>小程序中的部分组件是由客户端创建的原生组件，并不完全在Exparser的渲染体系下，这些组件有：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/camera.html">camera</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html">canvas</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">input</a>（仅在 focus 时表现为原生组件）</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html">live-player</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html">live-pusher</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/map.html">map</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/textarea.html">textarea</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/video.html">video</a></li></ul><p>引入原生组件主要有3个好处：</p><ul><li><strong>扩展Web的能力</strong>。比如像输入框组件（input, textarea）有更好地控制键盘的能力。</li><li><strong>体验更好，同时也减轻WebView的渲染工作</strong>。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用WebView线程，而交给更高效的客户端原生处理。</li><li><strong>绕过setData、数据通信和重渲染流程，使渲染性能更好</strong>。比如像画布组件（canvas）可直接用一套丰富的绘图接口进行绘制。</li></ul><h2 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h2><p>如果业务场景为手势识别之类的，监听事件不断的触发，数据不断的改变。<br>这样的业务场景中，我们可以想像，如果坐标值不断改变的话，在逻辑与视图分开的双线程架构中，线程与线程之间的通讯是非常频繁的，会有很大的性能问题。<br>所以我们可以看到微信开放了一个标记，可以在渲染层写部分js逻辑。这样话就可以在渲染层单独处理频繁改变的数据，就避免了线程与线程之间频繁通讯导致的性能和延时问题。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>为什么不用HTML语法和WebComponents来实现渲染，而是选择自定义？</p><ul><li>管控与安全：web技术可以通过脚本获取修改页面敏感内容或者随意跳转其它页面</li><li>能力有限：会限制小程序的表现形式</li><li>标签众多：增加理解成本</li></ul><h1 id="wxss"><a href="#wxss" class="headerlink" title="wxss"></a>wxss</h1><p>WXSS 具有 CSS的大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p><h1 id="虚拟-dom-渲染流程"><a href="#虚拟-dom-渲染流程" class="headerlink" title="虚拟 dom 渲染流程"></a>虚拟 dom 渲染流程</h1><p>微信开发者工具和微信客户端都无法直接运行小程序的源码，因此我们需要对小程序的源码进行编译。<br>代码编译过程包括本地预处理、本地编译和服务器编译。<br>为了快速预览，微信开发者工具模拟器运行的代码只经过本地预处理、本地编译，没有服务器编译过程，而微信客户端运行的代码是额外经过服务器编译的。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--index.wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  Weixin<br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative;&quot;</span> &gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编译后<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img09.png" alt="image.png"></p><p>但是在这个script标签中插入了$gwx函数之后并没有立即执行这个函数。<br>在渲染层的一个的<script>标签中,我们可以看到这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> decodeName = <span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&quot;./pages/index/index.wxml&quot;</span>)<br><span class="hljs-keyword">var</span> generateFunc = $gwx(decodeName)<br></code></pre></td></tr></table></figure><p>我们在控制抬手动执行$gwx()的返回值 generateFunc()函数<br>返回的树形结构，就是该页面wxml对应的js对象形式表示的dom树<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%8E%9F%E7%90%86/img10.png" alt="image.png"></p><p>这是一个类似Virtual Dom的对象，交给了 WAWebview.js 来渲染成真实DOM</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/2023/09/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/02.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/09/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/02.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="小程序启动流程"><a href="#小程序启动流程" class="headerlink" title="小程序启动流程"></a>小程序启动流程</h1><h2 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h2><h3 id="小程序相关信息准备"><a href="#小程序相关信息准备" class="headerlink" title="小程序相关信息准备"></a>小程序相关信息准备</h3><p>微信客户端需要从微信后台获取小程序的<strong>头像、昵称、版本、配置、权限</strong>等基本信息，这些信息会在本地缓存，并通过一定的机制进行更新。</p><h3 id="环境预加载"><a href="#环境预加载" class="headerlink" title="环境预加载"></a>环境预加载</h3><p>为了尽可能的降低运行环境准备对启动耗时的影响，微信客户端会根据用户的使用场景和设备资源的使用情况，依照一定策略在小程序<strong>启动前</strong>对运行环境进行部分地<strong>预加载</strong>，以降低启动耗时。<br><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/img01.png" alt="image.png"><br>从微信后台获取代码包地址，从 CDN 下载小程序代码包<br>小程序代码包会在本地缓存，并通过<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html">更新机制</a>进行更新。<br>同步下载&#x2F;异步下载 强制更新&#x2F;静默更新<br>为例降低代码包下载的耗时，微信做的一些优化</p><ul><li>代码包压缩</li><li>增量更新</li><li>优先使用QUIC 和HTTP&#x2F;2</li><li>预先建立连接：在下载发生前，提前和 CDN 建立连接，降低下载过程中 DNS 请求和连接建立的耗时</li><li>代码包复用：对每个代码包都会计算 MD5 签名。即使发生了版本更新，如果代码包的 MD5 没有发生变化，则不需要重新进行下载。</li></ul><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>小程序启动时需要从代码包内读取小程序的配置和代码，并注入到 JavaScript 引擎中。<br>微信客户端会使用 V8 引擎的 <a href="https://v8.dev/blog/code-caching-for-devs">Code Caching</a> 技术对代码编译结果进行缓存，降低非首次注入时的编译耗时</p><blockquote><p><strong>code cache</strong><br>V8 会把编译和解析的结果缓存下来，等到下次遇到相同的文件，直接跳过这个过程，把直接缓存好的数据拿来使用</p></blockquote><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/img02.png" alt="image.png"></p><h1 id="启动时性能优化"><a href="#启动时性能优化" class="headerlink" title="启动时性能优化"></a>启动时性能优化</h1><h2 id="控制代码包体积"><a href="#控制代码包体积" class="headerlink" title="控制代码包体积"></a>控制代码包体积</h2><ul><li>推荐所有小程序使用分包加载</li><li>避免非必要使用全局自定义组件和插件<ul><li>会影响按需注入的效果和小程序代码注入的耗时</li></ul></li><li>控制资源文件<ul><li>建议开发者在代码包内的图片一般应只包含一些体积较小的图标，避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片等资源文件。</li><li>这类文件应尽可能部署到 CDN，并使用 URL 引入。</li></ul></li></ul><h2 id="代码注入优化"><a href="#代码注入优化" class="headerlink" title="代码注入优化"></a>代码注入优化</h2><ul><li>推荐所有小程序使用按需注入</li><li>用时注入<ul><li>为自定义组件配置 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/placeholder.html">占位组件</a>，组件就会自动被视为用时注入组件</li></ul></li><li>启动过程中减少同步 API 的调用<ul><li>建议优先使用拆分后的 getSystemSetting&#x2F;getAppAuthorizeSetting&#x2F;getDeviceInfo&#x2F;getWindowInfo&#x2F;getAppBaseInfo 按需获取信息，或使用使用异步版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoAsync.html">getSystemInfoAsync</a></li><li>getStorageSync&#x2F;setStorageSync 应只用来进行数据的持久化存储，不应用于运行时的数据传递或全局状态管理。</li></ul></li></ul><h2 id="首屏渲染优化"><a href="#首屏渲染优化" class="headerlink" title="首屏渲染优化"></a>首屏渲染优化</h2><ul><li>启用「<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html">初始渲染缓存</a>」<ul><li>启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前</li></ul></li><li>提前首屏数据请求<ul><li>预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度</li><li>周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。</li></ul></li><li>缓存请求数据</li><li>骨架屏</li></ul><h1 id="运行时性能优化"><a href="#运行时性能优化" class="headerlink" title="运行时性能优化"></a>运行时性能优化</h1><h2 id="合理使用setData"><a href="#合理使用setData" class="headerlink" title="合理使用setData"></a>合理使用setData</h2><p>控制频率，范围，内容</p><h2 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h2><ul><li>适当监听scroll 事件</li><li>控制 WXML 节点数量和层级<ul><li>源码中一个页面dom 数目超过16000，肯定会报错</li></ul></li><li>data层级不要过深，因为需要深度遍历</li><li>使用 IntersectionObserver 监听元素</li></ul><h2 id="页面切换优化"><a href="#页面切换优化" class="headerlink" title="页面切换优化"></a>页面切换优化</h2><ul><li>避免在 onHide&#x2F;onUnload 执行耗时操作<ul><li>页面切换时，会先调用前一个页面的 onHide 或 onUnload 生命周期，然后再进行新页面的创建和渲染</li></ul></li><li>提前发起数据请求<ul><li>进行页面跳转时（例如 wx.navigateTo），可以提前为下一个页面做一些准备工作。页面之间可以通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#%E9%A1%B5%E9%9D%A2%E9%97%B4%E9%80%9A%E4%BF%A1">EventChannel</a> 进行通信。类似postMessage</li><li>例如，在页面跳转时，可以同时发起下一个页面的数据请求，而不需要等到页面 onLoad 时再进行，从而可以让用户更早的看到页面内容。</li></ul></li><li>控制预加载下个页面的时机<ul><li>程序页面加载完成后，会预加载下一个页面。默认情况下，小程序框架会在当前页面 onReady 触发 200ms 后触发预加载。</li><li>预加载会阻塞当前页面setData，我们可以对单个页面的配置增加， handleWebviewPreload 选项，来控制预加载下个页面的时机。</li></ul></li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/img03.png" alt="image.png"></p><h2 id="资源加载优化"><a href="#资源加载优化" class="headerlink" title="资源加载优化"></a>资源加载优化</h2><p>控制图片和静态资源的大小</p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ul><li>合理分包，既能减少耗时，也能降低内存占用</li><li>事件监听，定时器记得清除</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>context</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/07.context/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/07.context/</url>
    
    <content type="html"><![CDATA[<p>以 <code>React 16.8</code> 为例子：</p><ul><li>新版本 Context 位置：<code>react-reconciler/src/ReactFiberNewContext.js</code> </li><li>老版本 Context 位置：<code>react-reconciler/src/ReactFiberContext.js</code> </li><li>Provider 如何传递 context？ </li><li>三种获取 context 原理（<code>Consumer</code>，<code>useContext</code>，<code>contextType</code>）？ </li><li>消费<code>context</code>的组件，context 改变，为什么会订阅更新（如何实现）。 </li><li>context 更新，如何避免 <code>pureComponent</code>，<code>shouldComponentUpdate</code> 渲染控制策略的影响。 </li><li>如何实现的 context 嵌套传递（多个 Provider）？</li></ul><h1 id="1-context-对象"><a href="#1-context-对象" class="headerlink" title="1. context 对象"></a>1. context 对象</h1><p>上述所说的老版本 context 就是 Legacy Context 模式下的 context，老版本的 context 是采用约定式的使用规则，于是有了 <code>getChildContext</code>和<code>childContextTypes</code>协商的属性和方法，这种方式不仅不够灵活，而且对于函数组件也存在局限性，所以在 <code>v16.3</code>推出了新版本的 <code>context</code>，开发者能够更加灵活的运用 Context。新版本引入 context 对象的概念，而且 context 对象上除了保留了传递的信息 <code>value</code>外，还有提供者 <code>Provider</code>和消费者<code>Consumer</code>。</p><p>createContext：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createContext</span>(<span class="hljs-params">defaultValue, calculateChangedBits</span>) &#123;<br>  <span class="hljs-comment">// context 对象本质</span><br>  <span class="hljs-keyword">const</span> context = &#123;<br>    <span class="hljs-attr">$$typeof</span>:<span class="hljs-variable constant_">REACT_CONTEXT_TYPE</span>, <span class="hljs-comment">// 本质上就是 Consumer element 类型</span><br>    <span class="hljs-attr">_calculateChangedBits</span>: calculateChangedBits,<br>    <span class="hljs-attr">_currentValue</span>: defaultvalue,<br>    <span class="hljs-attr">_threadCount</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-title class_">Provider</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-title class_">Consumer</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>  <span class="hljs-comment">// 本质上就是 Provider element 类型</span><br>  context.<span class="hljs-property">Provider</span> = &#123;<br>    <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_PROVIDER_TYPE</span>,<br>    <span class="hljs-attr">_context</span>: context,<br>  &#125;;<br>  context.<span class="hljs-property">Consumer</span> = context<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Provider</code>本质上是一个 element 对象 $$typeof -&gt; <code>REACT_PROVIDER_TYPE</code></li><li><code>Consumer</code>本质上也是一个 element 对象 $$typeof -&gt; <code>REACT_CONTEXT_TYPE</code></li><li><code>_currentValue</code>这个用来保存传递给 Provider 的 value。</li></ul><h1 id="2-Provider-提供者"><a href="#2-Provider-提供者" class="headerlink" title="2. Provider 提供者"></a>2. Provider 提供者</h1><p>Provider 本质就是一个特殊的 React Element 对象，那么接下来重点看一下 Provider 的实现原理，研究 Provider 重点围绕这两个点。</p><ul><li>Provider 如何传递 context 状态的。</li><li>Provider 中 value 改变，如何通知订阅 context。</li></ul><p><strong>jsx -&gt; element -&gt; fiber</strong></p><ul><li>首先标签形式的 <code>&lt;Provider&gt;</code>本质上就是<code>REACT_PROVIDER_TYPE</code>的 React Element。<code>&lt;Provider&gt;</code>-&gt; <code>REACT_PROVIDER_TYPE</code>React element。</li><li>接下来 element 会转化成 fiber，fiber 类型为 <strong>ContextProvider</strong>，React element -&gt; <code>ContextProvider fiber</code>。</li></ul><p>ContextProvider 类型的 fiber，在 fiber 调和阶段会进入到 <code>beginWork</code>流程，这个阶段会发生两件事情：</p><ul><li>如果当前类型的 fiber 不需要更新，那么会 <code>FinishedWork</code>中止当前节点和子节点的更新。</li><li>如果当前类型 fiebr 需要更新，那么会调用不同类型 fiber 的处理方法。，fiber 类型为 <code>ContextProvider</code>也有对应的 fiber 更新方法 - <code>updateContextProvider</code>。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContextProvider</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime,</span>) &#123;<br>  <span class="hljs-comment">// 获取 Provider 上的 value</span><br>  <span class="hljs-title function_">pushProvider</span>(workInProgress, newProps.<span class="hljs-property">value</span>);<br>  <span class="hljs-comment">// 更新 context</span><br>  <span class="hljs-keyword">if</span> (oldProps !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> changedBits = <span class="hljs-title function_">calculateChangedBits</span>(context, newProps.<span class="hljs-property">value</span>,oldProps.<span class="hljs-property">value</span>);<br>    <span class="hljs-keyword">if</span> (changedBits === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// context 没有变化，如果孩子们都是一样的话，那么不需要更新</span><br>      <span class="hljs-keyword">if</span>(oldProps.<span class="hljs-property">children</span> === newProps.<span class="hljs-property">children</span> &amp;&amp; !<span class="hljs-title function_">hasLegacyContextChanged</span>()) &#123;<br>        <span class="hljs-keyword">return</span> ... <span class="hljs-comment">// 停止调和子节点，收尾工作</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// context 改变，更新 context</span><br>      <span class="hljs-title function_">propagateContextChange</span>(workInProgress,context,changedBits,renderExpirationTime,);   <br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 继续向下调和子代 fiber</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>updateContextProvider</code>的核心流程：</p><ul><li>第一步：首先会调用 <code>pushProvider</code>，<code>pushProvider</code>会获取 type 属性上的 _context 对象，就是上述通过 _<code>_createContext_</code>_创建的 context 对象。然后将 Provider 的 value 属性，赋值给 context 的 _currentValue 属性上。 <strong>这里解释了 Provider 通过什么手段传递 context value，即通过挂载 context 的 _currentValue 属性。</strong></li><li>第二步：通过<code>calculateChangedBits</code> 计算出 changedBits，<code>caculateChangedBits</code>内部触发 context 对象上的 <code>_calculateChangedBits</code>，在调用 <code>createContext</code>的时候，实际上是有第二个参数的 <code>calculateChangedBits</code>，在更新 Provider 的时候这个参数就起作用了，当它返回的 <code>changedBits === 0</code>的时候，那么还会浅比较 children 是否发生变化，还有就是又没有 <code>legacy context</code>，如果这三点都满足的话，那么会判断当前 Provider 和 子节点不需要更新，那么会 return 停止向下掉和子节点。</li><li>第三步（ <strong>重点</strong> ）：在实际开发中，绝大多数当 value 发生变化，会走 <code>propagateContextChange</code>这个流程，也是 Provider 更新的特点。</li></ul><p><strong>propagateContextChange</strong>函数流程很繁琐，这里简化了流程，保留了最核心的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">propagateContextChange</span>(<span class="hljs-params">workInProgress, context</span>) &#123;<br>  <span class="hljs-keyword">let</span> fiber = workInProgress.<span class="hljs-property">child</span>;<br>  <span class="hljs-keyword">if</span> (fiebr !== <span class="hljs-literal">null</span>) &#123;<br>    fiber.<span class="hljs-property">return</span> = workInProgress;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(fiber !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> list = fiber.<span class="hljs-property">dependencies</span>;<br>    <span class="hljs-keyword">while</span> (dependency !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (dependency.<span class="hljs-property">context</span> === context) &#123;<br>        <span class="hljs-comment">// 类组件，不受 PureComponent 和 shouldComponentUpdate 影响</span><br>        <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) &#123;<br>          <span class="hljs-comment">// 会走 forceUpdate 逻辑</span><br>          <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(renderExpirationTime, <span class="hljs-literal">null</span>);<br>          update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ForceUpdate</span>;<br>          <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);<br>        &#125;<br>        <span class="hljs-comment">// 重要：<span class="hljs-doctag">TODO:</span> 提高 fiber 的优先级，让当前 fiber 可以 beginWork ，并且向上更新父级 fiber 链上的优先级</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>propagateContextChange</code>非常重要，它的职责就是深度遍历所有的子代 fiber，然后找到里面具有 <code>dependencies</code>的属性，对比 dependencies 中的 context 和当前 Provider 的 context 是否是同一个，如果是同一个，那么如果当前 fiber 是类组件，那么会给绑定一个 forceUpdate 标识。然后会提高 fiber 的更新优先级，让 fiber 在接下来的调和过程中，处于一个高优先级待更新的状态。大致逻辑就是，找到当前 fiber 向上的父级链上的 fiber，统一更新他们的优先级，使之变成高优先级待更新状态。</p><ul><li>什么情况下 fiber 会存到 dependencies，dependencies 保存的是 context 的依赖项。 <ul><li>dependencies 属性可以把当前的 fiber 和 context 建立起关联，可以理解成，使用了当前 context 的 fiber 会把 context 放在 dependencies 中，dependencies 属性本身是一个链表结构，一个 fiber 可以有多个 context 与之相对应，推测一下，什么情况下会使用 context？ <ul><li>有 <code>contextType</code>静态属性指向的类组件</li><li>使用 <code>useContext</code> hooks 的函数组件。</li><li>context 提供的 <code>Consumer</code>。</li></ul></li><li>使用过 contextType useContext 的组件对应 fiber，和 Consumer 类型 fiber，会和 dependencies 建立起联系，会把当前消费的 context 放入 dependencies 中，</li></ul></li><li>为什么对于 class 类组件会创建一个 ForceUpdate 类型的 update 对象呢？ <ul><li>在类组件中，通过<code>this.forceUpdate()</code>带来的更新就会被打上 ForceUpdate 类型的 update tag，这里可以理解为强制更新。在类组件更新流程中，强制更新会跳过 <code>PureComponent</code>和<code>shouldComponentUpdate</code>等优化策略。</li><li>如果想要让类组件调用 render，得到新的 children，那么就要通过 <code>PureComponent</code>和<code>shouldComponentUpdate</code>等层层阻碍，那么 context 要突破这些控制，就要做到当 value 改变，消费 context 的类组件更新，则需要通过 forceUpdate 强制更新。这样就解决了类组件更新限制。</li><li>流程：当 Provider 的 value 更新之后，Provider 下面的只要有消费了 context 的类组件，就会触发强制更新。：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context01.png" alt="image.png"></li></ul></li><li>存在 dependency 的 fiber，为什么要向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。 <ul><li>Provider 和 beiginWork 调和更新机制： <ul><li>第一个类组件执行 render，函数组件执行就是渲染吗？ <ul><li>实际上在 React 整个 <code>Reconciler</code>调和流程中，从更新调度任务的发起，再到 commit 和 render 两大阶段，再到真实的 dom 元素绘制，每一个环节都属于渲染的一部分。而开发者能够控制的 render，只是其中的一小部分：类组件执行 render，函数组件执行。而且这些本质上都发生在 FunctionComponent fiber 和 ClassComponent fiber 上。但是整个 fiber 树在调和阶段都需要更新的。更新调和 fiber 的方法在 React 底层叫做 <code>beginWork</code>。有一个问题需要注意，就是<code>beginWork</code> 非 render。 <ul><li><code>beginWork</code>：在一次更新中，只要需要更新的 fiber 或者受到牵连的 fiber，都会执行 beginWork。</li><li><code>render</code>：在一次更新中，只要组件类型的 fiber 会执行 render，得到新的 children。如果组件触发 render 那么她一定会经历 <code>beginWork</code></li></ul></li></ul></li></ul></li></ul></li></ul><p>比如发生一次更新任务，此次更新可能发生整个 fiber 树的任意枝叶上，但是因为 context props 穿透影响，React 不知道此次更新的波及范围，React 会从 rootFiber 开始更新，每一个更新 fiber 都会走 <code>beginWork</code>流程，开始找不同，找到没有需要更新的地方，那么指标是什么呢？其中一个重要的指标就是 <strong>更新的优先级</strong>，老版本用的是 <code>expirationTime</code>，新版本用的是<code>lane</code>，那么就要保证一个问题，就是如果更新发生在一个子节点，那么只有父节点<code>beginWork</code>才能让子节点<code>beginWork</code>。这样就形成了一条 root fiber -&gt; 父 fiber -&gt; 子 fiber 的 <code>beginWork</code>链。在 beginWork 过程中，有几种情况： </p><pre><code class="hljs">        -  第一种：如果遇到组件，而且更新不涉及当前组件，也不再当前组件的父子递归链上，那么就不会 render，也不会向下 beginWork。         -  第二种：如果遇到组件，而且更新不涉及当前组件，但是更新组件属于当前组件的子孙后代，那么不会 render，但是会向下 beginWork，目的很明确，找到对应的更新组件。         -  第三种：如果遇到其他类型的 fiber 比如 hostComponent `&lt;div&gt;`，那么会对比当前的更新优先级，如果低优先级，那么不需要向下 beginWork。反之向下 beginWork。            -  例子：点击 componentB 下面的 span 触发 setState 更新：</code></pre><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context02.png" alt="image.png"><br>                  - 从 root 开始第一次调和，三个 fiber 都会经历 beginWork，通过比较优先级，<code>componentA</code>和<code>div</code>停止向下 beginWork。<br>                  - 更新发生在 componentB，所以 componentB 渲染，触发<code>render</code>，得到新的 element，通过对比，<code>div</code> <code>span</code>都会 beginwork<br>                  - componentC 由于父组件更新，没有任何优化策略的情况下，那么也会跟着 <code>render</code>，接着 div 也会跟着 beginWork。</p><p>如上 ComponentC 通过 <code>PureComponent</code>或者<code>shouldComponentUpdate</code>限制更新之后，就会变成如下样子：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context03.png" alt="image.png"><br>如上 componentC 通过 <code>PureComponent</code> 处理后，不再 render ，当然也不会再向下 beginwork。<br>接下来点击 componentC 下的 div，触发 setState 更新，会发生如下变化： </p><pre><code class="hljs">              -  此时更新发生在 `componentC` 上，所以 componentB 只会发生 beginWork，不会发生 render。               -  `componentB`下面的`div`会停止向下的 beginWork</code></pre><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context04.png" alt="image.png"></p><p>总结流程： </p><pre><code class="hljs">        - 如果一个组件发生更新，那么当前组件到 fiber root 上的父级链上的多有 fiber，更新优先级都会升高，都会触发 beginWork。        - render 不等于 beginWork，但是 render 发生，一定触发了 beginWork。        - 一次 beginWork，一个 fiber 下的同级兄弟 fiber 会发生对比，找到任务优先级高的 fiber。向下 beginWork。  -  第二个 Context 改变如何做到消费 context 的组件更新？ </code></pre><p><strong>Context 原理</strong></p><p><code>Provider</code>更新，会递归所有子组件，只有消费了 context 的子代 fiber，都会给一个高优先级。而且向上更新父级 fiber 链上的优先级，让多有父级 fiber 都处于一个高优先级。那么接下来高优先级的 fiber 都会 beginWork。</p><p>将上述例子进行修改，<code>propagateContextChange</code>的流程会下如下一样，把父级 fiber 的优先级提高。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context05.png" alt="image.png"></p><p>整个 fiber 更新流程如下：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/context/context06.png" alt="image.png"></p><h1 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3. Consumer"></a>3. Consumer</h1><h2 id="Consumer-流程"><a href="#Consumer-流程" class="headerlink" title="Consumer 流程"></a>Consumer 流程</h2><p>Consumer 本质上是类型位 <code>REACT_CONTEXT_TYPE</code>的 element 对象。在调和阶段，会转化成<code>ContextConsumer</code>类型的 fiber 对象。 在 beginWork 中，会调用 <code>updateContextConsumer</code>方法。</p><blockquote><p>react&#x2F;react&#x2F;reconcider&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContextConsumer</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime,</span>) &#123;<br>  <span class="hljs-keyword">let</span> context = workInProgress.<span class="hljs-property">type</span>;<br>  <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-comment">// 得到 render props children</span><br>  <span class="hljs-keyword">const</span> render = newProps.<span class="hljs-property">children</span>;<br>  <span class="hljs-comment">// 读取 context</span><br>  <span class="hljs-title function_">perpareToReadContext</span>(workInProgress, renderExpirationTime);<br>  <span class="hljs-comment">// 得到最新的 context value</span><br>  <span class="hljs-keyword">const</span> newValue = <span class="hljs-title function_">readContext</span>(context, newProps.<span class="hljs-property">unstable_observedBits</span>);<br>  <span class="hljs-keyword">let</span> newChildren;<br>  <span class="hljs-comment">// 得到最新的 children element</span><br>  newChildren = <span class="hljs-title function_">render</span>(newValue);<br>  workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">PerformedWork</span>;<br>  <span class="hljs-comment">// 调和 children</span><br>  <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderExpirationTime);<br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>updateContextConsumer</code>的核心流程：</p><ul><li>首先调用 <code>readContext</code>获取最新的 value。</li><li>然后通过<code>render props</code>函数，传入最新的 value，得到最新的 <code>children</code>。</li><li>接下来调和 children。</li></ul><p>fiber 上的 dependencies 如何和 context 建立起关联？就是 <code>readContext</code>这个函数做的事情，而且 useContext 和 contextType 本质上也是</p><h3 id="readContext"><a href="#readContext" class="headerlink" title="readContext"></a>readContext</h3><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberNewContext.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readContext</span> (context, observedBits) &#123;<br>  <span class="hljs-comment">// 创建一个 contextItem</span><br>  <span class="hljs-keyword">const</span> contextItem = &#123;<br>    context,<br>    <span class="hljs-attr">observedBits</span>: resolvedObservedBits,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>  <span class="hljs-comment">// 不存在最后一个 context Dependency</span><br>  <span class="hljs-keyword">if</span> (lastContextDependency === <span class="hljs-literal">null</span>) &#123;<br>    lastContextDependency = contextItem;<br>    currentlyRenderingFiber.<span class="hljs-property">dependencies</span> = &#123;<br>      <span class="hljs-attr">expirationTime</span>: <span class="hljs-title class_">NoWork</span>,<br>      <span class="hljs-attr">firstContext</span>: contextItem,<br>      <span class="hljs-attr">responders</span>: <span class="hljs-literal">null</span>,<br>    &#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 存在的情况</span><br>    lastContextDependency = lastContextDependency.<span class="hljs-property">next</span> = contextItem;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isPrimaryRenderer ? context.<span class="hljs-property">_currentValue</span> : context.<span class="hljs-property">_currentValue2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>readContext 主要做的事情是这样的，首先会创建一个 contextItem，上述说到过 fiber 上回存在多个 <code>dependencies</code>，它们以链表的形式联系到一起，如果不存在最后一个 <code>context dependency</code>，那证明 context dependencies 为空，那么会创建第一个 dependency，如果存在最后一个 dependency，那么 contextItem 会以链表形式保存，并变成最后一个 lastContextDependency。</li></ul><h3 id="多个-Provider-嵌套"><a href="#多个-Provider-嵌套" class="headerlink" title="多个 Provider 嵌套"></a>多个 Provider 嵌套</h3><p>如果有多个 Provider 的情况，那么最后一个 contextValue 会覆盖前一个 contextValue，在开发者脑海中，要有一个定律就是：<code>**Provider**</code><strong>是用来传递 value，而非保存 value。</strong></p><h4 id="contextType-和-useContext"><a href="#contextType-和-useContext" class="headerlink" title="contextType 和 useContext"></a>contextType 和 useContext</h4><h5 id="useContext-原理"><a href="#useContext-原理" class="headerlink" title="useContext 原理"></a>useContext 原理</h5><p><code>useContext</code>原理，调用 useContext 本质上调用 <code>readContext</code>方法。</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnMount</span> = &#123;<br>  <span class="hljs-attr">useContext</span>: readContext<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数组件通过 readContext，将函数组件的 <code>dependencies</code>和当前 context 建立起关联，context 改变，将当前函数组件设置高优先级，促使其渲染。</li></ul><h5 id="contextType-原理"><a href="#contextType-原理" class="headerlink" title="contextType 原理"></a>contextType 原理</h5><p>类组件的静态属性 <code>contextType</code>和 useContext 一样，本质上就是调用 readContext 方法。</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructClassInstance</span>(<span class="hljs-params">workInProgress,ctor,props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 读取 context</span><br>    context = <span class="hljs-title function_">readContext</span>(contextType);<br>  &#125;<br>  <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(props, context);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态属性 contextType，在类组件实例化的时候被使用，本质上也是调用 <code>readContext</code>将 context 和 fiber 上的 <code>dependencies</code>建立起关联。</li></ul><h1 id="4-Context-流程总结"><a href="#4-Context-流程总结" class="headerlink" title="4. Context 流程总结"></a>4. Context 流程总结</h1><ul><li>Provider 传递流程：Provider 的更新，会深度遍历子代 fiber，消费 context 的 fiber 和父级链都会提升更新优先级。对于类组件的 fiber，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork。</li><li>context 订阅流程：<code>contextType</code>，<code>useContext</code>，<code>Consumer</code>会内部调用<code>readContext</code>，readContext 会把 fiber 上的 <code>dependencies</code>属性和 context 对象 建立起关联。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hooks</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/06.Hooks/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/06.Hooks/</url>
    
    <content type="html"><![CDATA[<ul><li>React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。</li><li>React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li><li>React Hooks 为什么不能写在条件语句中？</li><li>useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。</li><li>useEffect 添加依赖项 props.a，为什么 props.a 改变，useEffect 回调函数 create 重新执行。</li><li>React 内部如何区别 useEffect 和 useLayoutEffect，执行时机有什么不同？</li></ul><p>React 为什么会造出 Hooks 呢？</p><p>如果没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI、以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，，每一个类组件都有一套独特的状态，相互之间不能复用，即便是 React 之前出现过 mixin 等复用方式，但是伴随出 mixin 模式下隐式依赖，代码冲突覆盖等问题，也不能成功 React 的中流砥柱的逻辑复用方案。所以 React 放弃了 mixin 这种方式。</p><p>类组件是一种面向对象思想的体现，类组件之间的状态会随之功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一整套函数组件替代类组件的方案，于是 Hooks 也就理所当然的诞生了。</p><p>所以 Hooks 出现本质上原因是：</p><ul><li>让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。</li><li>解决逻辑复用难的问题。</li><li>放弃面向对象编程，拥抱函数式编程。</li></ul><h1 id="1-Hooks-与-Fiber-（workInProgress）"><a href="#1-Hooks-与-Fiber-（workInProgress）" class="headerlink" title="1. Hooks 与 Fiber （workInProgress）"></a>1. Hooks 与 Fiber （workInProgress）</h1><p>类组件的状态比如 state，context，props 本子上是存在类组件对应的 Fiber 上，生命周期比如 componentDidMount，也是以副作用 effect 形式存在的。那么 Hooks 既然赋予了函数组件如上功能，所以 Hooks 本质上是离不开函数组件对应的 Fiber 的。Hooks 可以作为函数组件本身和函数组件对应的 Fiber 之间的沟通桥梁。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks01.png" alt="image.png"></p><p>Hooks 对象本质上是主要以三种处理策略存在 React 中：</p><ul><li><code>ContextOnlyDispatcher</code>：第一种形态是防止开发者在函数组件外部调用 Hooks，所以第一种就是报错形态，只要开发者条用了这个形态下的 Hooks，就会抛出异常。</li><li><code>HooksDispatcherOnMount</code>：第二种形态是函数组件初始化 mount，这个时候的 Hooks 作用就是建立这个桥梁，初次建立其 Hooks 与 Fiber 之间的关系。</li><li><code>HooksDispatcherOnUpdate</code>：第三种形态是函数组件的更新，既然与 Fiber 之间的桥梁已经搭建好了，那么组件再更新，就需要 Hooks 去获取或者更新维护状态。</li></ul><p>Hooks 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnMount</span> = &#123; <span class="hljs-comment">// 函数组件初始化用的 Hooks</span><br>  <span class="hljs-attr">useState</span>: mountState,<br>  <span class="hljs-attr">useEffect</span>: mountEffect,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnUpdate</span> = &#123; <span class="hljs-comment">// 函数组件更新用的 Hooks</span><br>useState； updateState,<br>  <span class="hljs-attr">useEffect</span>: updateEffect,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextOnlyDispatcher</span> = &#123; <span class="hljs-comment">// 当 Hooks 不是函数内部调用的时候，调用这个 Hooks 对象下的 Hooks，所以报错</span><br>  <span class="hljs-attr">useEffect</span>: throwInvalidHookError,<br>  <span class="hljs-attr">useState</span>: throwInvalidHookError,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数组件触发"><a href="#函数组件触发" class="headerlink" title="函数组件触发"></a>函数组件触发</h2><p>所有的函数组件的触发都是在 renderWithHooks 方法中，在 Fiber 调和过程中，遇到 FunctionComponent 类型的 Fiber （函数组件），就会用 updateFunctionComponent 内部就会调用 renderWithHooks。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> currentlyRenderingFiber<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderWithHooks</span> (current, workInProgress, <span class="hljs-title class_">Component</span>, props) &#123;<br>  currentlyRenderingFiber = workInProgress;<br>  workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 每一次执行函数组件之前，先清空状态（用于存放 Hooks 列表）</span><br>  workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空状态（用于存放 effect List）</span><br>  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">memoizedState</span> === <span class="hljs-literal">null</span> ? <span class="hljs-title class_">HooksDispatcherOnMount</span> : <span class="hljs-title class_">HooksDispatcherOnUpdate</span> <span class="hljs-comment">// 判断是初始化组件还是更新组件</span><br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title class_">Component</span>(props, secondArg); <span class="hljs-comment">// 执行我们真正函数组件，所有 Hooks 将依次执行</span><br>  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">ContextOnlyDispatcher</span>; <span class="hljs-comment">// 将 Hooks 变成第一种，防止 Hooks 在函数组件外部调用，调用直接报错。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>workInProgress 正在调和更新函数组件对应的 Fiber 树。</p><ul><li>对于类组件 Fiber，用 memoizedState 保存 state 信息，<strong>对于函数组件 Fiber，用 memoizedState 保存 Hooks 信息。</strong></li><li>对于函数组件 Fiber，updateQueue 存放每个 useEffect&#x2F;useLayoutEffect 产生的副作用组成的链表。在 commit 阶段更新这些副作用。</li><li>然后判断数组是初始化流程还是更新流程，如果初始化用 HooksDispatcherOnMount 对象，如果更新用 HooksDispatcherOnUpdate 对象。函数组件执行完毕，将 Hooks 赋值给 ContextOnlyDispatcher 对象。<strong>引用的 React Hooks 都是从 ReactCurrentDispatcher.current 中的，React 就是通过赋予 current 不同的 Hooks 对象达到监控 Hooks 是否在函数组件内部调用。</strong></li><li>Component（props，secondArg）这个时候函数组件被真正的执行，里面每一个 Hooks 也将依次执行。</li><li>每个 Hooks 内部为什么能够读取当前 Fiber 信息，因为 currentlyRenderingFiber，函数组件初始化已经把当前 fiber 赋值给 currentlyRenderingFiber，每个 Hooks 内部读取的就是 currentlyRenderingFiber 的内容。</li></ul><h2 id="Hooks-初始化-Hooks-如何与-Fiber-建立起关系"><a href="#Hooks-初始化-Hooks-如何与-Fiber-建立起关系" class="headerlink" title="Hooks 初始化 - Hooks 如何与 Fiber 建立起关系"></a>Hooks 初始化 - Hooks 如何与 Fiber 建立起关系</h2><p>Hooks 初始化流程使用的是 mountState，mountEffect 等初始化节点的 Hooks，将 Hooks 和 Fiber 建立起联系，那么是如何建立起关系的呢，每一个 Hooks 初始化都会执行 mountWorkInProgressHook</p><blockquote><p>react0reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountWorkInProgressHook</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = &#123; <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">baseState</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">queue</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>, &#125;;<br>  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 只有一个 hooks</span><br>    currentlyRenderingFiber.<span class="hljs-property">memoizedState</span> = workInProgressHook = hook;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有多个 hooks</span><br>    workInProgressHook = workInProgressHook.<span class="hljs-property">next</span> = hook;<br>  &#125;<br>  <span class="hljs-keyword">return</span> workInProgressHook;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先函数组件对应 Fiber 用 memoizedState 保存 Hooks 信息，每一个 Hooks 执行都会产生一个 Hooks 对象，Hooks 对象中，保存着当前 Hooks 的信息，不同 Hooks 保存的形式不同。每一个 Hooks 通过 next 链表建立起关系。</p><p>假设在一个组件中这么写：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 第一个 Hooks</span><br>  <span class="hljs-keyword">const</span> [ num, setNum ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 第二个 Hooks</span><br>  <span class="hljs-keyword">const</span> dom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 第三个 Hooks</span><br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">current</span>)<br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;dom&#125;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNumber(number + 1)&#125;&gt;&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNumber(num + 1)&#125;&gt;&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么如上四个 Hooks，初始化，每个 Hooks 内部执行 mountWorkInProgressHook，然后每一个 Hook 通过 next 和下一个 Hook 建立起关联，最后在 Fiber 上的结构会变成这样：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks02.png" alt="image.png"></p><h2 id="Hooks-更新"><a href="#Hooks-更新" class="headerlink" title="Hooks 更新"></a>Hooks 更新</h2><p>更新 Hooks 逻辑和 Fiber 的双缓冲树更新差不多，会首先取出 workInProgress.alternate 里面对应的 Hook，然后根据之前的 Hooks 复制一份，形成新的 Hooks 链表关系。这个过程解释了一个问题，就是 <strong>Hooks 规则，Hooks 为什么要通常放在顶部，Hooks 不能写在 if 条件语句中</strong>，因为在更新过程中，如果通过 if 条件语句，增加或者删除 Hooks，在复用 Hooks 过程中，会产生复用 Hooks 状态和当前 Hooks 不一致的问题。举一个例子，还是将如上的 demo 进行修改。</p><p>将第一个 Hooks 变成条件判断形式，具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span> (&#123; showNumber &#125;) &#123;<br>  <span class="hljs-keyword">let</span> number, setNumber<br>  showNumber &amp;&amp; ([ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>) ) <span class="hljs-comment">// 第一个 Hooks</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一次渲染时候 <code>showNumber = true</code>那么第一个 Hooks 会渲染，第二次渲染时候，父组件将 showNumber 设置为 flase，那么第一个 Hooks 将不执行，那么第一个 Hooks 将不执行，那么更新逻辑会变成这样。</p><table><thead><tr><th>Hook 复用顺序</th><th>缓存老的 Hooks</th><th>新的 Hooks</th></tr></thead><tbody><tr><td>第一次 hook 复用</td><td>useState</td><td>useState</td></tr><tr><td>第二次 hook 复用</td><td>useState</td><td>useRef</td></tr></tbody></table><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks03.png" alt="image.png"></p><p>第二次复用时候已经发现 Hooks 类型不同 <code>useState !== useRef</code>，那么已经直接报错了。所以开发的时候一定要注意 Hooks 顺序一致性。</p><p>报错内容：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks04.png" alt="image.png"></p><h1 id="2-状态派发"><a href="#2-状态派发" class="headerlink" title="2. 状态派发"></a>2. 状态派发</h1><p>useState 解决了函数组件没有 state 的问题，让无状态组件有了自己的状态，useState 和 useReducer 原理大同小异，本质上触发更新的函数都是 dispatchAction 。</p><p>比如一段代码中这么些：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">sueState</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>setNumber 本质就是 dispatchAction。首先需要看一下执行 <code>useState(0)</code>本质上做了些什么呢？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; initialState = <span class="hljs-title function_">initialState</span>() &#125; <span class="hljs-comment">// 如果 useState 第一个参数为函数，执行函数得到初始化 state</span><br>  hook.<span class="hljs-property">memoizedState</span> = hook.<span class="hljs-property">baseState</span> = initialState;<br>  <span class="hljs-keyword">const</span> queue = (hook.<span class="hljs-property">queue</span> = &#123; ... &#125;); <span class="hljs-comment">// 负责记录更新的各种状态。</span><br>  <span class="hljs-keyword">const</span> dispatch = (queue.<span class="hljs-property">dispatch</span> = (dispatchAction.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, currentlyRenderingFiber, queue ))) <span class="hljs-comment">// dispatchAction 为更新调度的主要函数</span><br>  <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面的 state 会被当前 Hooks 的 <code>memoizedState</code>保存下来，每一个 useState 都会创建一个 <code>queue</code> 里面保存了更新的信息。</li><li>每一个 useState 都会创建一个更新函数，比如上面的 setNumber 本质上就是 dispatchAction，那么值得注意一点是，当前的 Fiber 被 bind 绑定了固定的参数传入 dispatchAction 和 queue，所以当用户触发 setNumber 的时候，能够直观反映出来自哪个 Fiber 的更新。</li><li>最后把 memoizedState dispatch 返回给开发者使用。</li></ul><p>接下来重点研究一下 <code>dispatchAction</code>，底层是怎么处理更新逻辑的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchAction</span>(<span class="hljs-params">fiber, queue, action</span>) &#123;<br>  <span class="hljs-comment">// 第一步：创建一个 update</span><br>  <span class="hljs-keyword">const</span> update = &#123; ... &#125;<br>  <span class="hljs-keyword">const</span> pending = queue.<span class="hljs-property">pending</span>;<br>  <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第一待更新任务</span><br>    update.<span class="hljs-property">next</span> = update;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 已经有待更新任务</span><br>    update.<span class="hljs-property">next</span> = pending.<span class="hljs-property">next</span>;<br>    pending.<span class="hljs-property">next</span> = update;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fiber === currentlyRenderingFiber) &#123;<br>    <span class="hljs-comment">// 说明当前 fiber 正在发生调和和渲染更新，那么不需要更新</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">expirationTime</span> === <span class="hljs-title class_">NoWork</span> &amp;&amp; (alternate === <span class="hljs-literal">null</span> || alternate.<span class="hljs-property">expirationTime</span> === <span class="hljs-title class_">NowWork</span>)) &#123;<br>      <span class="hljs-keyword">const</span> lastRenderedReducer = queue.<span class="hljs-property">lastRenderedReducer</span>;<br>      <span class="hljs-keyword">const</span> currentState = queue.<span class="hljs-property">lastRenderedState</span>; <span class="hljs-comment">// 上一次的 state</span><br>      <span class="hljs-keyword">const</span> eagerState = <span class="hljs-title function_">lastRenderedReducer</span>(currentState, action); <span class="hljs-comment">// 这一次新的 state</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is</span>(eagerState, currentState)) &#123;<br>       <span class="hljs-keyword">return</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime); <span class="hljs-comment">// 发起调度更新</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一次改变 state，底层会做这些事：</p><ul><li>首先用户每一次调用 dispatchAction（比如如上触发 setNumber）都会先创建一个 update，然后把它放入待更新 pending 队列中。</li><li>然后判断如果当前的 fiber 正在更新，那么也就不需要再更新了。</li><li>反之，说明当前 fiber 没有更新任务，那么会拿出上一次 state 和这一次 state 进行对比，如果相同，那么直接退出更新。如果不相同，那么发起更新调度任务。<strong>这就解释了，为什么函数组件 useState 改变相同的值，组件不更新了。</strong></li></ul><p>接下来就是更新环节，下面模拟一个更新场景。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-function"><span class="hljs-params">num</span>=&gt;</span>num+<span class="hljs-number">1</span>) <span class="hljs-comment">// num = 1</span><br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-function"><span class="hljs-params">num</span>=&gt;</span>num+<span class="hljs-number">2</span>) <span class="hljs-comment">// num = 3</span><br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-function"><span class="hljs-params">num</span>=&gt;</span>num+<span class="hljs-number">3</span>) <span class="hljs-comment">// num = 6</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>handleClick()&#125;&gt;点击 &#123; number &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如上当点击一次按钮，触发了三次 setNumber，等于触发了三次 dispatchAction，那么这三次 update 会在当前 Hooks 的 pending 队列中，然后事件批量更新的概念，会统一合成一次更新。接下来就是组件渲染，那么就到了再一次执行 useState，此时走的是更新流程。那么试想点击 handleClick 最后 state 被更新成 6，那么在更新逻辑中 useState 内部要做的事，就是 <strong>得到最新的 state。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateReducer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第一步把待更新的 pending 队列取出来，合并到 baseQueue</span><br>  <span class="hljs-keyword">const</span> first = baseQueue.<span class="hljs-property">next</span>;<br>  <span class="hljs-keyword">let</span> update = first;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 得到新的 state</span><br>    newState = <span class="hljs-title function_">reducer</span>(newState, action);<br>  &#125; <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);<br>  hook.<span class="hljs-property">memoizedState</span> = newState;<br>  <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当再次执行 useState 的时候，会触发更新 Hooks 逻辑，本质上调用的就是 updateReducer，如上会把更新的队列 pendingQueue 拿出来，合并到 <code>baseQueue</code>，循环进行更新。</li><li>循环更新的流程，说白了就是执行每一个 <code>num=&gt;num+1</code>，得到最新的 state。接下来就可以从 useState 中得到最新的值。</li></ul><p>整个流程：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks05.png" alt="image.png"></p><h1 id="3-处理副作用"><a href="#3-处理副作用" class="headerlink" title="3. 处理副作用"></a>3. 处理副作用</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在 render 阶段，实际没有进行真正的 DOM 元素的增加，删除 React 把想要做的不同操作打成不同的 effectTag，等到 commit 阶段，统一处理这些副作用，包括 DOM 元素增删改，执行一些生命周期等。hooks 中得 useEffect 和 useLayoutEffect 也是副作用，接下来以 effect 为例子，看一下 React 是如何处理 useEffect 副作用得。</p><p>以初始化和更新两个角度来分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountEffect</span>(<span class="hljs-params">create, deps</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-keyword">const</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;<br>  currentlyRenderingFiber.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">UpdateEffect</span> | <span class="hljs-title class_">PassiveEffect</span>;<br>  hook.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">pushEffect</span>(<br>  <span class="hljs-title class_">HookHasEffect</span> | hookEffectTag,<br>    create, <span class="hljs-comment">// useEffect 第一次参数，就是副作用函数</span><br>    <span class="hljs-literal">undefined</span>,<br>    nextDeps, <span class="hljs-comment">// useEffect 第二次参数，deps</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>mountWorkInProgressHook 产生一个 hooks，并和 fiber 建立起关系。</li><li>通过 pushEffect 创建一个 effect，并保存到当前 hooks 的 memoizedState 属性下。</li><li>pushEffect 除了创建一个 effect，还有一个重要作用，就是如果存在多个 effect 或者 layoutEffect 会形成一个副作用链表，绑定在函数组件 fiber 的 updateQueues 上。</li></ul><p>首先对于类组件有 componentDidMount&#x2F;componentDidUpdate 固定的生命周期钩子，用于执行初始化&#x2F;更新的副作用逻辑，但是对于函数组件，可能存在多个 useEffect&#x2F;useLayoutEffect，hook 把这些 effect，独立形成链表结构，在 commit 阶段统一处理和执行。</p><p>如果在一个函数组件中这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第一次 effect&#x27;</span>)<br>&#125;,[ props.<span class="hljs-property">a</span> ])<br><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第二个 effect&#x27;</span>)<br>&#125;, [])<br><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;第三个 effect&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><p>那么在 updateQueue 中，副作用链表会变成如下样子：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/Hooks/hooks06.png" alt="image.png"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新流程：无非判断是否执行下一次的 effect 副作用函数，还有一些细枝末节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateEffect</span>(<span class="hljs-params">create, deps</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">areaHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="hljs-comment">// 如果 deps 项没有发生变化，那么更新 effect list 就可以了，无须设置 hookHasEffect</span><br>    <span class="hljs-title function_">pushEffect</span>(hookEffectTag, create, destroy, nextDeps);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果 deps 依赖项发生改变，赋予 effectTag，在 commit 节点，就会再次执行 我们的 effect</span><br>  currentlyRenderingFiber.<span class="hljs-property">effectTag</span> |= fiberEffectTag;<br>  hook.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">pushEffect</span>(<span class="hljs-title class_">HookHasEffect</span> | hookEffectTag, create, destroy, nextDeps)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断 deps 项有没有发生变化，如果没有发生变化，更新副作用链表就可以了，如果发生变化，更新链表同时，打执行副作用标签：<code>fiber =&gt; fiberEffectTag, hook =&gt; HookHasEffect</code>。在 commit 阶段就会根据这些标签，重新执行副作用。</li></ul><h3 id="不同的effect"><a href="#不同的effect" class="headerlink" title="不同的effect"></a>不同的effect</h3><p>关于<code>EffectTag</code>的思考：</p><ul><li>React 会用不同的 EffectTag 来标记不同的 effect，对于 useEffect 会标记 UpdateEffect | PassiveEffect，UpdateEffect 是证明此次更新需要更新 effect，HookPassive 是 useEffect 的标识符，对于 useLayoutEffect 第一次更新会打上 HookLayout 的标识符。  <strong>React 就是在 commit 阶段，通过标识符，证明是 useEffect 还是 useLayoutEffect，接下来 React 会同步处理 useLayoutEffect。</strong></li><li>如果函数组件需要更新副作用，会标记 UpdateEffect，至于哪个 effect 需要更新，那就看 hooks 上有没有 HookHasEffect，所以会执行组件的副作用钩子。</li></ul><h1 id="4-状态获取与状态缓存"><a href="#4-状态获取与状态缓存" class="headerlink" title="4. 状态获取与状态缓存"></a>4. 状态获取与状态缓存</h1><h2 id="1-对于-ref-处理"><a href="#1-对于-ref-处理" class="headerlink" title="1. 对于 ref 处理"></a>1. 对于 ref 处理</h2><p>useRef 就是创建并维护一个 ref 原始对象。用于获取原生 DOM 或者组件实例，或者保存一些状态。</p><p>创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountRef</span>(<span class="hljs-params">initialValue</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-keyword">const</span> ref = &#123; <span class="hljs-attr">current</span>: initialValue &#125;;<br>  hook.<span class="hljs-property">memoizedState</span> = ref; <span class="hljs-comment">// 创建 ref 对象</span><br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateRef</span>(<span class="hljs-params">initialValue</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>()<br>  <span class="hljs-keyword">return</span> hook.<span class="hljs-property">memoizedState</span> <span class="hljs-comment">// 取出复用 ref 对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上 ref 创建和更新过程，就是 ref 对象的创建和复用过程。</p><h2 id="2-对于-useMemo-的处理"><a href="#2-对于-useMemo-的处理" class="headerlink" title="2. 对于 useMemo 的处理"></a>2. 对于 useMemo 的处理</h2><p>对于 useMemo，逻辑比 useRef 复杂点，但是对于 useState 和 useEffect 简单的多。</p><p>创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountMemo</span>(<span class="hljs-params">nextCreate, deps</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-keyword">const</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;<br>  <span class="hljs-keyword">const</span> nextValue = <span class="hljs-title function_">nextCreate</span>();<br>  hook.<span class="hljs-property">memoizedState</span> = [nextValue, nextDeps];<br>  <span class="hljs-keyword">return</span> nextValue;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>useMemo 初始化会执行第一个函数得到想要缓存的值，将值缓存到 hook 的 memoizedState 上。</li></ul><p>更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMemo</span>(<span class="hljs-params">nextCreate, nextDeps</span>) &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();<br>  <span class="hljs-keyword">const</span> prevState = hook.<span class="hljs-property">memoizedState</span>;<br>  <span class="hljs-keyword">const</span> pervDeps = prevState[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 之前保存的 deps 值</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="hljs-comment">// 判断两次 deps 值</span><br>    <span class="hljs-keyword">return</span> prevState[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">const</span> nextValue = <span class="hljs-title function_">nextCreate</span>(); <span class="hljs-comment">// 如果 deps，发生改变，重新执行</span><br>  hook.<span class="hljs-property">memoizedState</span> = [nextValue, nextDeps];<br>  <span class="hljs-keyword">return</span> nextValue<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>useMemo 更新流程就是对比两次的 dep 是否发生变化，如果没有发生变化，直接返回缓存值，如果发生变化，执行第一个参数函数，重新生成缓存值，缓存下来，供开发者使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调度任务</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/04.%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/04.%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-调度和调和的总结"><a href="#1-调度和调和的总结" class="headerlink" title="1. 调度和调和的总结"></a>1. 调度和调和的总结</h1><h2 id="1-1-调度"><a href="#1-1-调度" class="headerlink" title="1.1 调度"></a>1.1 调度</h2><ul><li><strong>调度</strong>：首先调度目的针对<strong>多个更新任务</strong>的情况，调度让多个任务井然有序的执行，执行任务的同时，也不要影响浏览器的绘制。调度决定着更新任务的执行时期。</li></ul><p><strong>调度的作用：</strong></p><p>在多个任务的情况下，如果一口气执行完所有更新任务，那么就会阻塞浏览器的正常渲染，给用户的体验就是卡住了。那么调度任务就是每一次执行一个任务，然后先让浏览器完成后续的渲染操作，然后在空暇时间，再执行下一个任务。</p><p>在 v18 调度任务还有一些调整。</p><p><code>Legacy</code>模式下：在 v17 及其以下版本，所有的任务都是紧急任务，那么任务都是平等的，所以只需要按照顺序执行任务。</p><p><code>v18 Concurrent</code>模式下：在 v18 模式下，正常紧急的任务都可以看作是会员，一些优先级低的任务比如<code>transtion</code>过渡任务，如果优先级低和优先级高的任务一起来，那么优先会执行其优先级高的任务，正常情况下是执行完所有优先级高的任务才去执行优先级低的任务；但是在一些极端的情况下，怕执行优先级高的任务的时间过长无法执行优先级低的任务，所以设置一个超时时间，达到超时时间，就会直接执行优先级低的任务。</p><h2 id="1-2-调和"><a href="#1-2-调和" class="headerlink" title="1.2 调和"></a>1.2 调和</h2><ul><li><strong>调和</strong>：一旦更新任务执行，那么就会进入调和流程，说白了就是根据 state 的改变，去切实地更新视图。</li></ul><p><strong>调和的作用：</strong></p><p>每一次更新，workLoop会一次检查每一个需要更新的fiber，如果需要更新，那么会更新，如果有子代fiber更新，那么父代fiber本身也会进入到workLoop流程中。</p><p><code>Legacy</code>模式下：在这个模式下，所有的fiber更新，没有优先级的区分，所有的更新都被workLoop依次检查执行。</p><p><code>Concurrent</code>模式下：workLoop在更新低优先级fiber的时候遇到了高优先级更新的fiber，会暂停低优先级的fiber更新而去更新高优先级的fiebr</p><h1 id="2-更新流程分析"><a href="#2-更新流程分析" class="headerlink" title="2. 更新流程分析"></a>2. 更新流程分析</h1><p>在 Legacy 下的 React 应用中，更新本质上有两种：</p><ul><li>第一种就是初始化的时候第一次页面的呈现</li><li>第二种就是初始化完毕，state 的更新，比如点击按钮，触发 <code>setState</code>或者<code>useState</code></li></ul><h2 id="2-1-从-ReactDOM-render-看初始化流程"><a href="#2-1-从-ReactDOM-render-看初始化流程" class="headerlink" title="2.1 从 ReactDOM.render 看初始化流程"></a>2.1 从 ReactDOM.render 看初始化流程</h2><p>在 ReactDOM.render 做的市区是形成一个 Fiber Tree 挂载到 app 上。</p><p>主要流程：</p><blockquote><p>react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMLegacy.js -&gt; legacyRenderSubtreeIntoContainer</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyRenderSubtreeIntoComtainer</span>(<span class="hljs-params"></span><br><span class="hljs-params">parentComponent, <span class="hljs-comment">// null</span></span><br><span class="hljs-params">  children, <span class="hljs-comment">// &lt;App/&gt;根部组件</span></span><br><span class="hljs-params">  container, <span class="hljs-comment">// app dom 元素</span></span><br><span class="hljs-params">  forceHydrate,</span><br><span class="hljs-params">  callback <span class="hljs-comment">// ReactDOM.render 第三个参数回调函数 </span></span><br><span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> root = container.<span class="hljs-property">_reactRootContainer</span><br>    <span class="hljs-keyword">let</span> fiberRoot<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>      <span class="hljs-comment">// 创建 fiber Root</span><br>      root = container.<span class="hljs-property">_reactRootContainer</span> = <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(container, forceHydrate);<br>      fiberRoot = root.<span class="hljs-property">_internalRoot</span>;<br>      <span class="hljs-comment">// 处理 callback 逻辑，这里可以省略</span><br>      <span class="hljs-comment">// 注意初始化这里用的是 unbatch</span><br>      <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 开始更新</span><br>        <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);<br>      &#125;);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用  ReactDOM.render 本质上就是 <code>legacyRenderSubtreeIntoContainer</code> 方法。这个方法的主要做的事情是：</p><ul><li>创建整个应用的<code>FiberRoot</code>。</li><li>然后调用<code>updateContainer</code>开始初始化更新。</li><li>这里注意：用的是<code>unbatch</code>（非批量的情况下），并不是批量更新的<code>batchUpdate</code>。</li></ul><p>接下来看一看<code>updateContainer</code></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberReconciler.js -&gt; updateContainer</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">element, container, parentComponent, callback</span>) &#123;<br>  <span class="hljs-comment">// 计算优先级，在 v16以及以下版本用的是 expirationTime，在 v17 , v18版本，用的是 lane</span><br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(current);<br>  <span class="hljs-title function_">enqueueUpdate</span>(current, update, lane);<br>  <span class="hljs-comment">// 开始调度更新</span><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">scheduleUpdateOnFiber</span>(current, lane, eventTime)<br>&#125;<br></code></pre></td></tr></table></figure><p>updateContainer 主要做了哪些事情：</p><ul><li>首先计算更新优先级 <code>lane</code>，老版本用的是 <code>expirationTime</code>。</li><li>然后创建一个 <code>update</code>，通过<code>enqueueUpdate</code>把当前的 update 放入待更新队列<code>updateQueue</code>中。</li><li>接下来开始调用<code>scheduleUpdateOnFiber</code>，开始进入调度更新流程中。</li></ul><h2 id="2-2-从-useState-setState-看更新流程"><a href="#2-2-从-useState-setState-看更新流程" class="headerlink" title="2.2 从 useState | setState 看更新流程"></a>2.2 从 useState | setState 看更新流程</h2><h3 id="类组件之setState"><a href="#类组件之setState" class="headerlink" title="类组件之setState :"></a>类组件之<code>setState</code> :</h3><p>触发 setState 本质上是调用 <code>enqueueSetState</code>。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js -&gt; enqueueSetState</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst, payload, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);<br>  <span class="hljs-title function_">enqueueUpdate</span>(fiber, update, lane);<br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数组件之useState"><a href="#函数组件之useState" class="headerlink" title="函数组件之useState:"></a>函数组件之<code>useState</code>:</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js -&gt; dispatchAction</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchAction</span>(<span class="hljs-params">fiber, queue, action</span>) &#123;<br>  <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);<br>  <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是初始化，useState，setState最后都是调用<code>scheduleUpdateOnFiber</code>方法。那么这个就是整个更新的入口</p><h2 id="2-3-更新入口-scheduleUpdateOnFiber"><a href="#2-3-更新入口-scheduleUpdateOnFiber" class="headerlink" title="2.3 更新入口 scheduleUpdateOnFiber"></a>2.3 更新入口 scheduleUpdateOnFiber</h2><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; scheduleUpdateOnFiber</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber, lane, eventTime</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">SyncLane</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<br>    (executionContext &amp; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span> &amp;&amp; <span class="hljs-comment">// unbatch 情况，比如初始化</span><br>      (executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span><br>    ) &#123;<br>      <span class="hljs-comment">// 开始同步更新，进入到 workLoop 流程</span><br>      <span class="hljs-title function_">performSyncWorkOnRoot</span>(root);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 进入调度，把任务放入调度中</span><br>      <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);<br>      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) &#123;<br>        <span class="hljs-comment">// 当前的执行任务类型为 NoContext,说明当前任务是非可控的，那么会调用 flushSyncCallbackQueue 方法</span><br>        <span class="hljs-title function_">flushSyncCallbackQueue</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleUpdateOnFiber 的核心逻辑如上，正常情况下，大多数任务都是 <code>SyncLane</code>。即便在异步任务里面触发的更新，比如在 <code>Promise</code> 或者是 <code>setTimeout</code> 里面的更新，也是 <code>SyncLane</code>，两者之间没有太大的联系。所以上述核心代码中，只保留了 <code>SyncLane</code> 的逻辑。</p><p>那么在 <code>scheduleUpdateOnFiber</code> 内部主要做的事情是：</p><ul><li>在<code>unbatch</code>情况下，会直接进入到 performSyncWorkOnRoot，接下来进入到<strong>调和流程</strong>，比如<code>render</code>，<code>commit</code>。</li><li>那么任务是<code>useState</code>和<code>setState</code>，那么会进入到<code>else</code>流程，那么会进入到<code>ensureRootIsScheduled</code>调度流程。</li><li>当前的执行任务类型为<code>NoContext</code>，说明当前任务是非可控的，那么会调用<code>flushSyncCallbackQueue</code>方法。</li></ul><p>通过上面知道了，<strong>performSyncWorkOnRoot</strong> ： 这个方法会直接进入到调和阶段，会从 rootFiber 开始向下遍历。 <strong>ensureRootIsScheduled</strong>  ：会进入到调度流程。 <strong>flushSyncCallbackQueue</strong> ：用于立即执行更新队列里面的任务。</p><p>初始化的更新会通过 unbatchedUpdatedates 包裹，那么<strong>初始化的更新会直接进入调和阶段同步更新，而不会放入到调度任务中</strong>。</p><p><code>**legacy**</code>** 模式下的可控任务和非可控任务。**</p><ul><li>可控任务：对于 React 事件系统中发生的任务，会被标记<code>EventContext</code>，在 batchUpdate api 里面的更新任务，会被标记成<code>BatchedContext</code>，那么这些任务是 React 可以检测到的，所以<code>executionContext !== NoContext</code>，那么不会执行 <code>flushSyncCallbackQueue</code>。</li><li>非可控任务：如果在<strong>延时器（timer）队列</strong>或者<strong>微任务队列（microtask）</strong>，那么这种更新任务，React 是无法控制执行时机的，所以说这种任务是非可控的任务。比如<code>setTimeout</code>和<code>promise</code>里面的更新任务，那么<code>executionContext === NoContext</code>，接下来会执行一次<code>flushSynCallbackQueue</code>。</li></ul><p>流程图如下：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/task01.png" alt="image.png"></p><h1 id="3-进入调度更新"><a href="#3-进入调度更新" class="headerlink" title="3. 进入调度更新"></a>3. 进入调度更新</h1><h2 id="3-1-控制进入调度"><a href="#3-1-控制进入调度" class="headerlink" title="3.1 控制进入调度"></a>3.1 控制进入调度</h2><p>上面非初始化类型的更新任务，那么最终会走到 ensureRootIsScheduled 流程中，所以来分析一下这个方法。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root, currentTime</span>) &#123;<br>  <span class="hljs-comment">// 计算一下执行更新的优先级</span><br>  <span class="hljs-keyword">var</span> newCallbackPriority = <span class="hljs-title function_">returnNextLanesPriority</span>();<br>  <span class="hljs-comment">// 当前 root 上存在的更新优先级</span><br>  <span class="hljs-keyword">const</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;<br>  <span class="hljs-comment">// 如果两者相等，那么说明是在一次更新中，那么将退出</span><br>  <span class="hljs-keyword">if</span>(existingCallbackPriority === newCallbackPriority) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (newCallbackPriority === <span class="hljs-title class_">SyncLanePriority</span>) &#123;<br>    <span class="hljs-comment">// 在正常情况下，会直接进入到调度任务中</span><br>    newCallbackNode = <span class="hljs-title function_">scheduleSyncCallback</span>(performSyncWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 这里先忽略</span><br>  &#125;<br>  <span class="hljs-comment">// 给当前 root 的更新优先级，绑定到最新的优先级</span><br>  root.<span class="hljs-property">callbackPriority</span> = newCallbackPriority;<br>&#125;<br></code></pre></td></tr></table></figure><p>ensureRootIsScheduled 主要做的事情有：</p><ul><li>首先会计算最新的调度更新优先级<code>newCallbackPriority</code>，接下来获取当前 root 上的 <code>callbackPriority</code>判断两者是否相等，如果两者相等，那么将直接退出不会进入调度中。</li><li>如果不相等，那么会真正的进入调度任务<code>scheduleSyncCallback</code>中，注意的是放入调度中的函数就是<strong>调和流程</strong>的入口函数<code>performSyncWorkOnRoot</code>。</li><li>函数最后将 newCallbackPriority 赋值给 callbackPriority。</li></ul><p><strong>什么情况下会存在 existingCallbackPriority &#x3D;&#x3D;&#x3D; newCallbackPriority，退出调度的情况？</strong></p><p>我们注意到一次更新中最后 callbackPriority 会被赋值成 newCallbackPriority。那么如果在正常模式下（非异步）一次更新中触发了多次<code>setState</code>或者<code>useState</code>，那么第一个 setState 进入到 ensureRootIsScheduled 就会有 root.callbackPriority &#x3D; newCallbackPriority，那么接下来如果还有 setState | useState，那么就会退出，将进入调度任务中，<strong>原来这才是批量更新的原理，多次触发更新只有一次会进入调度中</strong>。</p><h2 id="3-2-进入调度任务"><a href="#3-2-进入调度任务" class="headerlink" title="3.2 进入调度任务"></a>3.2 进入调度任务</h2><p>当进入到 scheduleSyncCallback 中会发生什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 如果队列为空</span><br>    syncQueue = [callback];<br>    <span class="hljs-comment">// 放入调度任务</span><br>    immediateQueueCallbackNode = <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<span class="hljs-title class_">Scheduler</span>_ImmediatePriority,flushSyncCallbackQueueImpl);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果任务队列不为空，那么将任务放入队列中</span><br>    syncQueue.<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flushSyncCallbackQueueImpl</code>会真正的执行<code>callback</code>，本质上就是调和函数<code>performSyncWorkOnRoot</code>。</p><p><code>Scheduler_scheduleCallback</code>本质上是通过<code>MessageChannel</code>向浏览器请求下一空闲帧，在空闲帧中执行更新任务。</p><p>scheduleSyncCallback 做的事情如下：</p><ul><li>如果执行队列为空，那么把当前任务放入队列中，然后执行调度任务。</li><li>如果队列不为空，此时已经在调度中，那么不需要执行调度任务，只需要把当前更新放入队列中就可以，调度中心会一个个按照顺序执行更新任务。</li></ul><p>到现在，已经知道了调和更新任务如何进入调度的。也知道了在初始化和改变 state 带来的更新原理。</p><p>接下来有一个问题就是，<strong>比如在浏览器空闲状态下发生一次 state 更新，那么最后一定会进入调度，等到下一次空闲帧执行吗？</strong></p><p>答案是否定的，如果这样，那么就是一种性能的浪费，因为正常情况下，发生更新希望的是在一次事件循环中执行完更新到视图渲染，如果在下一次事件循环中执行，那么更新肯定会延时。但是 <code>React</code> 是如何处理这个情况的呢？</p><h2 id="3-3-空闲期的同步任务"><a href="#3-3-空闲期的同步任务" class="headerlink" title="3.3 空闲期的同步任务"></a>3.3 空闲期的同步任务</h2><p>在没有更新任务空闲期的条件下，为了让更新变成同步的，也就是本次更新不再调度中执行，那么React 对于更新，会用 <code>flushSyncCallbackQueue</code>立即执行更新队列，发起更新任务，<strong>目的就是让任务不延时到下一帧</strong>。但是此时调度会正常执行，不过调度中的任务已经被清空，</p><p>既然不让任务进入调度，而选择同步执行任务，那么调度意义是什么呢?</p><p>调度的目的是处理存在多个更新任务的情况，比如发生了短时间内的连续的点击事件，每次点击事件都会更新 state ，那么对于这种更新并发的情况，第一个任务以同步任务执行，那么接下来的任务将放入调度，等到调度完成后，在下一空闲帧时候执行。</p><h3 id="可控更新任务"><a href="#可控更新任务" class="headerlink" title="可控更新任务"></a>可控更新任务</h3><p>发生一次同步任务之后，React 会让调度执行，但是会立即执行同步任务，原理就是通过 <code>flushSyncCallbackQueue</code>方法。对于可控的更新任务，比如事件系统里的同步的 setState 或者 useState，再比如 batchUpdate，如果此时处理空闲状态，贼内部都会触发一个<code>flushSyncCallbackQueue</code>来立即更新。</p><p><strong>事件系统中的</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; batchedEventUpdates</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn, a</span>) &#123;<br>  <span class="hljs-comment">// 批量更新流程，没有更新状态下，那么直接执行任务</span><br>  <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;<br>  executionContext |= <span class="hljs-title class_">EventContext</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a) <span class="hljs-comment">// 执行事件本身，React 事件再这里执行，useState 和 setState 也会在这里执行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 重置状态</span><br>    executionContext = prevExecutionContext;<br>    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) &#123;<br>      <span class="hljs-comment">// 批量更新流程，没有更新状态下，那么直接执行任务</span><br>      <span class="hljs-title function_">flushSyncCallbackQueue</span>();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**ReactDOM暴露的api **<code>**batchedUpdates**</code></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; batchedUpdates</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdate</span>(<span class="hljs-params">fn, a</span>) &#123;<br>  <span class="hljs-comment">// 和上述流程一样</span><br>  <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) &#123;<br>    <span class="hljs-title function_">flushSyncCallbackQueue</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上可以看到，如果浏览器没有调度更新任务，那么如果发生一次可控更新任务，最后会默认执行一次<code>flushSyncCallbacQueue</code>来让任务同步执行。</p><h3 id="非可控更新任务"><a href="#非可控更新任务" class="headerlink" title="非可控更新任务"></a>非可控更新任务</h3><p>比如在<code>setTimeout</code>或者<code>Promise</code>里面的更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) &#123;<br>  <span class="hljs-comment">/* 执行 flushSyncCallbackQueue ，立即执行更新 */</span><br>  <span class="hljs-title function_">flushSyncCallbackQueue</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>综上这也就说明了，为什么在异步内部的 <code>setState</code> | <code>useState</code> 会打破批量更新的原则，本质上是因为，执行一次 <code>setState</code> | <code>useState</code> 就会触发一次 <code>flushSyncCallbackQueue</code> 立即触发更新，所以就会进入到调和阶段，去真正的更新 fiber 树。</p><h1 id="4-同步异步模式下的更新流程实践"><a href="#4-同步异步模式下的更新流程实践" class="headerlink" title="4. 同步异步模式下的更新流程实践"></a>4. 同步异步模式下的更新流程实践</h1><p>legacy 模式下的更新流程。</p><h2 id="初始化情况"><a href="#初始化情况" class="headerlink" title="初始化情况"></a>初始化情况</h2><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/task02.png" alt="image.png"></p><ul><li>ReactDOM.render -&gt; unbatchContext 开关打开 -&gt; updateContainer。</li><li>updateContainer: scheduleUpdateOnFiber -&gt; performSyncWorkOnRoot -&gt; renderRoot -&gt; commitRoot -&gt; 浏览器绘制。</li><li>unbatchContext 开关关闭。</li></ul><h2 id="同步情况"><a href="#同步情况" class="headerlink" title="同步情况"></a>同步情况</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-comment">// 同步条件下</span><br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  &#123;number&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>当点击按钮的时候，会触发两次<code>setNumber</code>，那么这两次<code>setNumber</code>的更新流程：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/task03.png" alt="image.png"></p><ul><li><strong>事件上下文：</strong>开启事件开关 -&gt; 进入第一次 <code>setNumber</code>。</li><li><strong>第一次</strong><code>setNumber</code><strong>上下文：</strong><code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code>（放入回调函数<code>performSyncWorkOnRoot</code>）。</li><li><strong>第二次</strong><code>setNumber</code><strong>上下文：</strong><code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; 退出</li><li><strong>事件上下文：</strong>关闭事件开关 -&gt; <code>flushSyncCallbackQueue</code>。</li><li><strong>flushSyncCallbackQueue</strong> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code> -&gt; 浏览器绘制。</li></ul><h2 id="异步情况"><a href="#异步情况" class="headerlink" title="异步情况"></a>异步情况</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 异步情况下</span><br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>)<br>  &#125;,<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>两次更新流程图：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/task04.png" alt="image.png"></p><p>整个流程过程：</p><ul><li><strong>事件上下文：</strong>开启事件开关 -&gt; 关闭事件开关 -&gt; flushSyncCallbackQueue（此时更新队列为空）。 </li><li><strong>setTimeout 上下文：</strong> 执行第一次<code>setNumber</code>。 </li><li><strong>第一次</strong><code>setNumber</code><strong>上下文：</strong><code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -&gt; <code>flushSyncCallbackQueue</code> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code>。 </li><li><strong>回到 setTimeout 上下文</strong>：执行第二次 <code>setNumber</code>。 </li><li><strong>第二次 <strong><code>setNumber</code></strong> 上下文</strong>：<code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -&gt; <code>flushSyncCallbackQueue</code> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code>。 </li><li>js执行完毕，浏览器绘制。</li></ul><p>所以这种情况下 render 了两遍。到此为止 legacy 模式下更新流程真相大白。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>调度任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>beginWork和render全流程</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/05.beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/05.beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>组件 A 触发 <code>setState</code>或者<code>useState</code>更新视图，既然 <code>fiber</code>是从 root 开始更新，那么如何找到对应的 A 并 rerender 的呢？</li><li>组件类型 fiber 进行 <code>beginWork</code>就一定会进行 <code>render</code>吗？</li></ul><h1 id="1-state-更新源泉"><a href="#1-state-更新源泉" class="headerlink" title="1. state 更新源泉"></a>1. state 更新源泉</h1><h2 id="1-1-更新的最小单元"><a href="#1-1-更新的最小单元" class="headerlink" title="1.1 更新的最小单元"></a>1.1 更新的最小单元</h2><p>虽然在 React V18 引入订阅外部数据源的 <code>useMutableSource</code>。但是在当前版本的 React 中，视图的更新基本都来源于内部 state 的改变。如果有一个组件 A，如果想要它更新，那么场景中有如下情况：</p><ul><li>组件本身改变 <code>state</code>。函数<code>useState</code>|<code>useReducer</code>，类组件 <code>setState</code> | <code>forceUpdate</code></li><li><code>props</code>改变，由组件更新带来的子组件的更新。</li><li><code>context</code>更新，并且该组件消费了当前 <code>context</code>。</li></ul><p>无论从哪种方式，本质上都是 state 的变化。</p><ul><li>props 改变来源于父级组件的 state 变化。</li><li>context 变化来源于<code>Provider</code>中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li></ul><p><code>state</code> 改变是在组件对应的 fiber 单位上的，<code>function Component</code>或者 <code>Class Component</code>也是两种不同的 fiber 类型，而且 React 底层对它们的处理逻辑也是不同的：</p><ul><li>更新类组件用的是 <code>updateClassComponent</code>，它做的事情是初始化时候实例化类组件，更新的话直接调用 render 得到新的 <code>children</code>；</li><li>更新函数组件用的是 <code>updateFunctionComponent</code>，里面调用 <code>renderWithHooks</code>执行函数组件并依次调用 <code>hook</code>。</li></ul><p>那么在整个 <code>React</code>系统中，能够更新 state 的基本上都在组件层面，换句话说只有组件才能发出更新，比如 <code>div</code>元素 hostComponent 类型的 fiber，它是无法独立的自我更新的，只能依赖于父类的组件更新 state，但是在调和阶段，他也会作为一个任务单元进入到 workLoop 中：</p><ul><li><strong>fiber 是调和过程中的最小单元，每一个需要调和的 fiber 都会进入 workLoop 中。</strong></li><li><strong>而组件是最小的更新单元，React 的更新源于数据层 state 的变化。</strong></li></ul><h2 id="1-2-beginWork-更新源泉"><a href="#1-2-beginWork-更新源泉" class="headerlink" title="1.2 beginWork 更新源泉"></a>1.2 beginWork 更新源泉</h2><p>类组件在 render 阶段的一个重要作用就是产生新的 children，也就是我们常说的 <code>rerender</code>。只有产生新的 children，接下来才能深度遍历 children，改变视图。每一个需要调和的 fiber 都要经历一个过程叫做 beginWork，在 beginWork 流程中将执行上述各种 fiber 的更新函数。</p><p>那么对于组件类型 fiber：进入到 workLoop 中，那么一定会 <code>rerender</code>吗？</p><p>答案是否定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs react">// 子组件 2<br>function Child2() &#123;<br>  return &lt;div&gt;子组件 2&lt;/div&gt;<br>&#125;<br>// 子组件 1<br>function Child1() &#123;<br>  const [num, setNumber] = React.useState(0)<br>  return &lt;div&gt;<br>  子组件 &#123;num&#125;<br>    &lt;button onClick=&#123;() =&gt; setNumber(num + 1)&#125;&gt;按钮1&lt;/button&gt;<br>  &lt;/div&gt;<br>&#125;<br>// 父组件<br>export default function Index() &#123;<br>  const [num, setNumber] = React.useState(0)<br>  return &lt;div&gt;<br>  &lt;p&gt;父组件&#123;num&#125;&lt;/p&gt;<br>    &lt;Child1 /&gt;<br>    &lt;Child2 /&gt;<br>    &lt;button onClick=&#123;() =&gt; setNumber(num+1)&#125;&gt;按钮 2&lt;/button&gt;<br>  &lt;/div&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>场景一</strong>：如上 demo 中，当点击 <code>Child1</code>的 按钮1 的时候，Child1 会渲染，那么 Child1 自然会进入到 <code>beginWork</code>流程中：</p><ul><li>父组件 <code>Index</code>没有更新，会 rerender 吗？ 那么有会进入 <code>beginWork</code>流程吗？</li><li><code>Child2</code>会进入<code>beginWork</code>流程吗？</li><li>如果<code>Index</code>会<code>beginWork</code>，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？</li></ul><p><strong>场景二</strong>：在如上 demo 中，当点击 Index 中的 <strong>按钮2</strong> 的时候：</p><ul><li><code>Index</code>因为本身的 <code>state</code>改变会更新，那么 <code>Child1</code>和<code>Child2</code>为什么会跟着更新。</li></ul><p>开始以一次更新开始，分析调和过程中 beginWork 流程。</p><p>在 v16 版本，任务的优先级用 expirationTime 表示，在 v17 版本被 lane 取缔。</p><ul><li><strong>lane</strong>：更新优先级。（在一次更新任务中，将赋予更新的 fiber 的一个更新优先级 lane）</li><li><strong>childLeanes</strong>：<code>children</code>中更新优先级。（如果当前 fiber 的 child 中有高优先级任务，那么当前 fiber 的 childLanes 等于当前优先级）。</li></ul><h1 id="2-起源：从-state-改变到-scheduleUpdateOnFiber"><a href="#2-起源：从-state-改变到-scheduleUpdateOnFiber" class="headerlink" title="2. 起源：从 state 改变到 scheduleUpdateOnFiber"></a>2. 起源：从 state 改变到 scheduleUpdateOnFiber</h1><p>更新是以 <strong>组件</strong>为粒度，那么调用 <code>useState</code>或者是<code>setState</code>接下来会发生什么呢？</p><p><strong>类组件 setState 更新</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.new.js -&gt; classComponentUpdater</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchReducerAction</span>(<span class="hljs-params">fiber, queue,action</span>) &#123;<br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);<br>  <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>组件更新的本质就是：</p><ul><li>创建一个任务优先级 lane。</li><li>然后进行 scheduleUpdateOnFiber。这个 scheduleUpdateOnFiber 就是整个 React 更新任务的开始。</li></ul><h2 id="2-1-scheduleUpdateOnFiber-开始更新-fiber"><a href="#2-1-scheduleUpdateOnFiber-开始更新-fiber" class="headerlink" title="2.1 scheduleUpdateOnFiber 开始更新 fiber"></a>2.1 scheduleUpdateOnFiber 开始更新 fiber</h2><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; scheduleUpdateOnFiber</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span> (fiber, lane) &#123;<br>  <span class="hljs-comment">// 递归向上标记更新优先级</span><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(fiber, lane);<br>  <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 如果当前 root 确定更新，那么会执行 ensureRootIsScheduled</span><br>  <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleUpdateOnFiber 主要做了两件事：</p><ul><li>通过当前的更新优先级 lane，把当前 fiber 到 rootFiber 的父级链表上的所有优先级都给更新了。</li><li>如果当前 fiber 确定更新，那么会调用 ensureRootIsScheduled。</li></ul><p><strong>那么 markUpdateLaneFromFiberToRoot 如果标记优先级呢？</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; markUpdateLaneFromFiberToRoot</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; sourceFiber 发生 state 变化的fiber ，比如组件 A 触发了 useState ，那么组件 A 对应的 fiber 就是 sourceFiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; lane        产生的更新优先级</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(<span class="hljs-params">sourceFiber, lane</span>) &#123;<br>  <span class="hljs-comment">// 更新当前 fiber 上</span><br>  sourceFiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(sourceFiber.<span class="hljs-property">lanes</span>, lane);<br>  <span class="hljs-comment">// 更新缓存树上的 lanes</span><br>  <span class="hljs-keyword">let</span> alternate = sourceFiber.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) alternate.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanges</span>(alternate.<span class="hljs-property">lanes</span>, lane);<br>  <span class="hljs-comment">// 当前更新的 fiber</span><br>  <span class="hljs-keyword">let</span> node = sourceFiber;<br>  <span class="hljs-keyword">let</span> parent = sourceFiber.<span class="hljs-property">return</span>;<br>  <span class="hljs-keyword">while</span>(parent !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 更新 childLanes 字段</span><br>    parent.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(parent.<span class="hljs-property">childLanes</span>, lane);<br>    <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) &#123;<br>      alternate.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">childLanes</span>, lane);<br>    &#125;<br>    <span class="hljs-comment">// 递归遍历更新</span><br>    node = parent;<br>    parent = parent.<span class="hljs-property">return</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>markUpdateLaneFromFiberToRoot 做的事很重要。</p><ul><li>首先会更新当前 fiber 上的更新优先级。fiber 采用 双缓冲树，所有还要更新当前 fiber 的缓冲树 <code>alternate</code>上的优先级。</li><li>然后会递归向上把父级连上的 childLanes 都更新，更新成当前的任务优先级。</li></ul><p>为什么向上递归更新父级的 childLanes？</p><ul><li>所有的 fiber 是通过一棵 fiber 树关联到一起的，如果组件 A 发生一次更新，React 是从 root 开始遍历更新 fiber 树。</li><li>那么更新过程中需要深度遍历整个 fiber 树吗？当然也不是，那么只有一个组件更新，所有的 fiber 节点都调和无疑是性能上的浪费。</li><li>既然要从头更新，又不想调和整个 fiber 树，那么如何找到更新的组件 A 呢？这个时候 <code>childLanes</code>就派上用场了，如果 A 发生了更新，那么向上递归更新父级链的<code>childLanes</code>，接下来从 Root Fiber 向下调和的时候，发现 childLanes 等于当前更新优先级<code>updateLanes</code>，那么说明它的 child 链上有新的更新任务，则会继续向下调和，反之退出调和流程。</li></ul><p>这样就知道了：</p><p>如果 Index 会 beginWork，React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的。：</p><p><strong>Root Fiber 是通过 childLanes 逐渐向下调和找到需要更新的组件的。</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render01.png" alt="image.png"></p><p>整个 fiber 树 调和流程。</p><ul><li>第一阶段是发生更新，那么产生一个更新优先级 <code>lane</code>。</li><li>第二阶段向上标记 childLanes 过程。</li><li>第三阶段是向下调和过程，为什么 A 会被调和，原因是 A 和 B 是同级，如果父级元素调和，并且向下调和，那么父级的第一级子链上的 fiber 都会进入调和流程。从 fiber 关系上看，Root 先调和的是 child 指针上的 A，然后 A 会退出向下调和，接下来才是 sibling B，接下来 B 会向下调和，通过 childLanes 找到当事人 F，然后 F 会触发 render 更新。这也就解决了Child2 的调和问题。</li></ul><p>通过上述我们知道了如何找到 F 并执行 render 的，还有一个问题，就是 B，E 会向下调和，如果它们是组件，那么会 render 吗？答案是否定的，要记住的是 <strong>调和过程并非 render 过程</strong>，调和过程有可能会触发 render 函数，也有可能只是继续向下调和，而本身不会执行 render。</p><p>既然知道了如何去更新 childLanes，以及更新 childLanes 的意义，我们接着向下分析流程。在 scheduleUpdateOnFiber 中，最后会调用 <code>ensureRootIsScheduled</code>，那么它的作用是什么呢？</p><ul><li>对于 <code>legacy sync</code>模式最后的更新任务是<code>performSyncWorkOnRoot</code>。</li><li>对于<code>Concurrent</code>模式最后的更新任务是<code>performConcurrentWorkOnRoot</code>。</li></ul><p>组件 beginWork 更新流程，所以这里主要以 legacy 模式为主，所以跟着 performSyncWorkOnRoot 流程往下看：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; performSyncWorkOnRoot</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performSyncWorkOnRoot</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-comment">// render 阶段</span><br>  <span class="hljs-keyword">let</span> exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);<br>  <span class="hljs-comment">// commit 阶段</span><br>  <span class="hljs-title function_">commitRoot</span>(root);<br>  <span class="hljs-comment">// 如果有其他的等待中的任务，那么继续更新</span><br>  <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>调和的两大阶段 <code>render</code>和<code>commit</code>都在这个函数中执行。</p><ul><li><code>renderRootSync</code>代表 render 阶段</li><li><code>commitRoot</code>代表 commit 阶段</li><li>当 render 和 commit 阶段执行之后，如果有其他的等待中的任务，那么继续执行调度任务。</li></ul><p>到此为止，一次更新调度任务的初始化工作完成。开始正式进入调和阶段。</p><p>流程图：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render02.png" alt="image.png"></p><h1 id="3-探索：从-workLoop-到-beginWork"><a href="#3-探索：从-workLoop-到-beginWork" class="headerlink" title="3. 探索：从 workLoop 到 beginWork"></a>3. 探索：从 workLoop 到 beginWork</h1><p>beginWork 和组件更新流程，这些主要都发生在 <code>render</code>阶段，所以下面将围绕 <code>renderRootSync</code>展开。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; renderRootSync</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderRootSync</span>(<span class="hljs-params">root, lanes</span>) &#123;<br>  <span class="hljs-title function_">workLoopSync</span>();<br>  <span class="hljs-comment">// workLoop 完毕后，证明所有节点都遍历完毕，那么重置状态，进入 commit 阶段</span><br>  workInProgressRoot = <span class="hljs-literal">null</span>;<br>  workInProgressRootRenderLanes = <span class="hljs-title class_">NoLanes</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>renderRootSync 核心功能：</p><ul><li>执行 <code>workLoopSync</code>。</li><li><code>workLoop</code>完毕后，证明所有节点都遍历完毕，那么重置状态，进入 <code>commit</code>阶段。</li></ul><p><code>workLoopSync</code>在整个 render 流程中充当的角色非常重要，可以把<code>workLoopSync</code>当作一个循环运作的加工器，每一个需要调和的 fiber 可以当作一个零件，每一个零件都需要进入加工器，如果没有待加工的零件，那么加工器才停止运转。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; workLoopSync</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 循环执行 performUnitOfwork，一直到 workInProgress 为空</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如上只要 <code>workInProgress</code>不为<code>null</code>（还有需要调和的 fiber），那么 workLoopSync 会循环调用 performUnitOfWork。</li></ul><p>当 Concurrent 模式下面会通过 <code>shouldYield</code>，来判断有没有过期的任务，有过期任务，会中断 workLoop，那么也就是说明了 <strong>render 阶段是可以被打断的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>  <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>&#125;<br></code></pre></td></tr></table></figure><p>fiber 树是深度优先遍历得到的，在遍历完父节点，接下来就会遍历子节点，在这其中，每一个调和的 fiber 都将作为 <code>workInProgress</code> 进行调和更新。</p><p>无论什么模式，workLoop 的执行单元都是 fiber。而且更新单元的函数叫做 performUnitOfWork。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; performUnitOfWork</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">let</span> next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);<br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>completeUnitOfWork 是向上归并的流程。以组件更新流程为目的，研究 beginWork 流程。</p><p>在介绍 beginWork 之前先来看几个场景：</p><p>假设有一个组件 fiber 链。我们在这个 fiber 链上暂且无视其他类型的 fiber，只保留组件类型的 fiber。结构如下：</p><p>root Fiber – child –&gt; A 组件 – child –&gt; B 组件 – child –&gt; C 组件。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render03.png" alt="image.png"></p><p>主角就是 <strong>组件B</strong>，以组件 B 为参考，来看一下 React 如何调和。那么一次更新就可能有三种场景：</p><p>-<br>场景一：<strong>更新 A 组件 state</strong>，那么 A 触发更新，那么如果 B，C 没有做渲染控制处理（比如 memo PureComponent），那么更新会波动到 B，C，那么 A，B，C 都会 rerender。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render04.png" alt="image.png"></p><p>-<br>场景二：<strong>当更新 B 组件</strong>，那么组件 A fiber 会被标记，然后 A 会调和，但是不会 rerender；组件 B 是当事人，既会进入调和，也会 rerender；组件 C 收到 父组件 B 的影响，会 rerender。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render05.png" alt="image.png"></p><p>-<br>场景三：<strong>当更新 C 组件</strong>，那么 A，B 会进入调和流程，但是不会 rerender，C 是当事人，会调和并 rerender。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render06.png" alt="image.png"></p><p>如上场景本质上都在 <code>beginWork</code> 中进行的，这个 beginWork 是如何处理这些逻辑的。</p><h1 id="4-揭秘：从-beginWork-到组件更新全流程"><a href="#4-揭秘：从-beginWork-到组件更新全流程" class="headerlink" title="4. 揭秘：从 beginWork 到组件更新全流程"></a>4. 揭秘：从 beginWork 到组件更新全流程</h1><h2 id="4-1-beginWork-更新的调度栈"><a href="#4-1-beginWork-更新的调度栈" class="headerlink" title="4.1 beginWork 更新的调度栈"></a>4.1 beginWork 更新的调度栈</h2><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js -&gt; beginWork</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; current         current 树 fiber </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; workInProgress  workInProgress 树 fiber </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; renderLanes     当前的 render 优先级</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) &#123;<br>  <span class="hljs-comment">/* -------------------第一部分-------------------- */</span><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 更新流程</span><br>    <span class="hljs-comment">// current 树上上一次渲染后的 props</span><br>    <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>    <span class="hljs-comment">// workInProgress 树上这一次更新的 props</span><br>    <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>    <br>    <span class="hljs-keyword">if</span> (oldProps !== newProps || <span class="hljs-title function_">hasLegacyContextChanged</span>()) &#123;<br>      didReceiveUpdate = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// props 和 context 没有发生变化，检查是否更新来自自身 context 改变</span><br>      <span class="hljs-keyword">const</span> hasScheduledUpdateOrContext = <span class="hljs-title function_">checkScheduledUpdateOrContext</span>(current, rederLanes)<br>      <span class="hljs-keyword">if</span> (!hasScheduledUpdateOrContext) &#123;<br>        didReceiveUpdate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(current, workInProgress, renderLanes)<br>      &#125;<br>      <span class="hljs-comment">// 这里省略了一些判断逻辑</span><br>      didReceiveUpdate = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">/* -------------------第二部分-------------------- */</span><br>  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 走到这里流程会被调和 | 更新，比如函数执行会执行，类组件会执行 render 。 */</span> <br>  <span class="hljs-keyword">switch</span>(workInProgress.<span class="hljs-property">tag</span>) &#123;<br>      <span class="hljs-comment">// 函数组件的情况</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, resolvedProps, renderLanes) <br>    &#125;<br>    <span class="hljs-comment">// 类组件的情况</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, resolvedProps, renderLanes)<br>    &#125;<br>    <span class="hljs-comment">// 类组件的情况</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, resolbedProps, renderLanes)<br>    &#125;<br>    <span class="hljs-comment">// 元素类型 fiebr &lt;div&gt;,&lt;span&gt;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, renderLanes)<br>    &#125;<br>    <span class="hljs-comment">// 其他 fiber 情况</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上就是 <code>beginWork</code>的全流程，整个流程分为两个阶段。</p><h2 id="4-2-第一阶段"><a href="#4-2-第一阶段" class="headerlink" title="4.2 第一阶段"></a>4.2 第一阶段</h2><p>第一部分，这部分非常重要就是判断更新情况的，上面的三种常见都可以在第一阶段进行判断处理。<code>didReceiveUpdate</code>变量的意义：</p><ul><li><p>didReceiveUpdate：这个变量主要证明当前更新是否来源于父级的更新，那么自身并没有更新。比如更新 B 组件，那么 C 组件也会跟着更新，这个情况下 <code>didReceiveUpdate = true</code>。</p></li><li><p>首先通过 <code>current !== null</code>来判断当前 fiber 是否创建过，如果第一次 mounted，那么 current 为 null，而第一阶段主要针对更新的情况。如果初始化，那么直接跳过第一阶段，<strong>到第二阶段</strong></p></li><li><p>如果是更新流程。那么判断 old Props &#x3D;&#x3D;&#x3D; newProps（源码中还判断了老版本 context 是否变化），那么两者相等。一般会有以下几种情况：</p><ul><li><strong>情况一</strong>：如果 C 组件更新，那么 B 组件被标记 ChildLanes 会进入到 beginWork 调和阶段，但是 B 组件本身 props 不会发生变化。</li><li><strong>情况二</strong>：通过 useMemo 等方式缓存了 React element 元素</li><li><strong>情况三</strong>：就是更新发生在当前组件本身，比如 B 组件发生更新，但是 B 组件的 props 并没有发生变化，所以也会走到这个流程上来。</li></ul></li><li><p>反之如果两者不相等，证明父级 fiber 重新 rerender 导致了 props 改变，此时 didReceiveUpdate &#x3D; true，那么第一阶段完成，<strong>进入第二阶段</strong>。</p></li></ul><p><strong>新老 props 相等</strong>，会有一些处理逻辑：第一个就是调用 <code>checkScheduledUpdateOrContext</code></p><p><strong>checkScheduledUpdateOrContext</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js -&gt; checkShceduledUpdateOrContext</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScheduledUpdateOrContext</span>(<span class="hljs-params">current, renderLanes</span>) &#123;<br>  <span class="hljs-keyword">const</span> updateLanes = current.<span class="hljs-property">lanes</span>;<br>  <span class="hljs-comment">// 这种情况说明当前更新</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(updateLanes, renderLanes)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果该 fiber 消费了 context，并且 context 发生了改变</span><br>  <span class="hljs-keyword">if</span> (enableLazyContextPropagation) &#123;<br>    <span class="hljs-keyword">const</span> dependencies = current.<span class="hljs-property">dependencies</span>;<br>    <span class="hljs-keyword">if</span> (dependencies !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">checkIfContextChanged</span>(dependencies)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当新老 props 相等情况，首先会检查当前 fiber 的 <code>lane</code> 是否等于 <code>updateLanes</code>，如果相等，那么证明更新来源当前 fiber，比如 B 组件发生更新，那么会走这里（情况三）。当然期间也会判断是否有消费 <code>context</code> 并发生了变化。最后返回状态 hasScheduledUpdateOrContext 。</li></ul><p>如果 <code>hasScheduledUpdateOrContext</code> 为 false，证明当前组件没有更新，也没有 context 上的变化，那么还有一种情况就是 child 可能有更新，但是当前 fiber 不需要更新（情况一）。那么会直接返回 <code>attemptEarlyBailoutIfNoScheduledUpdate</code> ，<strong>退出第二阶段</strong></p><p>attemptEarlyBailoutIfNoScheduledUpdate 这个函数会处理部分 Context 逻辑，但是最重要的是调用了 <strong><code>bailoutOnAlreadyFinishedWork</code></strong> 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js -&gt; bailoutOnAlreadyFinishedWork</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(<span class="hljs-params">current,workInProgress,renderLanes</span>)&#123;<br>     <span class="hljs-comment">/* 如果 children 没有高优先级的任务，说明所有的 child 都没有更新，那么直接 返回，child 也不会被调和  */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="hljs-property">childLanes</span>)) &#123;<br>      <span class="hljs-comment">/* 这里做了流程简化 */</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <br>    &#125;<br>    <span class="hljs-comment">/* 当前fiber没有更新。但是它的children 需要更新。  */</span><br>    <span class="hljs-title function_">cloneChildFibers</span>(current, workInProgress);<br>    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bailoutOnAlreadyFinishedWork 流程非常重要。它主要做了两件事。</p><ul><li>首先通过 includesSomeLane 判断 childLanes 是否是高优先级任务，如果不是，那么所有子孙 fiber 都不需要调和 ，那么直接返回 null，child 也不会被调和。</li><li>如果 childLanes 优先级高，那么证明 child 需要被调和，但是当前组件不需要，所以会克隆一下 children，返回 children ，那么本身不会 <code>rerender</code>。</li></ul><p>到这里第一阶段完成了，完成了组件更新流程的所有情况。第一阶段完成会进入到更新的第二阶段。</p><h2 id="4-3-第二阶段"><a href="#4-3-第二阶段" class="headerlink" title="4.3 第二阶段"></a>4.3 第二阶段</h2><p>从 beginWork 的源码中可以看到，第二阶段就是更新 fiber，比如是函数组件，就会调用 <code>updateFunctionComponent</code>，类组件就调用 <code>updateClassComponent</code>，然后进行 rerender 了。</p><p>以上述中的 <strong>组件B</strong>为例子，强化以下更新流程。</p><p><strong>场景一</strong>：当更新 A 的时候，那么 A 组件的 fiber 会进入调和流程，会执行 render 形成新的组件 B 对应的 element 元素，接下来调和 B，因为 B 的 newProps 不等于 oldProps，所以会 didReceiveUpdate &#x3D; true，然后更新组件，也会触发 render。（这里都是默认没有渲染控制的场景，比如 memo PureComponent 等），这样也就解决了文章开头的问题四。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render07.png" alt="image.png"></p><p><strong>场景二</strong>：当更新 B 的时候，那么 A 组件会标记 childLanes，所以 A 会被调和，但是不会 render，然后到了主角 B，B 由于新老 props 相等，所以会 <code>checkScheduledUpdateOrContext</code>流程，判断 lane 等于 renderLanes，检查到 lane 等于 renderLane，所以会执行更新，触发 render。C 组件也跟着更新。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render08.png" alt="image.png"></p><p><strong>场景三</strong>：当更新 C 的时候，那么 A 和 B 组件会标记 childLanes，所以 A 和 B 会被调和，但是不会更新，然后到 C，C 会走正常流程。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render09.png" alt="image.png"></p><p><strong>场景四</strong>：还有一种情况，什么时候 B 会跳出调和流程呢？</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render10.png" alt="image.png"></p><p>到此为止完成了整个更新流程。</p><h1 id="5-beginWork-流程图"><a href="#5-beginWork-流程图" class="headerlink" title="5. beginWork 流程图"></a>5. beginWork 流程图</h1><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B/render11.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>beginWork和render全流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调和与fiber</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/03.%E8%B0%83%E5%92%8C%E4%B8%8Efiber/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/03.%E8%B0%83%E5%92%8C%E4%B8%8Efiber/</url>
    
    <content type="html"><![CDATA[<ul><li>什么是 fiber ？Fiber 架构解决了什么问题？</li><li>Fiber root 和 root fiber 有什么区别？</li><li>不同 fiber 之间如何建立起关联的？</li><li>React 调和流程？</li><li>两大阶段 commit 和 render 都做了哪些事情？</li><li>什么是双缓冲树？有什么作用？</li><li>Fiber 深度遍历流程？</li><li>Fiber 的调和能中断吗？如何中断？</li></ul><h1 id="什么是-fiber？"><a href="#什么是-fiber？" class="headerlink" title="什么是 fiber？"></a>什么是 fiber？</h1><p>Fiber 的英文是 ‘纤维’，fiber 诞生在 <code>React v16</code>版本，整个 React 团队花费两年时间重构 fiber 架构，目的就是解决大型 React 应用卡顿；fiber 在 React 中是最小粒度的执行单元，无论 React 还是 Vue，在遍历更新每一个节点的时候都不是用的真实 DOM，都是采用虚拟 DOM，所以可以理解成 fiber 就是 React 的虚拟 DOM。</p><h2 id="为什么要用-fiber？"><a href="#为什么要用-fiber？" class="headerlink" title="为什么要用 fiber？"></a>为什么要用 fiber？</h2><p>在 <code>React v15</code> 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互的体验就是卡顿。</p><p><code>React v16</code>为了解决卡顿问题引入了 fiber，为什么它能解决卡顿，更新 fiber 的过程叫做 <code>Reconciler</code>（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间<code>expirationTime</code>（v 17 版本叫做优先级 <code>lane</code>）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（reflow），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 <code>scheduler</code>（调度器），再次请求执行单元上来，这样就能本质上中断了渲染，提高了用户体验。</p><h2 id="全面认识-Fiber"><a href="#全面认识-Fiber" class="headerlink" title="全面认识 Fiber"></a>全面认识 Fiber</h2><h3 id="1-element，fiber，-dom-三者的关系"><a href="#1-element，fiber，-dom-三者的关系" class="headerlink" title="1. element，fiber， dom 三者的关系"></a>1. element，fiber， dom 三者的关系</h3><ul><li>element 是 React 视图层在代码层级上的表象，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props， children 等信息。</li><li>DOM 是元素在浏览器上给用户直观的表象。</li><li>fiber 可以说是 element 和真实 DOM 之间的交流枢纽站，一方面每一个类型 element 都会有一个与之对应的 fiebr 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。</li></ul><p>结构图：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber01.png" alt="image.png"></p><p>element 与 fiber 之间的对应关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 对应函数组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 对应的类组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>;                <span class="hljs-comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>;              <span class="hljs-comment">// 对应  ReactDOM.createPortal 产生的 Portal </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;           <span class="hljs-comment">// dom 元素 比如 &lt;div&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;                <span class="hljs-comment">// 文本节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;                <span class="hljs-comment">// 对应 &lt;React.Fragment&gt; </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;                    <span class="hljs-comment">// 对应 &lt;React.StrictMode&gt;   </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;         <span class="hljs-comment">// 对应 &lt;Context.Consumer&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 对应 &lt;Context.Provider&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;             <span class="hljs-comment">// 对应 React.ForwardRef</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;               <span class="hljs-comment">// 对应 &lt;Profiler/ &gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;      <span class="hljs-comment">// 对应 &lt;Suspense&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;          <span class="hljs-comment">// 对应 React.memo 返回的组件</span><br></code></pre></td></tr></table></figure><h3 id="2-fiber-保存了哪些信息？"><a href="#2-fiber-保存了哪些信息？" class="headerlink" title="2. fiber 保存了哪些信息？"></a>2. fiber 保存了哪些信息？</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag; <span class="hljs-comment">// fiber 标签 证明是什么类型的 fiber 。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key; <span class="hljs-comment">// key 调和子节点的时候用到。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// dom 元素对应的元素类型，比如 div，组件指向组件对应的类或者函数。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向对应的真实 dom 元素，类组件指向组件实例，可以被 ref 获取。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向父级 fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向子级 fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向兄弟 fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 索引</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ref 指向， ref 函数，或者 ref 对象。</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps; <span class="hljs-comment">// 在一次更新中，代表 element 创建</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 记录上一次更新完毕后的 props</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类组件存放 setState 更新队列，函数组件存放</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memeoizedState</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类组件保存 state 信息，函数组件保存 hooks 信息，dom 元素为 null</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependences</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// context 或是时间的依赖项</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode; <span class="hljs-comment">// 描述 fiber 树的模式，比如 ConcurrentMode 模式</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>; <span class="hljs-comment">// effect标签，用于收集 effectList</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个 effect</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 第一个 effect</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 最后一个 effect</span><br>  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationTime</span> = <span class="hljs-title class_">NoWork</span>; <span class="hljs-comment">// 通过不同过期时间，判断任务是否过期，在 v17 版本用 Lane 表示。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 双缓存树，指向缓存的 fiber。更新阶段，两棵树互相交替。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-每一个-Fiber-是如何建立起关联的？"><a href="#3-每一个-Fiber-是如何建立起关联的？" class="headerlink" title="3. 每一个 Fiber 是如何建立起关联的？"></a>3. 每一个 Fiber 是如何建立起关联的？</h3><p>每一个 fiber 是通过 return，child，sibling 三个属性建立起联系的。</p><ul><li>return：指向父级 Fiber 节点。</li><li>child：指向子 Fiber 节点。</li><li>sibling：指向兄弟 Fiber 节点</li></ul><p>比如项目中元素结构是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">666</span> &#125;<br>handleClick=<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">number</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    hello, world</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点赞数量： &#123; this.state.number &#125;👍<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.handleClick</span> &#125; &gt;</span>点赞<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fiber对应的关系如下：</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber02.png" alt="image.png"></p><h1 id="Fiber-更新机制"><a href="#Fiber-更新机制" class="headerlink" title="Fiber 更新机制"></a>Fiber 更新机制</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><h3 id="第一步：创建-fiberRoot-和-rootFiber"><a href="#第一步：创建-fiberRoot-和-rootFiber" class="headerlink" title="第一步：创建 fiberRoot 和 rootFiber"></a>第一步：创建 fiberRoot 和 rootFiber</h3><ul><li><code>fiberRoot</code>：首次构建应用，创建一个 fiberRoot，作为整个 React 应用的根基。</li><li><code>rootFiber</code>：如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有很多 ReactDOM.render 创建的 rootFiber，但是只能由一个 fiberRoot（应用根节点）。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Index</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>));<br></code></pre></td></tr></table></figure><p>第一次被挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberRoot.js</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberRoot</span>(<span class="hljs-params">containerInfo, tag</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 root</span><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberRootNode</span>(containerInfo, tag)<br>  <span class="hljs-keyword">const</span> rootFiber = <span class="hljs-title function_">createHostRootFiber</span>(tag);<br>  root.<span class="hljs-property">current</span> = rootFiber<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber03.png" alt="image.png"></p><h3 id="第二步：workInProgress-和-current"><a href="#第二步：workInProgress-和-current" class="headerlink" title="第二步：workInProgress 和 current"></a>第二步：workInProgress 和 current</h3><p>经过第一步的处理，开始到正式渲染阶段，会进入 beginwork 流程，在讲渲染流程之前，要先弄明白两个概念：</p><ul><li>workInProgress 是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。</li><li>current：正在视图层渲染的树叫做 current 树。</li></ul><p>接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（rootFiber）的<code>alternate</code>作为 workInProgress，如果没有 alternate （初始化的 rootFiber 是没有 alternate），那么创建一个 fiber 作为 workInProgress。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">currentFiber.<span class="hljs-property">alternate</span> = workInProgressFiber<br>workInProgressFiber.<span class="hljs-property">alternate</span> = currentFiber<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber04.png" alt="image.png"></p><h3 id="第三步：深度调和子节点，渲染视图"><a href="#第三步：深度调和子节点，渲染视图" class="headerlink" title="第三步：深度调和子节点，渲染视图"></a>第三步：深度调和子节点，渲染视图</h3><p>接下来会按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。</p><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber05.png" alt="image.png"></p><p>最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。</p><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber06.png" alt="image.png"></p><h2 id="2-更新"><a href="#2-更新" class="headerlink" title="2. 更新"></a>2. 更新</h2><p>对于上述 demo ，开发者点击一次按钮发生更新，接下来会发生什么呢？首先会走如上的逻辑，重新创建一棵 workInProgress 树，复用当前 current 树上的 alternate，作为新的 workInProgress，由于初始化 rootFiber 有 alternate，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgress 再次变成 current 树。</p><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber07.png" alt="image.png"></p><p>如果如上一次发生一次点击，会发生什么？</p><p>如果进行下一次更新，那么会将 current 的 alternate 作为基础（如图右树），复制一份作为 workInProgress，然后进行更新。</p><h3 id="双缓冲树"><a href="#双缓冲树" class="headerlink" title="双缓冲树"></a>双缓冲树</h3><p>canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做<strong>双缓存</strong>。</p><p>React 用 workInProress 树（内存中构建的树）和 current（渲染树）来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两棵树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一棵树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。</p><h1 id="两大阶段：render-和-commit"><a href="#两大阶段：render-和-commit" class="headerlink" title="两大阶段：render 和 commit"></a>两大阶段：render 和 commit</h1><p>render 阶段和 commit 阶段是整个 fiber Reconciler 的核心，接下来研究一下两个阶段能做些什么？</p><p>整个 fiber 的遍历开始 - workLoop：</p><h2 id="1-render-阶段"><a href="#1-render-阶段" class="headerlink" title="1. render 阶段"></a>1. render 阶段</h2><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span>(workInProgress !== <span class="hljs-literal">null</span>) &#123;<br>    workInProgress = <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。</p><p>perfromUnitOfWork 包括两个阶段 beginWork 和 completeWork。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params"></span>) &#123;<br>  next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, renderExpirationTime)<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    next = <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>beginWork</code>：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例化组件，diff 调和子节点，打不同 effectTag。</p><p><code>completeUnitOfWork</code>：是向上归并的过程，如果由兄弟节点，会返回 sibling 兄弟，没有返回 return 父级，一直返回 fiberRoot，期间可以形成 effectList，对于初始化流程会创建 DOM，对于 DOM 元素进行事件收集，处理 style，className 等。</p><p>这么一上一下，构成了整个 fiber 树的调和。</p><h3 id="向下调和-beginWork"><a href="#向下调和-beginWork" class="headerlink" title="向下调和 beginWork"></a>向下调和 beginWork</h3><p>beginwork 到底做了些什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">current, workInProgress</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>: &#123; <span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件</span><br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<span class="hljs-comment">//对应函数组件</span><br>      <span class="hljs-comment">//....</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:&#123;  <span class="hljs-comment">//类组件</span><br>      <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:&#123;<br>      <span class="hljs-comment">//...  </span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>beginWork 的作用：</p><ul><li>对于组件，执行部分生命周期，执行 render，得到最新的 children。</li><li>向下遍历调和 children，复用 oldFiber（diff 算法）</li><li>打不同的副作用标签 effectTag，比如类组件的生命周期，或者元素的增加，删除，更新。</li></ul><h4 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h4><p>React 是如何调和子节点的：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params">current, workInProgress</span>) &#123;<br>  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 初始化子代 fiber</span><br>  workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">mountChildFibers</span>(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderExpirationTime)<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 更新流程，diff children 将在这里进行</span><br>    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, current.<span class="hljs-property">child</span>, nextChildren, renderExporationTime) <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="EffectTag："><a href="#EffectTag：" class="headerlink" title="EffectTag："></a>EffectTag：</h4><p>常用的 effectTag。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Placement</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0000000000010</span>;  <span class="hljs-comment">// 插入节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Update</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0000000000100</span>;  <span class="hljs-comment">// 更新fiber</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Deletion</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000001000</span>;  <span class="hljs-comment">// 删除fiebr</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Snapshot</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000100000000</span>;  <span class="hljs-comment">// 快照</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Passive</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b0001000000000</span>;  <span class="hljs-comment">// useEffect的副作用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000100000</span>;  <span class="hljs-comment">// setState的 callback</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ref</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b0000010000000</span>;  <span class="hljs-comment">// ref</span><br></code></pre></td></tr></table></figure><h3 id="向上归并-completeUnitOfWork"><a href="#向上归并-completeUnitOfWork" class="headerlink" title="向上归并 completeUnitOfWork"></a>向上归并 completeUnitOfWork</h3><p>completeUnitOfWork 的流程是自下向上的，那么 completeUnitOfWork 过程主要做些什么呢？</p><ul><li>首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点保存在一条被称为 effectList 的单向链表中。在 commit 阶段，将不需要再遍历每一个 fiber，只需要执行更新 effectList 就可以了。</li><li>completeWork 阶段对于组件处理 context；对于元素标签初始化，会创建真实 DOM，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props，比如事件收集，style，className 处理。</li></ul><h4 id="调和顺序"><a href="#调和顺序" class="headerlink" title="调和顺序"></a>调和顺序</h4><p>那么上述写的demo片段，在初始化或者一次更新中调和顺序是怎样的呢？</p><ul><li>beginWork    -&gt; rootFiber</li><li>beginWork    -&gt; Index fiber</li><li>beginWork    -&gt; div fiber</li><li>beginWork    -&gt; hello,world fiber</li><li>completeWork -&gt; hello,world fiber (completeWork返回sibling)</li><li>beginWork    -&gt; p fiber</li><li>completeWork -&gt; p fiber</li><li>beginWork    -&gt; button fiber</li><li>completeWork -&gt; button fiber (此时没有sibling，返回return)</li><li>completeWork -&gt; div fiber</li><li>completeWork -&gt; Index fiber</li><li>completeWork -&gt; rootFiber  (完成整个workLoop)</li></ul><h2 id="2-commit-阶段"><a href="#2-commit-阶段" class="headerlink" title="2. commit 阶段"></a>2. commit 阶段</h2><ul><li>一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount，函数组件的 useEffect，useLayoutEffect；</li><li>另一方面就是在一次更新中，添加节点（<code>Placement</code>），更新节点（<code>Update</code>），删除节点（<code>Deletion</code>），还有就是一些细节的处理，比如 ref 的处理。</li></ul><p>commit 细分可以分为：</p><ul><li><code>Before mutation</code>阶段（执行 DOM 操作前）</li><li><code>mutation</code>阶段（执行 DOM 操作）</li><li><code>layout</code>阶段（执行 DOM 操作后）</li></ul><h3 id="Before-mutation"><a href="#Before-mutation" class="headerlink" title="Before mutation"></a>Before mutation</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.<span class="hljs-property">effectTag</span>;<br>    <span class="hljs-keyword">if</span> ((effectTag &amp; <span class="hljs-title class_">Snapshot</span>) !== <span class="hljs-title class_">NoEffect</span>) &#123;<br>      <span class="hljs-keyword">const</span> current = nextEffect.<span class="hljs-property">alternate</span>;<br>      <span class="hljs-comment">// 调用 getSnapshotBeforeUpdates</span><br>      <span class="hljs-title function_">commmitBeforeMutationEffectOnFiber</span>(current, nextEffect);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((effectTag &amp; <span class="hljs-title class_">Passive</span>) !== <span class="hljs-title class_">NoEffect</span>) &#123;<br>      <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalPriority</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">flushPassiveEffects</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;);<br>    &#125;<br>    nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Before mutation 阶段做的事主要有以下内容：</p><ul><li>因为 Before mutation 还没修改真实的 DOM，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate，那么会执行这个生命周期。</li><li>会异步调用 useEffect，useEffect 采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。</li></ul><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffects</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (effect &amp; <span class="hljs-title class_">Ref</span>) &#123; <span class="hljs-comment">// 置空 Ref</span><br>      <span class="hljs-keyword">const</span> current = nextEffect.<span class="hljs-property">alternate</span>;<br>      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-title function_">commitDetachRef</span>(current);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (primaryEffectTag) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Placement</span>: &#123;&#125; <span class="hljs-comment">// 新增元素</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Update</span>: &#123;&#125;    <span class="hljs-comment">// 更新元素</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Deletion</span>: &#123;&#125;  <span class="hljs-comment">// 删除元素</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mutation 阶段做的事情有：</p><ul><li>置空 ref</li><li>对新增元素，更新元素，删除元素。进行真实的 DOM 操作。</li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffects</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> effectTag = nextEffect.<span class="hljs-property">effectTag</span>;<br>    <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(root, current, nextEffect, committedExpirationTime)<br>    <span class="hljs-keyword">if</span> (effectTag &amp; <span class="hljs-title class_">Ref</span>) &#123;<br>      <span class="hljs-title function_">commitAtachRef</span>(nextEffect);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Layout 阶段 DOM 已经更新完毕，Layout 做的事情有：</p><ul><li>commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的 callback，对于函数组件会执行 useLayoutEffect 钩子</li><li>如果有 ref，会重新赋值 ref。</li></ul><p>对于 commit 阶段主要做的事情就是执行 effectList，更新 DOM，执行生命周期，获取 ref 等操作。</p><h2 id="调和-异步调度-流程总图"><a href="#调和-异步调度-流程总图" class="headerlink" title="调和 + 异步调度 流程总图"></a>调和 + 异步调度 流程总图</h2><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%92%8C%E4%B8%8Efiber/fiber08.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>调和与fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调度与时间片</title>
    <link href="/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/02.%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/"/>
    <url>/2023/08/26/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/02.%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-React-调度"><a href="#1-React-调度" class="headerlink" title="1. React 调度"></a>1. React 调度</h1><p>浏览器的 GUI 渲染线程 和 JS 引擎线程是相互排斥的：</p><p>比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。</p><p><strong>问题：</strong></p><ul><li>异步调度原理？</li><li>React 为什么不用 settimeout？</li><li>说一说 React 的时间分片？</li><li>React 如果模拟 requestIdleCallback?</li><li>简述一下调度流程？</li></ul><h2 id="1-1-异步调度"><a href="#1-1-异步调度" class="headerlink" title="1.1 异步调度"></a>1.1 异步调度</h2><p><code>v15</code> 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。</p><p>如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue  能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React  无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。</p><p>React 似乎无法打破从 root  开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React  的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue  更快的响应，更精确的更新范围，React 选择更好的用户体验。而今天即将讲的调度（ Scheduler ）就是具体的实现方式。</p><h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><p>React 如何让浏览器控制 React 更新呢？首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js，调用 requestAnimation，布局 Layout，绘制 Paint，在一帧执行后，如果没有其他事件，那么浏览器会进入休息事件，那么有的一些不是特别紧急 React 更新，就可以执行了。</p><p>首先是<strong>如何知道浏览器有空闲时间？</strong></p><p>requestIdleCallback 是谷歌浏览器提供的一个 API，在浏览器有空余的时间，浏览器就会调用requestIdleCallback 的回调。</p><p>requestIdleCallback 的基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">requestIdleCallback</span>(callback,&#123; timeout &#125;)<br></code></pre></td></tr></table></figure><ul><li>callback 回调，浏览器空余时间执行回调函数。</li><li>timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。</li></ul><p>React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。</p><ul><li><code>Immediate</code> -1 需要立刻执行</li><li><code>UserBlocking</code>250ms 超时时间250ms，一般指的时用户交互。</li><li><code>Normal</code> 5000ms 超时时间 5s，不需要直观立刻变化的任务，比如网络请求。</li><li><code>Low</code>10000ms 超时时间 10s，肯定要执行的任务，但是可以放在最后处理。</li><li><code>Idle</code>一些没有必要的任务，可能不会执行。</li></ul><p>React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，</p><p>等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/schedule01.png" alt="image.png"></p><h3 id="模拟-requestIdleCallback"><a href="#模拟-requestIdleCallback" class="headerlink" title="模拟 requestIdleCallback"></a>模拟 requestIdleCallback</h3><p>requestIdleCallback 目前只有谷歌浏览器支持，为了兼容每个浏览器，React 需要自己实现一个 requestIdleCallback，那么就必须具备两个条件：</p><ul><li>实现这个 requestIdleCallback，可以主动让出主线程，让浏览器去渲染视图。</li><li>一次时间循环只执行一次，因为执行一个以后，还会请求下一次的时间片。</li></ul><p>能满足上述条件的，就只有 <strong>宏任务</strong>，宏任务是在下次时间循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务，首先看一下两种满足情况的宏任务。</p><p><strong>setTimeout(fn, 0)</strong></p><p><code>setTimeout(fn, 0)</code> 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimtout(fn, 0) 时，最后间隔时间会变成 4 ms 左右，而不是最初的 1 ms，所以 React 优先选择的并不是 setTimeout 实现方案。</p><p>模拟 setTimeout 4 ms 延时的真实场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span> <br><span class="hljs-keyword">let</span> nowTime = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-keyword">let</span> timer<br><span class="hljs-keyword">const</span> poll = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> lastTime = nowTime<br>        nowTime = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;递归setTimeout(fn,0)产生时间差：&#x27;</span> , nowTime -lastTime )<br>        <span class="hljs-title function_">poll</span>()<br>    &#125;,<span class="hljs-number">0</span>)<br>    time++<br>    <span class="hljs-keyword">if</span>(time === <span class="hljs-number">20</span>) <span class="hljs-built_in">clearTimeout</span>(timer)<br>&#125;<br><span class="hljs-title function_">poll</span>()<br></code></pre></td></tr></table></figure><p>效果：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/schedule02.png" alt="image.png"></p><h3 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h3><p>为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16 ms。也就是这 16 ms 要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的性能浪费就足足有 4ms，react 团队应该是注意到这 4 ms 有点过于铺张浪费，所以才采用了一个新的方式，那就是 <code>MessageChannel</code>。</p><p>MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。</p><ul><li>MessageChannel.port1 只读返回 channel 的 port1 。</li><li>MessageChannel.port2 只读返回 channel 的 port2 。</li></ul><p>模拟 MessageChannel 触发异步宏任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> scheduleHostCallback = <span class="hljs-literal">null</span><br><span class="hljs-comment">// 建立一个消息通道</span><br><span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-comment">// 建立一个 port 发送消息</span><br><span class="hljs-keyword">var</span> port = channel.<span class="hljs-property">port2</span>;<br><br>channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 执行任务</span><br>  <span class="hljs-title function_">scheduleHostCallback</span>()<br>  <span class="hljs-comment">// 执行完毕，清空任务</span><br>  scheduleHostCallback = <span class="hljs-literal">null</span><br>&#125;;<br><span class="hljs-comment">// 向浏览器请求执行更新任务</span><br>requestHostCallback = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>  scheduledHostCallback = callback;<br>  <span class="hljs-keyword">if</span> (!isMessageLoopRunning) &#123;<br>    isMessageLoopRunning = <span class="hljs-literal">true</span>;<br>    port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在一次更新中，React 会调用 requestHostCallback，把更新任务赋值给 scheduledHostCallback，然后 port2 向 port1 发起 postMessage 消息通知。</li><li>port1 会通过 onmessage，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback，然后置空 scheduledHostCallback，借此达到异步执行目的。</li></ul><h2 id="1-2-异步调度原理"><a href="#1-2-异步调度原理" class="headerlink" title="1.2 异步调度原理"></a>1.2 异步调度原理</h2><p>调度任务具体的实现细节。React 发送一次更新，会统一走 ensureRootIsScheduled（调度应用）。</p><ul><li>对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走<code>workLoopSync</code></li><li>对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 <code>workLoopConcurrent</code></li></ul><p>如下看一下 workLoopSync，workLoopConcurrent。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) &#123;<br>    workInProgress = <span class="hljs-title function_">performUnitOfwork</span>(workInProgress)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    workInProgress = <span class="hljs-title function_">performUnitOfWork</span>(wokrInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield()  ，如果当前浏览器没有空余时间， shouldYield  会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber  ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。</p><h3 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h3><p>无论是上述正常更新任务<code>workLoopSync</code>还是低优先级的任务<code>workLoopConcurrent</code>，都是由调度器<code>scheduleCallback</code>统一调度的，那么两者在进入调度器时候有什么区别呢？</p><p>对于正常更新任务，最后会变成类似如下结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">Immediate</span>, workLoopSync)<br></code></pre></td></tr></table></figure><p>对于异步任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算超时等级，就是加上那五个等级</span><br><span class="hljs-keyword">var</span> priorityLevel = <span class="hljs-title function_">inferPriorityFromExpirationTime</span>(currentTime, expirationTime);<br><span class="hljs-title function_">scheduleCallback</span>(priorityLevel, workLoopConcurrent)<br></code></pre></td></tr></table></figure><p>低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上那五种超时等级。</p><h3 id="scheduldCallback-到底做了些什么"><a href="#scheduldCallback-到底做了些什么" class="headerlink" title="scheduldCallback 到底做了些什么?"></a>scheduldCallback 到底做了些什么?</h3><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 计算过期时间：超时时间 - 开始时间（现在时间）+ 任务超时时间（上述设置那五个等级）</span><br>  <span class="hljs-keyword">const</span> expirationTime = startTime + timeout;<br>  <span class="hljs-comment">// 创建一个新任务</span><br>  <span class="hljs-keyword">const</span> newWask = &#123; ... &#125;<br> <span class="hljs-keyword">if</span> (startTime &gt; currentTime) &#123;<br>    <span class="hljs-comment">// 通过开始时间排序</span><br>    newTask.<span class="hljs-property">sortIndex</span> = startTime;<br>    <span class="hljs-comment">// 把任务放在 timeQueue 中</span><br>    <span class="hljs-title function_">push</span>(timerQueue, newTask);<br>    <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 通过 expirationTime 排序</span><br>    newTask.<span class="hljs-property">sortIndex</span> = expirationTime;<br>    <span class="hljs-comment">// 把任务放入 taskQueue</span><br>    <span class="hljs-title function_">push</span>(taskQueue, newTask);<br>    <span class="hljs-comment">// 没有处理调度中的任务，然后向浏览器请求一帧，浏览器空闲执行 flushWork</span><br>    <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">requestHostCallback</span>(flushWork)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于调度本身，有几个概念必须掌握：</p><ul><li><code>taskQueue</code>，里面存的都是过期的任务，依据任务的过期时间（<code>expirationTime</code>）排序，需要在调度的<code>workLoop</code>中循环执行完这些任务。</li><li><code>timeQueue</code>里面存的都是没有过期的任务，依据任务的开始时间（<code>startTime</code>）排序，在调度 workLoop 中会用<code>advanceTimers</code> 检查任务是否过期，如果过期了，放入<code>taskQueue</code>队列。</li></ul><p>scheduleCallback 流程如下：</p><ul><li>创建一个新的任务 newTask。</li><li>通过任务的开始时间（startTime）和 当前时间（currentTime）比较：startTime &gt; currentTime，说明未过期，存到 timerQueue，当 startTime &lt;&#x3D; currentTime，说明已过期，存到 taskQUeue。</li><li>如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。</li><li>如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。</li></ul><h3 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h3><p>上述当一个任务，没有超时，那么 React 把它放入 timerQueue 中了，但是它什么时候执行呢？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态，那么需要延迟 startTime - currentTime 毫秒就可以了。</p><p>requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">requestHostTimeout = <span class="hljs-keyword">function</span> (cb, ms) &#123;<br>  _timeoutID = set<span class="hljs-constructor">Timeout(<span class="hljs-params">cb</span>, <span class="hljs-params">ms</span>)</span>;<br>&#125;;<br>cancelHostTimeout = <span class="hljs-keyword">function</span> <span class="hljs-literal">()</span> &#123;<br>  clear<span class="hljs-constructor">Timeout(<span class="hljs-params">_timeoutID</span>)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout 用来清除当前的延时器。</li></ul><h3 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h3><p>延时指定时间后，调用的 handleTimeout 函数，handleTimeout 会把任务重新放在 requestHostCallback 调度。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> handleTimeout <span class="hljs-literal">()</span> &#123;<br>  isHostTimeoutScheduled = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 将 timeQueue 中过期的任务，放在 taskQueue 中</span><br>  advance<span class="hljs-constructor">Timers(<span class="hljs-params">currentTime</span>)</span><br>  <span class="hljs-comment">// 如果没有处于调度中</span><br>  <span class="hljs-keyword">if</span> (!isHostCallbackScheduled) &#123;<br>    <span class="hljs-comment">// 判断有没有处于调度中</span><br>    <span class="hljs-keyword">if</span> (peek(taskQueue) !== null) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 开启调度任务</span><br>      request<span class="hljs-constructor">HostCallback(<span class="hljs-params">flushWOrk</span>)</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 advanceTimers 将 timeQueue 中过期的任务转移 taskQueue 中。</li><li>然后调用 requesttHostCallback 调度过期的任务。</li></ul><h3 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h3><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js advanceTimers</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs maxima">function advanceTimers() &#123;<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">timer</span> = peek(timerQueue);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">timer</span> !== null) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timer</span>.callback === null) &#123;<br>      <span class="hljs-built_in">pop</span>(tiemrQueue);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timer</span>.startTime &lt;= currentTime) &#123; // 如果任务已经过期，那么将 timeQueue 中的过期任务，放入 taskQueue<br>      <span class="hljs-built_in">pop</span>(timerQueue);<br>      <span class="hljs-built_in">timer</span>.sortIndex = <span class="hljs-built_in">timer</span>.expirationTime;<br>      <span class="hljs-built_in">push</span>(taskQueue, <span class="hljs-built_in">timer</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。</li></ul><h3 id="flushWork-和-workLoop"><a href="#flushWork-和-workLoop" class="headerlink" title="flushWork 和 workLoop"></a>flushWork 和 workLoop</h3><ul><li>React 的更新任务最后都是放在 taskQueue 中的。</li><li>requestHostCallback，放入 MessageChannel 中的回调函数是flushWork。</li></ul><h4 id="flushWork"><a href="#flushWork" class="headerlink" title="flushWork"></a>flushWork</h4><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js flushWork</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> flush<span class="hljs-constructor">Work()</span> &#123;<br>  <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) &#123; <span class="hljs-comment">// 如果有延时任务，那么先暂定延时任务</span><br>    isHostTimeoutScheduled = <span class="hljs-literal">false</span>;<br>    cancel<span class="hljs-constructor">HostTimeout()</span>;<br>  &#125;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 执行 workLoop 里面会真正调度我们的事件</span><br>    work<span class="hljs-constructor">Loop(<span class="hljs-params">hanTimeRemaining</span>, <span class="hljs-params">initialTime</span>)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop，去真正执行超时的更新任务。</li></ul><h4 id="workLoop"><a href="#workLoop" class="headerlink" title="workLoop"></a>workLoop</h4><p>这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> work<span class="hljs-constructor">Loop()</span> &#123;<br>  var currentTime = initialTime;<br>  advance<span class="hljs-constructor">Timers(<span class="hljs-params">currentTime</span>)</span>;<br>  <span class="hljs-comment">// 获取任务列表中的第一个</span><br>  currentTask = peek<span class="hljs-literal">()</span>;<br>  <span class="hljs-keyword">while</span> (currentTask !== null) &#123;<br>    <span class="hljs-comment">// 执行更新</span><br>    callback<span class="hljs-literal">()</span><br>    <span class="hljs-comment">// 先看一下 timeQueue 中有没有 过期任务</span><br>    addvance<span class="hljs-constructor">Timers(<span class="hljs-params">currentTime</span>)</span>;<br>  &#125;<br>  <span class="hljs-comment">// 再一次获取任务，循环执行</span><br>  currentTask = peek(taskQueue);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>workLoop 会依次更新过期任务队列中的任务。<strong>到此为止，完成整个调度过程</strong></li></ul><h3 id="调度流程图"><a href="#调度流程图" class="headerlink" title="调度流程图"></a>调度流程图</h3><p>整个调度流程：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/schedule03.png" alt="image.png"></p><h4 id="调和-异步调度-流程总图"><a href="#调和-异步调度-流程总图" class="headerlink" title="调和 + 异步调度 流程总图"></a>调和 + 异步调度 流程总图</h4><p>异步调度过程，如下图所示：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87/schedule04.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>调度与时间片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2023/08/01/web%E5%89%8D%E7%AB%AF/JavaScript/02.%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2023/08/01/web%E5%89%8D%E7%AB%AF/JavaScript/02.%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块概念"><a href="#模块概念" class="headerlink" title="模块概念"></a>模块概念</h1><ul><li>将复杂程序按照约定好的规范封装成几个块（文件），并进行组合</li><li>块的内部数据是私有的，只是向外部暴露一些接口（方法）与外部通信</li></ul><h1 id="模块化的目的"><a href="#模块化的目的" class="headerlink" title="模块化的目的"></a>模块化的目的</h1><ul><li>避免命名冲突（减少命名空间污染）</li><li>更好的分离代码，实现按需加载</li><li>更高的可复用性</li><li>更好的可维护性</li></ul><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>NodeJs 所采用的模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类都是私有的，对其他文件不可见。<br><strong>服务端：</strong> 模块的加载是运行时同步加载的<br><strong>浏览器端：</strong> 模块需要提前编译打包处理</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>所有代码都运行在模块作用域，不会污染全局作用域</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。想要模块再次运行，必须清除缓存。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>导出模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>导入模块：<code>require(xxx)</code>，如果第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p><strong>导出：</strong><br>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<br><strong>所以加载某个模块，其实是加载该模块的module.exports属性。</strong></p><p><strong>导入：</strong><br><strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</strong></p><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong></p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>AMD规范则是非同步加载模块，允许指定回调函数。<br>如果是浏览器环境，要从服务器端加载模块，这时就必须采用<strong>非同步模式</strong>，因此浏览器端一般采用AMD规范。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>定义导出模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义没有依赖的模块</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> 模块 &#125;) <br><span class="hljs-comment">//定义有依赖的模块</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;module1&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">m1, m2</span>)&#123;    <span class="hljs-keyword">return</span> 模块 &#125;)<br></code></pre></td></tr></table></figure><p><strong>导入使用模块:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;module1&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">m1, m2</span>)&#123;    使用m1/m2 &#125;)<br></code></pre></td></tr></table></figure><p><strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系。</strong></p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>定义导出模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义没有依赖的模块 </span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>)&#123;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">xxx</span> = value<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = value<br>&#125;)<br><span class="hljs-comment">//定义有依赖的模块 </span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>)&#123;   <br><span class="hljs-comment">//引入依赖模块(同步)</span><br><span class="hljs-keyword">var</span> module2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module2&#x27;</span>)<br><span class="hljs-comment">//引入依赖模块(异步)</span><br><span class="hljs-built_in">require</span>.<span class="hljs-title function_">async</span>(<span class="hljs-string">&#x27;./module3&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">m3</span>) &#123;<br>&#125;)<br><span class="hljs-comment">//暴露模块</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">xxx</span> = value <br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>导入使用模块：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module1&#x27;</span>)<br>  <span class="hljs-keyword">var</span> m4 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module4&#x27;</span>)<br>  m1.<span class="hljs-title function_">show</span>()   m4.<span class="hljs-title function_">show</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>静态化的设计思想，使得编译时就能确定模块的依赖关系，以及输入和输出的变量， CommonJS  和 AMD 模块化规范，都只能在运行时确定这些东西。 比如，CommonJS 模块就是对象，输入时必须查找对象属性。 </p><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** 定义模块 math.js **/</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-keyword">export</span> &#123; basicNum, add &#125;;<br><span class="hljs-comment">/** 引用模块 **/</span><br><span class="hljs-keyword">import</span> &#123; basicNum, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">ele</span>) &#123;<br>    ele.<span class="hljs-property">textContent</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">99</span> + basicNum);<br>&#125;<br><br><span class="hljs-comment">// 默认导入</span><br><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// import-default.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>; <span class="hljs-comment">// 自定义导入后的模块名字</span><br><span class="hljs-title function_">customName</span>(); <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="ES6-与-CommonJS-的差异"><a href="#ES6-与-CommonJS-的差异" class="headerlink" title="ES6 与 CommonJS 的差异"></a>ES6 与 CommonJS 的差异</h2><ul><li><strong>CommonJS 是运行时加载，同步加载模块，输出值的拷贝</strong><ul><li>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。</li><li>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。</li><li>当使用 require 命令加载某个模块时，就会运行整个模块的代码。</li><li>当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li><li>循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul></li><li><strong>ES6 模块是编译时输出接口，异步加载模块，输出值的引用</strong><ul><li>ES6模块中的值属于【动态只读引用】。</li><li>对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。</li><li>循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线上问题定位</title>
    <link href="/2023/07/31/web%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/02.%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/07/31/web%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/02.%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="利用-开发者工具"><a href="#利用-开发者工具" class="headerlink" title="利用 开发者工具"></a>利用 开发者工具</h1><ol><li>找到 <code>network</code> 面板下的搜索按钮</li><li>搜索页面中的文案，从而定位到对应的 <code>chunk</code> (<code>对应页面的js文件</code>)，</li><li>检索对应功能的文案，定位源码位置</li><li>再右键<code>Open in Sources panel</code>, 即可打断点调试了</li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>项目技巧</category>
      
      <category>线上问题定位</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件原理</title>
    <link href="/2023/07/31/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/01.%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2023/07/31/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/01.%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="事件原理"><a href="#事件原理" class="headerlink" title="事件原理"></a>事件原理</h1><h2 id="react-独特的事件系统"><a href="#react-独特的事件系统" class="headerlink" title="react 独特的事件系统"></a>react 独特的事件系统</h2><p>React 事件系统可以分为三个部分</p><ul><li>第一个部分是事件合成系统，初始化会注册不同的事件插件。</li><li>第二个就是在一次渲染过程中，对事件标签中事件的收集，向 <code>container</code> 注册事件。</li><li>第三个就是一次用户交互，事件触发到事件执行一系列过程。</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><ul><li>给元素绑定的事件，不是真正的事件处理函数。</li><li>在冒泡&#x2F;捕获阶段绑定的事件，也不是在冒泡&#x2F;捕获阶段执行的。</li><li>甚至在事件处理函数中拿到的事件源 e，也不是真正的事件源 e。</li></ul><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><ul><li>抹平不同浏览器的差异：对于不同的浏览器，对事件存在不同的兼容性 。</li><li>为了 <code>ssr</code> 和跨端的支持</li></ul><h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><ul><li>V17 之前的 React 事件都是绑定在 document 上，V17 之后 React 把事件绑定在应用对应的容器 container 上<br>  将事件绑定在统一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获-&gt;事件源-&gt;事件冒泡，也包括重写一下事件源对象 event。</li></ul><h2 id="独特的事件处理"><a href="#独特的事件处理" class="headerlink" title="独特的事件处理"></a>独特的事件处理</h2><h3 id="冒泡阶段和捕获阶段"><a href="#冒泡阶段和捕获阶段" class="headerlink" title="冒泡阶段和捕获阶段"></a>冒泡阶段和捕获阶段</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span>=(<span class="hljs-params"></span>)=&gt;&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;模拟冒泡阶段执行&#x27;</span>) &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span>=(<span class="hljs-params"></span>)=&gt;&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;模拟捕获阶段执行&#x27;</span>) &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick</span> &#125; <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClickCapture</span> &#125;&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>冒泡阶段：开发者正常给 React 绑定的事件比如 onClick，onChange，默认会模拟冒泡阶段执行。</li><li>捕获阶段：如果想要在捕获阶段执行可以将事件后面加上 Capture 后缀，比如 onClickCapture，onChangeCapture。</li></ul><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>调用 <code>e.stopPropagation()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span>=(<span class="hljs-params">e</span>)=&gt;&#123;<br>    e.<span class="hljs-title function_">stopPropagation</span>() <span class="hljs-comment">// 阻止事件冒泡，handleFatherClick 事件将不触发</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFatherClick</span>=(<span class="hljs-params"></span>)=&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;冒泡到父级&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleFatherClick</span> &#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick</span> &#125;&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>React 阻止冒泡和原生事件中的写法差不多，当如上 <code>handleClick上</code> 阻止冒泡，父级元素的 <code>handleFatherClick</code> 将不再执行，但是底层原理完全不同</li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p><strong>原生事件：</strong> <code>e.preventDefault()</code> 和<code>return false</code> 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。所以导致 return false 方法在 React 应用中完全失去了作用。<br><strong>React事件：</strong> 在React 应用中，可以用 <code>e.preventDefault()</code> 阻止事件默认行为，这个方法并非是原生事件的 <code>preventDefault，由于</code> React 事件源 e 也是独立组建的，所以 <code>preventDefault</code> 也是单独处理的。</p><h2 id="事件合成"><a href="#事件合成" class="headerlink" title="事件合成"></a>事件合成</h2><h3 id="事件合成概念"><a href="#事件合成概念" class="headerlink" title="事件合成概念"></a>事件合成概念</h3><p><strong>案例：</strong> 在整个 React 应用中只绑定一个事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick</span> &#125;&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面在 <code>button</code> 元素绑定的事件中，没有找到 <code>handleClick</code> 事件。但是在 <code>document</code> 上绑定一个 <code>onClick</code> 事件<br><strong>总结：</strong> </p><ul><li>React 的事件不是绑定在元素上的，而是统一绑定在顶部容器上，在 v17 之前是绑定在 document 上的，在 v17 改成了 app 容器上，这样更有利于一个 html 下存在多个应用（微前端）</li><li>绑定事件并不是一次性绑定所有事件，比如发现了 onClick 事件，就会绑定 click 事件，比如发现 onChange 事件，会绑定 <code>[blur，change ，focus ，keydown，keyup]</code> 多个事件。</li><li>React 事件合成的概念：React 应用中，元素绑定的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成的，onChange 是由 blur，change，focus 等多个事件合成。</li></ul><h3 id="事件插件机制"><a href="#事件插件机制" class="headerlink" title="事件插件机制"></a>事件插件机制</h3><p>React 有一种事件插件机制，比如上述的 onClick 和 onChange，会有不同的事件插件 <code>SimpleEventPlugin</code>，<code>ChangeEventPlugin</code> 处理。</p><p><strong><code>registrationNameModules</code></strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> registrationNameModules = &#123;<br>  <span class="hljs-attr">onBlur</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>  <span class="hljs-attr">onClick</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>  <span class="hljs-attr">onClickCapture</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,<br>  <span class="hljs-attr">onChange</span>: <span class="hljs-title class_">ChangeEventPlugin</span>,<br>  <span class="hljs-attr">onChangeCapture</span>: <span class="hljs-title class_">ChangeEventPlugin</span>,<br>  <span class="hljs-attr">onMouseEnter</span>: <span class="hljs-title class_">EnterLeaveEventPlugin</span>,<br>  <span class="hljs-attr">onMouseLeave</span>: <span class="hljs-title class_">EnterLeaveEventPlugin</span>,<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>registrationNameModules</code> 记录了 React 事件（比如 onBlur ）和与之对应的处理插件的映射，比如上述的  onClick ，就会用 <code>ChangeEventPlugin</code> 插件处理，<code>onChange</code> 就会用 <code>ChangeEventPlugin</code>  处理。应用于事件触发阶段，根据不同事件使用不同的插件。</p><p>对于不同的事件，有不同的处理逻辑；对应的事件源对象也有所不同，React 的事件和事件源是自己合成的，所以对于不同事件需要不同的事件插件处理。<br><strong><code>registrationNameDependencies</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">onBlur</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>],<br>  <span class="hljs-attr">onClick</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],<br>  <span class="hljs-attr">onClickCapture</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],<br>  <span class="hljs-attr">onChange</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;focus&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>],<br>  <span class="hljs-attr">onMouseEnter</span>: [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>],<br>  <span class="hljs-attr">onMouseLeave</span>: [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>],<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个对象保存了 React 事件和原生事件对应关系，这就解释了为什么上述只写了一个 onChange ，会有很多原生事件绑定在 document 上。在事件绑定阶段，如果发现有 React 事件，比如 onChange ，就会找到对应的原生事件数组，逐一绑定。</p><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>事件绑定就是在 React 处理 props 时候，如果遇到事件比如 onClick，就会通过 addEventListener 注册原生事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击事件&#x27;</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;change事件&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对如上结构，最后 onChange 和 onClick 会保存在对应 DOM 元素类型 fiber 对象（hostComponent）的 memoizedProps 属性上，如上结构会变成这样：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/event01.png" alt="image.png"></p><ol><li>React 根据事件注册事件监听器<blockquote><p>react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMComponent.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffProperties</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 判断当前的 propKey 是不是 React 合成事件</span><br>  <span class="hljs-keyword">if</span> (registrationNameModules.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) &#123;<br>    <span class="hljs-comment">// 这里多个函数简化了，如果是合成事件，传入合成事件名称 onClick，向 document 注册事件</span><br>    <span class="hljs-title function_">legacyListenToEvent</span>(registrationName, <span class="hljs-variable language_">document</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><code>diffProperties</code> 函数在 diff props 如果发现是合成事件( onClick ) 就会调用 <code>legacyListenToEvent</code> 函数。注册事件监听器。接下来看一下 <code>legacyListenToEvent</code> 是如何注册事件的。<blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyListenToEvent</span>(<span class="hljs-params">registrationName, mountAt</span>) &#123;<br>  <span class="hljs-keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="hljs-comment">// 根据 onClick 获取 onClick 依赖的时间组件 [&#x27;click&#x27;]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> dependency = dependencies[i];<br>    <span class="hljs-comment">// addEventListener 绑定事件监听器</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>这个就是应用上述 <code>registrationNameDependencies</code> 对 React 合成事件，分别绑定原生事件的事件监听器。比如发现是 onChange，那么取出 <code>[&#39;blur&#39;, &#39;change&#39;, &#39;click&#39;, &#39;focus&#39;, &#39;input&#39;, &#39;keydown&#39;, &#39;keyup&#39;, &#39;selectionchange&#39;]</code> 遍历绑定。</li></ul><ol start="2"><li>通过 <code>addEventListener</code> 真正绑定事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> listener = dispatchEvent.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;click&#x27;</span>,eventSystemFlags,<span class="hljs-variable language_">document</span>)<br><span class="hljs-comment">// 主要，这里进行真正的事件绑定</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,listener, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p><strong>案例</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick1</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick2</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick3</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick4</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick3</span> &#125;  <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick4</span> &#125;  &gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick1</span> &#125;  <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick2</span> &#125;  &gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>点击以上按钮，在 React 中的流程如下:</p><h3 id="1-批量更新"><a href="#1-批量更新" class="headerlink" title="1. 批量更新"></a>1. 批量更新</h3><p>执行 dispatchEvent，dispatchEvent 执行会传入真实的事件源 button 元素本身，通过元素可以找到 button 对应的 fiber。</p><p>React 在初始化真实 DOM 的时候，用一个随机的 key internalInstanceKey  指针指向了当前 DOM 对应的 fiber 对象，fiber 对象用 stateNode 指向了当前的 DOM 元素。<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/event02.png" alt="image.png"></p><p>批量更新</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn, a</span>) &#123;<br>  isBatchingEventUpdates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 打开批量更新开关</span><br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-title function_">fn</span>(a) <span class="hljs-comment">// 事件在这里执行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isBatchingEventUpdates = <span class="hljs-literal">false</span> <span class="hljs-comment">// 关闭批量更新开关</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/event03.png" alt="image.png"></p><h3 id="2-合成事件源"><a href="#2-合成事件源" class="headerlink" title="2. 合成事件源"></a>2. 合成事件源</h3><p>接下来会通过 onClick 找到对应的处理插件 SimpleEventPlugin，合成新的事件源 e，里面包含了 preventDefault 和 stopPropagation 等方法。<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/event04.png" alt="image.png"></p><h3 id="3-形成事件执行队列"><a href="#3-形成事件执行队列" class="headerlink" title="3. 形成事件执行队列"></a>3. 形成事件执行队列</h3><p>在第一步通过原生 DOM 获取到对应的 fiber，接着会从这个 fiber 向上遍历，遇到元素类型 fiber，就会收集事件，用一个数组收集事件：</p><ul><li>如果遇到捕获阶段事件 onClickCapture，就会 unshift 放在数组前面。以此模拟事件捕获阶段。</li><li>如果遇到冒泡阶段事件 onClick，就会 push 到数组后面，模拟事件冒泡阶段。</li><li>一直收集到最顶端 app，形成执行队列，在接下来阶段，依次执行队列里面的函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; stateNode, tag &#125; = instance;<br>  <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// DOM 元素</span><br>    <span class="hljs-keyword">const</span> currentTarget = stateNode;<br>    <span class="hljs-keyword">if</span> (captured !== <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 事件捕获</span><br>      <span class="hljs-comment">// 在事件捕获阶段，真正的事件处理函数</span><br>      <span class="hljs-keyword">const</span> captureListener = <span class="hljs-title function_">getListener</span>(instance, captured); <span class="hljs-comment">// onClickCapture</span><br>      <span class="hljs-keyword">if</span> (captureListener != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数 unshift 添加到队列的最前面</span><br>        dispatchListeners.<span class="hljs-title function_">unshift</span>(captureListener);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bubbled !== <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 事件冒泡</span><br>        <span class="hljs-comment">// 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数 push 到执行队列的最后面</span><br>      <span class="hljs-keyword">const</span> bubbleListener = <span class="hljs-title function_">getListener</span>(instance, bubbled);<br>      <span class="hljs-keyword">if</span> (bubbleListener != <span class="hljs-literal">null</span>) &#123;<br>        dispatchListeners.<span class="hljs-title function_">push</span>(bubbleListtener); <span class="hljs-comment">// onClick</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  instance = instance.<span class="hljs-property">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>那么如上点击一次按钮，4 个事件执行顺序是这样的：</li><li>首先第一次收集是在 button 上，handleClick1 冒泡事件 push 处理，handleClick2 捕获事件 unshift 处理。形成结构<code>[ handleClick2, handleClick1 ]</code></li><li>然后接着向上收集，遇到父级，收集父级 div 上的事件，handleClick3 冒泡事件 push 处理，handleClick4 捕获时间 unshift 处理。<code>[handleClick4, handleClick2, handleClick1, handleClick3]</code></li><li>依次执行数组里面的事件，所以打印 4 2 1 3</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%8E%9F%E7%90%86/%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/event05.png" alt="image.png"></p><h3 id="模拟阻止事件冒泡"><a href="#模拟阻止事件冒泡" class="headerlink" title="模拟阻止事件冒泡"></a>模拟阻止事件冒泡</h3><blockquote><p>legacy-events&#x2F;EventBatching.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runEventsInBatch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatchListeners = event.<span class="hljs-property">_dispatchListenners</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(dispatchListeners)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; dispatchListeners.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123; <span class="hljs-comment">// 判断是否已经阻止事件冒泡</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      dispatchListeners[i](event) <span class="hljs-comment">// 执行真正的处理函数 及 handleClick1 ...</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述队列 <code>[handleClick4, handleClick2 , handleClick1, handleClick]</code></p><ul><li>假设在上述队列中，handleClick2 中调用 <code>event.stopPropagation()</code>，那么事件源里将有状态证明此次事件已经停止冒泡，那么下次遍历的时候，<code>event.isPropagationStopped()</code>就会返回 true，所以跳出循环，handleClick1，handleClick3 将不再执行，模拟了阻止事件冒泡的过程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>事件原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户登录状态</title>
    <link href="/2023/07/27/web%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/01.%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/"/>
    <url>/2023/07/27/web%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/01.%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="登录状态"><a href="#登录状态" class="headerlink" title="登录状态"></a>登录状态</h1><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>活跃用户不能频繁失去登录状态，并且要保证 <code>token</code> 的安全性</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>双<code>token</code>机制：</p><ol><li><code>accessToken</code>真正用来获取数据的<code>token</code></li><li><code>refreshToken</code>用来获取<code>accessToken</code></li></ol><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>在响应拦截器中拦截，后端判断<code>token</code>过期，返回固定的状态码，前端调用续签<code>token</code>的接口<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// token异常</span><br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">409</span>) &#123;<br>    <span class="hljs-title function_">deleteToken</span>();<br>    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br>    <span class="hljs-comment">// 更新Token</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">410</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;token&#125; = res.<span class="hljs-property">data</span><br>    <span class="hljs-title function_">setToken</span>(token);<span class="hljs-comment">// 重置token</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> res &amp;&amp; res.<span class="hljs-property">data</span><br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>项目技巧</category>
      
      <category>用户登录状态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滚动条</title>
    <link href="/2023/07/27/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/02.%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <url>/2023/07/27/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/02.%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h1><h2 id="两种表现形式"><a href="#两种表现形式" class="headerlink" title="两种表现形式"></a>两种表现形式</h2><ol><li>占据页面内容</li><li>悬浮在页面上，不占据页面内容</li></ol><h2 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">dom</span>&#125; el 滚动条容器dom元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">boolean</span>&#125; 是否出现占据内容宽度的滚动条</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">isScrollOccupyingWidth</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 获取元素的实际高度和可见高度</span><br>  <span class="hljs-keyword">const</span> scrollHeight = el.<span class="hljs-property">scrollHeight</span><br>  <span class="hljs-keyword">const</span> clientHeight = el.<span class="hljs-property">clientHeight</span><br><br>  <span class="hljs-comment">// 获取元素的实际宽度和可见宽度 </span><br>  <span class="hljs-keyword">const</span> offsetWidth = el.<span class="hljs-property">offsetWidth</span><br>  <span class="hljs-keyword">const</span> clientWidth = el.<span class="hljs-property">clientWidth</span><br><br>  <span class="hljs-comment">// 判断是否出现滚动条并且滚动条是占据内容宽度的</span><br>  <span class="hljs-keyword">return</span> scrollHeight &gt; clientHeight &amp;&amp; offsetWidth &gt; clientWidth<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>浏览器</category>
      
      <category>滚动条</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>滚动条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集成sortablejs实现拖拽功能</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E9%9B%86%E6%88%90sortablejs%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E9%9B%86%E6%88%90sortablejs%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p><code>darg mixins</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs vue">/*<br> * drag mixins<br> */<br>import Sortable from &#x27;sortablejs&#x27;<br>import SIcon from &#x27;@/components/icon&#x27;<br>export default &#123;<br>  props: &#123;<br>    drag: &#123;<br>      type: Boolean,<br>      default: false<br>    &#125;,<br>    rowKey: &#123;<br>      type: String, // 唯一key<br>      default: &#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  data: &#123;<br>    oldData: &#123;&#125;,<br>    curEl: null,<br>  &#125;,<br>  watch: &#123;<br>    data: &#123;<br>      immediate: true,<br>      deep: true,<br>      handler () &#123;<br>        if (!this.drag) &#123;<br>          return;<br>        &#125;<br>        this.initRowDrag();<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  coputed: &#123;<br>    isFixedLeft() &#123;<br>      this.columns.some(col =&gt; col.fixed === &#x27;left&#x27;);<br>    &#125;<br>  &#125;,<br>  beforeDestroy() &#123;<br>    if (this.sortable) &#123;<br>      this.sortable.destroy();<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    initDragColumn(columns) &#123;<br>      if (!this.drag) &#123;<br>        return;<br>      &#125;<br>      columns.unshift(&#123;<br>        title: &#x27;&#x27;,<br>        key: &#x27;drag&#x27;,<br>        width: 52,<br>        resizable: false,<br>        fixed: &#x27;left&#x27;,<br>        type: &#x27;drag&#x27;,<br>        render: (h) =&gt; &#123;<br>          return h(&#x27;span&#x27;, &#123;<br>            class: &#x27;drag-btn&#x27;,<br>          &#125;, [<br>            h(SIcon, &#123;<br>              style: &#123;<br>                cursor: &#x27;pointer&#x27;<br>              &#125;,<br>              props: &#123;<br>                icon: &#x27;sort&#x27;,<br>                size: 16<br>              &#125;<br>            &#125;)<br>          ]);<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    initRowDrag () &#123;<br>      this.$nextTick(() =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          // 固定列采用显示隐藏列的方案<br>          const xTable = this.$refs.sTable<br>          let dragBody = xTable.$el.querySelector(&#x27;.vxe-table--fixed-left-wrapper .vxe-table--body tbody&#x27;)<br>          if (!dragBody) &#123;<br>            dragBody = xTable.$el.querySelector(&#x27;.vxe-table--body-wrapper .vxe-table--body tbody&#x27;)<br>          &#125;<br>          if (this.sortable) &#123;<br>            this.sortable.destroy();<br>          &#125;<br>          this.sortable = Sortable.create(dragBody, &#123;<br>            handle: &#x27;.drag-btn&#x27;,<br>            animation: 150,<br>            onMove: (e, originalEvent) =&gt; &#123;<br>              const classNames = e.related._prevClass.split(&#x27; &#x27;)<br>              this.curEl = xTable.$el.querySelector(&#x27;.ghost&#x27;)<br>              if(~classNames.indexOf(&#x27;row-disabled&#x27;)) &#123;<br>                return false<br>              &#125; else &#123;<br>                return true<br>              &#125;<br>            &#125;,<br>            onStart: (e) =&gt; &#123;<br>              const &#123; oldIndex &#125; = e<br>              const &#123; tableData &#125; = this.$refs.sTable.getTableData();<br>              const &#123; visibleData &#125; = this.$refs.sTable.getTableData();<br>              let oldData = &#123;&#125;<br>              let isVirtualScroll = false<br>              if(visibleData.length &gt; xTable.scrollY.gt) &#123;<br>                // 开启虚拟滚动<br>                isVirtualScroll = true<br>              &#125;<br>              if(isVirtualScroll) &#123;<br>                oldData = visibleData.find(item =&gt; item[this.rowKey] === tableData[oldIndex][this.rowKey])<br>              &#125; else &#123;<br>                oldData = visibleData.filter(item =&gt; item._X_ROW_KEY === tableData[oldIndex]._X_ROW_KEY)[0]<br>              &#125;<br>              console.log(&#x27;dragStart-oldData&#x27;, oldData)<br>              this.oldData = oldData<br>            &#125;,<br>            ghostClass:&quot;ghost&quot;,<br>            onEnd: ( e) =&gt; &#123;<br>              const &#123; newIndex, oldIndex &#125; = e<br><br>              if (newIndex === oldIndex) return <br>              let isVirtualScroll = false<br>              // 考虑长列表情况需要对index做转换<br>              const &#123; tableData &#125; = this.$refs.sTable.getTableData();<br>              let &#123; visibleData &#125; = this.$refs.sTable.getTableData();<br>              let newData = &#123;&#125;<br>              if(visibleData.length &gt; xTable.scrollY.gt) &#123;<br>                // 开启虚拟滚动<br>                isVirtualScroll = true<br>              &#125;<br>              <br>              let fullDataOldIndex, fullDataNewIndex<br>              if(this.rowKey &amp;&amp; isVirtualScroll) &#123;<br>                newData = visibleData.find(item =&gt; item[this.rowKey] === tableData[newIndex][this.rowKey])<br>                fullDataNewIndex = visibleData.findIndex(item =&gt; item[this.rowKey] === newData[this.rowKey])<br>                fullDataOldIndex = visibleData.findIndex(item =&gt; item[this.rowKey] === this.oldData[this.rowKey])<br>              &#125; else &#123;<br>                newData = tableData.filter(item =&gt; item._X_ROW_KEY === tableData[newIndex]._X_ROW_KEY)[0]<br>                fullDataNewIndex = visibleData.findIndex(item =&gt; item._X_ROW_KEY === tableData[newIndex]._X_ROW_KEY)<br>                fullDataOldIndex = visibleData.findIndex(item =&gt; item._X_ROW_KEY === tableData[oldIndex]._X_ROW_KEY)<br>              &#125;<br>              if(this.curEl &amp;&amp; Math.abs(fullDataNewIndex-fullDataOldIndex) &gt; xTable.scrollY.gt ) &#123;<br>                this.curEl.style.display = &#x27;none&#x27;<br>              &#125;<br>              console.log(&#x27;dragEnd-newData&#x27;, newData)<br>              console.log(&#x27;fullDataOldIndex&#x27;, fullDataOldIndex)<br>              console.log(&#x27;fullDataNewIndex&#x27;, fullDataNewIndex)<br>              this.$emit(&#x27;on-row-drag&#x27;, &#123;<br>                oldIndex: fullDataOldIndex,<br>                newIndex: fullDataNewIndex,<br>              &#125;);<br>            &#125;<br>          &#125;)<br>        &#125;, 300);<br>      &#125;)<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
      <category>drag</category>
      
      <category>sortablejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mixins 实现方案</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/Mixins%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/Mixins%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Mixins"><a href="#什么是-Mixins" class="headerlink" title="什么是 Mixins"></a>什么是 Mixins</h1><p>VueJS的混入方式，把可复用的代码混入当前的代码里面。<br>VueJS中使用Mixins</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">// define a mixin object<br>var myMixin = &#123;<br>created: funtion() &#123;<br>this.hello()<br>&#125;,<br>methods: &#123;<br>hello: funtion() &#123;<br>console.log(&#x27;hello from mixin!&#x27;)<br>&#125;<br>&#125;<br>&#125;<br>// define a component that users this mixin<br>var Component = Vue.extend(&#123;<br>mixins:[myMixin]<br>&#125;)<br>var component = new Component() // =&gt; &quot;hello from mixin!&quot;<br></code></pre></td></tr></table></figure><h1 id="Mixins-的机制"><a href="#Mixins-的机制" class="headerlink" title="Mixins 的机制"></a>Mixins 的机制</h1><h2 id="关于生命周期函数的执行顺序："><a href="#关于生命周期函数的执行顺序：" class="headerlink" title="关于生命周期函数的执行顺序："></a>关于生命周期函数的执行顺序：</h2><p>如果在上一个例子的基础上，在新建组件Component里面也定义一个created()方法，那么是哪个created()先执行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">var Component = Vue.extend(&#123;<br>  mixins: [myMixin],<br>  created: function () &#123;<br>    console.log(&#x27;hello from Component!&#x27;)<br>  &#125;<br>&#125;)<br><br>var component = new Component()<br><br>// Hello from mixin!<br>// Hello from Component!<br></code></pre></td></tr></table></figure><p>说明 Mixins 的生命周期函数先于新建组件的生命周期函数执行</p><h2 id="对象属性的混入结果"><a href="#对象属性的混入结果" class="headerlink" title="对象属性的混入结果"></a>对象属性的混入结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">// define a mixin object<br>const myMixin = &#123;<br>data() &#123;<br>return &#123;<br>mixinData: &#x27;data from mixin&#x27;<br>&#125;<br>&#125;<br>&#125;<br>// define a component that uses this mixin<br>var Component = Vue.extend(&#123;<br>mixins: [myMixin],<br>data () &#123;<br>return &#123;<br>componentData: &#x27;data from component&#x27;<br>&#125;<br>&#125;,<br>mounted () &#123;<br>console.log(this.$data)<br>&#125;<br>&#125;)<br>var component = new Component()<br></code></pre></td></tr></table></figure><p>在 VueJS中，会把来自Mixins和组件的对象属性当中的内容（如data，methods等）混合，以确保两边的数据都同时存在。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>生命周期属性，会优先执行来自Mixins当中的，后执行来自组件当中的</li><li>对象类型属性，来自Mixins和来自组件中的会共存。</li></ol><h1 id="小程序的区别"><a href="#小程序的区别" class="headerlink" title="小程序的区别"></a>小程序的区别</h1><p>但是在小程序中，这套机制会和VueJS的有一点区别。在小程序中，自定义的方法是直接定义在Page的属性当中的，既不属于生命周期类型属性，也不属于对象类型属性，为了不引入奇怪的问题，我们为小程序的Mixins运行机制多加一条：</p><ol><li>小程序中自定义方法，优先级为Page&gt;Mixins，即Page中自定义方法会覆盖Mixins当中的。</li></ol><h1 id="小程序的实现"><a href="#小程序的实现" class="headerlink" title="小程序的实现"></a>小程序的实现</h1><p>在小程序中，每个页面都由Page(options)函数定义，而Mixins则作用于这个函数当中的options对象。因此我们实现Mixins的思路就有了—–劫持并改写Page函数，最后再重新把它释放出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存原生的 Page 函数</span><br><span class="hljs-keyword">const</span> originPage = <span class="hljs-title class_">Page</span><br><span class="hljs-title class_">Page</span> = <span class="hljs-function">(<span class="hljs-params">options</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> mixins = options.<span class="hljs-property">mixins</span><br><span class="hljs-comment">// mixins 必须为数组</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(mixins)) &#123;<br><span class="hljs-keyword">delete</span> options.<span class="hljs-property">mixins</span><br><span class="hljs-comment">// mixins 注入并执行相应逻辑</span><br>options = <span class="hljs-title function_">merge</span>(mixins, options)<br>&#125;<br><span class="hljs-comment">// 释放原生 Page 函数</span><br><span class="hljs-title function_">originPage</span>(options)<br>&#125;<br></code></pre></td></tr></table></figure><p>原理很简单，关键的地方在于merge()函数。merge函数即为小程序Mixins运行机制的具体实现，完全按照上一节总结的三条结论来进行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义小程序内置的属性/方法</span><br><span class="hljs-keyword">const</span> originProperties = [<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;properties&#x27;</span>, <span class="hljs-string">&#x27;options&#x27;</span>]<br><span class="hljs-keyword">const</span> originMethods = [<span class="hljs-string">&#x27;onLoad&#x27;</span>, <span class="hljs-string">&#x27;onReady&#x27;</span>, <span class="hljs-string">&#x27;onShow&#x27;</span>, <span class="hljs-string">&#x27;onHide&#x27;</span>, <span class="hljs-string">&#x27;onUnload&#x27;</span>,<span class="hljs-string">&#x27;onPullDownRefresh&#x27;</span>,<span class="hljs-string">&#x27;onReachBottom&#x27;</span>,<span class="hljs-string">&#x27;onShareAppMessage&#x27;</span>,<span class="hljs-string">&#x27;onPageScroll&#x27;</span>,<span class="hljs-string">&#x27;onTabItemTap&#x27;</span>]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span> (mixins, options) &#123;<br>mixins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">mixin</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(mixin) !== <span class="hljs-string">&#x27;[object Object]&#x27;</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;mixin 类型必须为对象！&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 遍历 mixin 里面的所有属性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(mixin)) &#123;<br><span class="hljs-keyword">if</span> (originProperties.<span class="hljs-title function_">includes</span>(key)) &#123;<br><span class="hljs-comment">// 内置对象属性混入</span><br>options[key] = &#123; ...value, ...options[key] &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originMethods.<span class="hljs-title function_">includes</span>(key)) &#123;<br><span class="hljs-comment">// 内置方法属性混入，优先执行混入部分</span><br><span class="hljs-keyword">const</span> originFunc = options[key]<br>options[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, arges)<br><span class="hljs-keyword">return</span> originFunc &amp;&amp; originFunc.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 自定义方法混入</span><br>options = &#123; ...mixin, ...options &#125;<br>&#125;<br>&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> options<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Mixins使用"><a href="#Mixins使用" class="headerlink" title="Mixins使用"></a>Mixins使用</h1><ol><li>在小程序的 app.js 里面引入mixins.js <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mixins.js&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>写一个myMixin.js <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">someData</span>: <span class="hljs-string">&#x27;myMixin&#x27;</span> &#125;,<br>  onShow () &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Log from mixin!&#x27;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在page&#x2F;index&#x2F;index.js 中使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">mixins</span>: [<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../myMixin.js&#x27;</span>)]<br>&#125;)<br></code></pre></td></tr></table></figure>具体实现代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义Minxin</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 保存原生的 Page 函数</span><br><span class="hljs-keyword">const</span> originPage = <span class="hljs-title class_">Page</span><br><br><span class="hljs-comment">// 局部使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Page01</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mixins = options.<span class="hljs-property">mixins</span><br>  <span class="hljs-comment">// mixins 必须为数组</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(mixins)) &#123;<br>    <span class="hljs-keyword">delete</span> options.<span class="hljs-property">mixins</span><br>    <span class="hljs-comment">// mixins 注入并执行相应逻辑</span><br>    options = <span class="hljs-title function_">merge</span>(mixins, options)<br>  &#125;<br>  <span class="hljs-comment">// 释放原生 Page 函数</span><br>  <span class="hljs-title function_">originPage</span>(options)<br>&#125;<br><span class="hljs-comment">// 定义小程序内置的属性/方法</span><br><span class="hljs-keyword">const</span> originProperties = [<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;properties&#x27;</span>, <span class="hljs-string">&#x27;options&#x27;</span>]<br><span class="hljs-keyword">const</span> originMethods = [<span class="hljs-string">&#x27;onLoad&#x27;</span>, <span class="hljs-string">&#x27;onReady&#x27;</span>, <span class="hljs-string">&#x27;onShow&#x27;</span>, <span class="hljs-string">&#x27;onHide&#x27;</span>, <span class="hljs-string">&#x27;onUnload&#x27;</span>, <span class="hljs-string">&#x27;onPullDownRefresh&#x27;</span>, <span class="hljs-string">&#x27;onReachBottom&#x27;</span>, <span class="hljs-string">&#x27;onShareAppMessage&#x27;</span>, <span class="hljs-string">&#x27;onPageScroll&#x27;</span>, <span class="hljs-string">&#x27;onTabItemTap&#x27;</span>]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span> (mixins, options) &#123;<br>  mixins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">mixin</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(mixin) !== <span class="hljs-string">&#x27;[object Object]&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;mixin 类型必须为对象！&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 遍历 mixin 里面的所有属性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(mixin)) &#123;<br>      <span class="hljs-keyword">if</span> (originProperties.<span class="hljs-title function_">includes</span>(key)) &#123;<br>        <span class="hljs-comment">// 内置对象属性混入</span><br>        options[key] = &#123; ...value, ...options[key] &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originMethods.<span class="hljs-title function_">includes</span>(key)) &#123;<br>        <span class="hljs-comment">// 内置方法属性混入，优先执行混入的部分</span><br>        <span class="hljs-keyword">const</span> originFunc = options[key]<br>        options[key] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>          value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>          <span class="hljs-keyword">return</span> originFunc &amp;&amp; originFunc.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 自定义方法混入</span><br>        options = &#123; ...mixin, ...options &#125;<br>        <span class="hljs-comment">// options[key] = value</span><br>      &#125;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> options<br>&#125;<br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">Page01</span> &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/uniapp/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/uniapp/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="upload-组件"><a href="#upload-组件" class="headerlink" title="upload 组件"></a>upload 组件</h2><p>ios真机一次最多可选择9个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&quot;scss&quot; scoped&gt;<br>.upload &#123;<br>&amp;__list &#123;<br>display: flex;<br>flex-wrap: wrap;<br>background: #fff;<br><br>&amp;--items &#123;<br>margin-right: 36rpx;<br>margin-bottom: 36rpx;<br>position: relative;<br><br>.value &#123;<br>width: 138rpx;<br>height: 138rpx;<br>border-radius: 6rpx;<br>vertical-align: top;<br>&#125;<br>.value2 &#123;<br>width: 246rpx;<br>height: 138rpx;<br>border-radius: 6rpx;<br>&#125;<br><br>.close &#123;<br>width: 30rpx;<br>height: 30rpx;<br>right: -10rpx;<br>top: -10rpx;<br>position: absolute;<br>&#125;<br><br>&amp;:nth-child(4n) &#123;<br>margin-right: 0;<br>&#125;<br>&#125;<br><br>&amp;--card &#123;<br>width: 138rpx;<br>height: 138rpx;<br>margin-bottom: 20rpx;<br>border-radius: 6rpx;<br>background: #f5f5f5;<br>display: flex;<br>flex-flow: column;<br>align-items: center;<br>justify-content: center;<br>border: 1rpx solid #e6e6e6;<br><br>.iconfont &#123;<br>font-size: 70rpx;<br>color: #8e8e8e;<br>&#125;<br>&#125;<br>&#125;<br><br>&amp;__tips &#123;<br>font-size: 30rpx;<br>font-weight: 400;<br>font-size: 24rpx;<br>font-family: PingFangSC-Regular, PingFang SC;<br>font-weight: 400;<br>color: #909090;<br>&#125;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;template&gt;<br>&lt;view class=&quot;upload&quot;&gt;<br>&lt;view class=&quot;upload__list&quot;&gt;<br>&lt;view<br>class=&quot;upload__list--items&quot;<br>v-for=&quot;(item, index) in tempFilePaths&quot;<br>:key=&quot;index&quot;<br>&gt;<br>&lt;image<br>v-if=&quot;uploadType === &#x27;img&#x27;&quot;<br>class=&quot;value&quot;<br>:src=&quot;item&quot;<br>@click=&quot;handlePreview(item)&quot;<br>&gt;&lt;/image&gt;<br>&lt;video v-else class=&quot;value2&quot; :src=&quot;item&quot;&gt;&lt;/video&gt;<br>&lt;img<br>class=&quot;close&quot;<br>v-if=&quot;isEdit&quot;<br>src=&quot;./images/close.png&quot;<br>alt=&quot;&quot;<br>@click=&quot;handleRemove(index)&quot;<br>/&gt;<br>&lt;/view&gt;<br>&lt;view<br>class=&quot;upload__list--card&quot;<br>@click=&quot;handleClick&quot;<br>v-if=&quot;tempFilePaths.length &lt; len &amp;&amp; isEdit&quot;<br>&gt;<br>&lt;u-icon name=&quot;plus&quot; size=&quot;34&quot; color=&quot;#999999&quot;&gt;&lt;/u-icon&gt;<br>&lt;/view&gt;<br>&lt;/view&gt;<br>&lt;view class=&quot;upload__tips&quot; v-if=&quot;isEdit&quot;&gt;&#123;&#123; tips &#125;&#125;&lt;/view&gt;<br>&lt;/view&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name: &quot;s-upload&quot;,<br>data() &#123;<br>return &#123;<br>tempFilePaths: [],<br>formData: [],<br>curUploadIndex: 0<br>&#125;;<br>&#125;,<br>props: &#123;<br>imgsData: &#123;<br>type: Array,<br>default: () =&gt; []<br>&#125;,<br>len: &#123;<br>type: Number,<br>default: 9<br>&#125;,<br>isEdit: &#123;<br>type: Boolean,<br>default: true<br>&#125;,<br>extraData: &#123;<br>type: Object,<br>default: () =&gt; &#123;&#125;<br>&#125;,<br>tips: &#123;<br>type: String,<br>default: &quot;&quot;<br>&#125;,<br>uploadType: &#123;<br>type: String,<br>default: &quot;img&quot;<br>&#125;,<br>maxSize: &#123;<br>type: String || Number,<br>default: &quot;3&quot;<br>&#125;<br>&#125;,<br>watch: &#123;<br>imgsData: &#123;<br>handler(value) &#123;<br>this.tempFilePaths = value<br>.filter(item =&gt; item.cdn_url)<br>.map(item =&gt; item.cdn_url);<br>this.formData = value;<br>console.log(&quot;imgsData---&quot;, this.tempFilePaths);<br>console.log(&quot;formData---&quot;, this.formData);<br>&#125;,<br>immediate: true<br>&#125;<br>&#125;,<br>methods: &#123;<br>async handleUpload(tempFilePath) &#123;<br>const result = await this.uploadFile(<br>&quot;your oss upload url&quot;,<br>&#123;<br>name: tempFilePath.split(&quot;/&quot;).pop(),<br>ext_name: tempFilePath.split(&quot;.&quot;).pop()<br>&#125;,<br>tempFilePath<br>);<br>return result;<br>&#125;,<br>async uploadFile(url, params, tempFilePath) &#123;<br>console.log(&quot;uploadFile---------------&quot;);<br>const res = await this.$post(url, params, false, true);<br>const action = res.url.replace(&quot;http&quot;, &quot;https&quot;);<br>let that = this;<br>return new Promise((resolve, reject) =&gt; &#123;<br>uni.uploadFile(&#123;<br>url: action,<br>filePath: tempFilePath,<br>name: &quot;file&quot;,<br>formData: &#123;<br>...res.params<br>&#125;,<br>success: function(result) &#123;<br>if (result.statusCode === 200) &#123;<br>that.formData.push(&#123;<br>cdn_url: tempFilePath,<br>url: res.params.key<br>&#125;);<br>resolve(true);<br>&#125;<br>&#125;,<br>fail: function(err) &#123;<br>reject(false);<br>&#125;<br>&#125;);<br>&#125;);<br>&#125;,<br>handleRemove(index) &#123;<br>this.tempFilePaths.splice(index, 1);<br>this.formData.splice(index, 1);<br>console.log(&quot;handleRemove-index&quot;, index);<br>console.log(&quot;handleRemove-formData&quot;, this.formData);<br>this.$emit(&quot;uploadSuccess&quot;, this.formData);<br>&#125;,<br>handlePreview(url) &#123;<br>uni.previewImage(&#123;<br>current: url, // 当前显示图片的http链接<br>urls: this.tempFilePaths // 需要预览的图片http链接列表<br>&#125;);<br>&#125;,<br>handleClick() &#123;<br>let that = this,<br>mediaType = [&quot;image&quot;];<br>if (this.uploadType === &quot;video&quot;) &#123;<br>mediaType = [&quot;video&quot;];<br>&#125;<br>uni.chooseMedia(&#123;<br>count: that.len &gt; 9 ? 9 : that.len, // ios 最大为 9<br>sizeType: [&quot;original&quot;, &quot;compressed&quot;], // 可以指定是原图还是压缩图，默认二者都有<br>sourceType: [&quot;album&quot;, &quot;camera&quot;], // 可以指定来源是相册还是相机，默认二者都有<br>mediaType: mediaType,<br>maxDuration: 60,<br>success: async res =&gt; &#123;<br>this.$emit(&quot;on-start-upload&quot;);<br>uni.showLoading(&#123; title: &quot;上传中&quot;, mask: true &#125;);<br>// 如果单次选择大于最大上传数量的时. 直接把多余的给截取<br>let tempFilePaths = res.tempFiles;<br>let showLimitLenTip = false;<br>if (res.tempFiles.length + that.tempFilePaths.length &gt; that.len) &#123;<br>showLimitLenTip = true;<br>tempFilePaths = tempFilePaths.slice(<br>0,<br>that.len - that.tempFilePaths.length<br>);<br>&#125;<br>let showLimitTip = false;<br>tempFilePaths = tempFilePaths<br>.filter(file =&gt; &#123;<br>let maxSize = that.maxSize * 1024 * 1024; // 大小限制<br>if (file.size &gt; maxSize) &#123;<br>showLimitTip = true;<br>&#125;<br>return file.size &lt;= maxSize;<br>&#125;)<br>.map(file =&gt; file.tempFilePath);<br><br>if (tempFilePaths.length &lt; 0) &#123;<br>uni.hideLoading();<br>return;<br>&#125;<br>tempFilePaths = await Promise.all(<br>tempFilePaths.map(async tempFilePath =&gt; &#123;<br>const result = await that.handleUpload(tempFilePath);<br>return result ? tempFilePath : null;<br>&#125;)<br>);<br>tempFilePaths = tempFilePaths.filter(<br>tempFilePath =&gt; tempFilePath !== null<br>);<br>if (showLimitTip) &#123;<br>uni.hideLoading();<br>setTimeout(() =&gt; &#123;<br>uni.showToast(&#123;<br>title: `上传$&#123;<br>that.uploadType === &quot;video&quot; ? &quot;视频&quot; : &quot;图片&quot;<br>&#125;太大，超过$&#123;that.maxSize&#125;M限制`,<br>icon: &quot;none&quot;,<br>duration: 2000,<br>&#125;);<br>&#125;);<br>&#125;<br>if (showLimitLenTip) &#123;<br>uni.hideLoading();<br>setTimeout(() =&gt; &#123;<br>uni.showToast(&#123;<br>title: `上传$&#123;<br>that.uploadType === &quot;video&quot; ? &quot;视频&quot; : &quot;图片&quot;<br>&#125;数量，超过$&#123;that.len&#125;个长度限制`,<br>icon: &quot;none&quot;,<br>duration: 2000,<br>&#125;);<br>&#125;);<br>&#125;<br>that.$emit(&quot;uploadSuccess&quot;, that.formData);<br>that.tempFilePaths = that.tempFilePaths.concat(tempFilePaths);<br>&#125;,<br>fail: err =&gt; &#123;&#125;<br>&#125;);<br>&#125;,<br>handleReset() &#123;<br>Object.assign(this.$data, this.$options.data());<br>&#125;<br>&#125;,<br>mounted() &#123;&#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="textarea-组件"><a href="#textarea-组件" class="headerlink" title="textarea 组件"></a>textarea 组件</h2><p>真机bug，可以输入超过<code>maxlength</code>的字符，并且会在<code>count</code>上显示出来<br>解决办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&#x27;scss&#x27; scoped&gt;<br>.u-textarea &#123;<br>background-color: #f5f5f5;<br>border-radius: 6rpx;<br>padding: 12rpx 12rpx 40rpx 12rpx;<br>position: relative;<br>&amp;__field &#123;<br>flex: 1;<br>font-size: 15px;<br>// color: #C5C5C5;<br>width: 100%;<br>&#125;<br>&amp;__count &#123;<br>position: absolute;<br>right: 12rpx;<br>bottom: 8rpx;<br>font-size: 20rpx;<br>color: #999999;<br>padding: 1rpx 4rpx;<br>&#125;<br>&#125;<br>&lt;/style&gt;<br>&lt;template&gt;<br>&lt;div class=&quot;s-textarea u-textarea&quot;&gt;<br>&lt;textarea<br>:style=&quot;&#123;<br>height: `$&#123;height&#125;rpx`<br>&#125;&quot;<br>class=&quot;u-textarea__field&quot;<br>placeholder-style=&quot;#C5C5C5&quot;<br>@input=&quot;input&quot;<br>:disabled=&quot;disabled&quot;<br>:maxlength=&quot;maxlength&quot;<br>v-model=&quot;valueCopy&quot;<br>:placeholder=&quot;placeholder&quot;<br>&gt;<br>&lt;/textarea&gt;<br>&lt;text v-if=&quot;count&quot; class=&quot;u-textarea__count&quot;&gt;<br>&#123;&#123; valueCopy.length &#125;&#125;/&#123;&#123; maxlength &#125;&#125;<br>&lt;/text&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name: &quot;s-textarea&quot;,<br>components: &#123;&#125;,<br><br>props: &#123;<br>value: &#123;<br>type: String,<br>default: &quot;&quot;<br>&#125;,<br>placeholder: &#123;<br>type: String,<br>default: &quot;请输入&quot;<br>&#125;,<br>maxlength: &#123;<br>type: String || Number,<br>default: &#x27;-1&#x27;<br>&#125;,<br>disabled: &#123;<br>type: Boolean,<br>default: false<br>&#125;,<br>count: &#123;<br>type: Boolean,<br>default: false<br>&#125;,<br>height: &#123;<br>type: String,<br>default: &#x27;120&#x27;<br>&#125;<br>&#125;,<br>data() &#123;<br>return &#123;<br>valueCopy: &quot;&quot;<br>&#125;;<br>&#125;,<br><br>computed: &#123;&#125;,<br><br>watch: &#123;<br>value: &#123;<br>handler(val) &#123;<br>this.valueCopy = val;<br>&#125;,<br>immediate: true<br>&#125;,<br>valueCopy: &#123;<br>handler(val) &#123;<br>this.$emit(&quot;input&quot;, val);<br>this.$emit(&quot;change&quot;, val);<br>&#125;<br>&#125;<br>&#125;,<br><br>created() &#123;&#125;,<br><br>mounted() &#123;&#125;,<br><br>methods: &#123;<br>input(e) &#123;<br>let value = e.detail.value;<br>console.log(&quot;value-------&quot;, value);<br>if (this.maxlength &gt; 0 &amp;&amp; value.length &gt; this.maxlength) &#123;<br>this.$nextTick(() =&gt; &#123;<br>this.valueCopy = value.substr(0, this.maxlength);<br>&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>uniapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Component</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/02-Component/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/02-Component/</url>
    
    <content type="html"><![CDATA[<h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><p>在 React 世界中，一切皆组件，组件可分为类（Class）组件，和函数（Function）组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">textClass</span> &#123;<br>  sayHello=<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, my name is alien&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state=&#123; <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;hello, my name is alien&#x27;</span> &#125;<br>    <span class="hljs-keyword">return</span>() &#123;<br>       <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span>&#x27;<span class="hljs-attr">50px</span>&#x27; &#125;&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.sayHello</span> &#125; &gt;</span> &#123; this.state.message &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">textFun</span> () &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello, world&#x27;</span><br>&#125;<br><span class="hljs-comment">// 函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FunComponent</span> () &#123;<br>  <span class="hljs-keyword">const</span> [ message, setMessage ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> setMessage(&#x27;hello, my name is alien&#x27;)  &#125; &gt;&#123; message &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>组件的本质就是类和函数，但是与常规的类和函数不同的是，<strong>组件承载了渲染视图的UI和更新视图的setState、useState等方法。</strong>React 在底层逻辑上会像正常实例化类和正常执行函数那样处理的组件</p><p>因此，函数与类上的特性在 React 组件上同样具有，比如原型链，继承，静态属性等，所以不要把 React 组件和类与函数独立开来。</p><h2 id="React-对组件的处理流程："><a href="#React-对组件的处理流程：" class="headerlink" title="React 对组件的处理流程："></a>React 对组件的处理流程：</h2><blockquote><p>对于类组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js中：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructClassInstance</span>(<span class="hljs-params"></span><br><span class="hljs-params">   workInProgress, <span class="hljs-comment">// 当前正在工作的 fiber 对象</span></span><br><span class="hljs-params">   ctor,           <span class="hljs-comment">// 我们的类组件</span></span><br><span class="hljs-params">   props           <span class="hljs-comment">// props</span></span><br><span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 实例化组件， 得到组件实例 instance</span><br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(props, context)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于函数组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js中：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current,            <span class="hljs-comment">// 当前函数组件对于的&#x27;fiber&#x27;，初始化</span></span><br><span class="hljs-params">  workInProgress,<span class="hljs-comment">// 当前正在工作的 fiber 对象</span></span><br><span class="hljs-params">  props,              <span class="hljs-comment">// 函数组件的第一个参数 props</span></span><br><span class="hljs-params">  secondArg,     <span class="hljs-comment">// 函数组件其他参数</span></span><br><span class="hljs-params">  nextRenderExpirationTime, <span class="hljs-comment">// 下次渲染过期时间</span></span><br><span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 执行我们的函数组件，得到 return 返回的 React.element 对象</span><br>    <span class="hljs-keyword">let</span> children = <span class="hljs-title class_">Component</span>(props, secondArg);<br><br>  &#125;<br></code></pre></td></tr></table></figure><p>在 React 调和渲染 fiber 节点的时候，如果发现 fiber tag 是 ClassComponent &#x3D; 1，则按照类组件逻辑处理，如果是 FunctionComponent &#x3D; 0 则按照函数组件逻辑处理。当然 React 也提供了一些内置的组件，比如说 Suspense、Profiler等。</p><h2 id="class类组件"><a href="#class类组件" class="headerlink" title="class类组件"></a>class类组件</h2><h3 id="类组件的定义"><a href="#类组件的定义" class="headerlink" title="类组件的定义"></a>类组件的定义</h3><p>在 class 组件中，除了继承 React.Component，底层还加入了 updater 对象，组件中调用的 setState 和 forceUpdate 本质上是调用了 updater 对象上的 enqueueSetState 和 enqueueForceUpdate 方法。</p><p>React 底层定义类组件</p><blockquote><p>react&#x2F;src&#x2F;ReactBaseClasses.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">props, context, updater</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props;      <span class="hljs-comment">// 绑定 props</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = context;  <span class="hljs-comment">// 绑定 context</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span> = emptyObject; <span class="hljs-comment">// 绑定 ref</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span> = updater || <span class="hljs-title class_">ReactNoopUpdateQueue</span>; <span class="hljs-comment">// 上面所属的 updater 对象</span><br>&#125;<br><span class="hljs-comment">// 绑定 setState 方法</span><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 绑定 forceupdate 方法</span><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forceUpdate</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueForceUpdate</span>(<span class="hljs-variable language_">this</span>, callback, <span class="hljs-string">&#x27;forceUpdate&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>类组件执行构造函数过程中会实例上绑定 props 和 context，初始化置空 refs 属性，原型链上绑定 setState、forceUpdate 方法。对于 updater，React 在实例化类组件之后会单独绑定 update 对象。</p><h3 id="React-类组件各个部分的功能"><a href="#React-类组件各个部分的功能" class="headerlink" title="React 类组件各个部分的功能"></a>React 类组件各个部分的功能</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...arg</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(...arg)                                        <span class="hljs-comment">// 执行 react 底层 Component 函数</span><br>  &#125;<br>  state = &#123;&#125;                                                <span class="hljs-comment">// state</span><br>    <span class="hljs-keyword">static</span> number = <span class="hljs-number">1</span>                                    <span class="hljs-comment">// 内置静态属性</span><br>    handleClick = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<span class="hljs-comment">// 方法：箭头函数方法直接绑定在 this 实例上</span><br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;              <span class="hljs-comment">// 生命周期</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Index</span>.<span class="hljs-property">number</span>,<span class="hljs-title class_">Index</span>.<span class="hljs-property">number1</span>) <span class="hljs-comment">// 打印 1 , 2 </span><br>  &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;                        <span class="hljs-comment">// 渲染函数</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span>&#x27;<span class="hljs-attr">50px</span>&#x27; &#125;&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.handerClick</span> &#125;  &gt;</span>hello,React!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><span class="hljs-title class_">Index</span>。number1 = <span class="hljs-number">2</span>                 <span class="hljs-comment">// 外置静态属性</span><br><span class="hljs-title class_">Index</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">handleClick</span> = <span class="hljs-function">()=&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>) <span class="hljs-comment">/* 方法: 绑定在 Index 原型链的 方法*/</span><br></code></pre></td></tr></table></figure><p>箭头函数是直接绑定在实例对象上的，而第二个 handleClick 是绑定在 prototype 原型链上的，它们的优先级是：实例对象上方法属性 &gt; 原型链对象上方法属性。点击 div 打印 111</p><h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><p>ReactV16.8 hooks 问世以来，对函数组件的功能加以强化，可以在 function 组件中，做类组件能做的一切事情，甚至完全取缔类组件。</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Index</span>.<span class="hljs-property">number</span>)<br>  <span class="hljs-keyword">const</span> [ message, setMessage ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br>  <span class="hljs-keyword">return</span>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setMessage(&#x27;let us learn React!&#x27;)  &#125; &gt; &#123; message &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">/* 返回值 作为渲染ui */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：不要尝试给函数组件 prototype 绑定属性或方法，即使绑定了也没有任何作用，因为 React 对函数组件的调用，是采用直接执行函数的方式，而不是通过 new 的方式。</p><h2 id="函数组件和类组件本质的区别"><a href="#函数组件和类组件本质的区别" class="headerlink" title="函数组件和类组件本质的区别"></a>函数组件和类组件本质的区别</h2><p><strong>对于类组件来说，底层只需要实例化一次，实例中保存了组件的 state 等状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。但是在函数组件中，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明</strong></p><p>为了能让函数组件可以保存一些状态，执行一些副作用钩子，React Hooks 应运而生，它可以帮助记录 React 中的函数组件的状态，处理一些额外的副作用。</p><h2 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h2><p>React 一共有 5 种主流通信方式</p><ol><li>props 和 callback 方式</li><li>ref 方式</li><li>React-redux 或 React-mobx 状态管理方式</li><li>context 上下文方式</li><li>event bus 事件总线</li></ol><p><strong>① props 和 callback 方式</strong></p><p>React 组件最基本的通信方式，父组件可以通过 props 将信息传递给子组件，子组件可以通过执行 props 中的回调函数 callback 来触发父组件的方法，实现父与子的消息通信。</p><p>父组件 -&gt; 通过自身 state 改变，重新渲染，传递 props -&gt; 通知子组件</p><p>子组件 -&gt; 通过调用父组件 props 方法 -&gt; 通知父组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; fatherSay, sayFather &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    </span><br><span class="language-xml">      我是子组件</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;我对父组件说&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">e</span>) =&gt;</span> sayFather(e.target.value) &#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br>functin <span class="hljs-title class_">Father</span>() &#123;<br>  <span class="hljs-keyword">const</span> [ childSay, setChildSay ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> [ fatherSay , setFatherSay  ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        我是父组件</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;我对子组件说&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">e</span>)=&gt;</span>setFatherSay(e.target.value) &#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">fatherSay</span>=<span class="hljs-string">&#123;fatherSay&#125;</span> <span class="hljs-attr">sayFather</span>=<span class="hljs-string">&#123;setChildSay&#125;/</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑤event bus事件总线</strong></p><p>当然利用 eventBus 也可以实现组件通信，但是在 React 中并不提倡用这种方式，提倡用 props 方式通信。eventBus 更适合用 React 做基础构建的小程序，比如 Taro。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BusService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><br><span class="hljs-comment">/* event Bus  */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> [ fatherSay , setFatherSay ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123; <br>        <span class="hljs-title class_">BusService</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;fatherSay&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;  <span class="hljs-comment">/* 事件绑定 , 给父组件绑定事件 */</span><br>            <span class="hljs-title function_">setFatherSay</span>(value)<br>       &#125;)<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-title class_">BusService</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;fatherSay&#x27;</span>) <span class="hljs-comment">/* 解绑事件 */</span> &#125;<br>    &#125;,[])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;son&#x27;</span> &gt;</span></span><br><span class="language-xml">         我是子组件</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;我对父组件说&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">e</span>)=&gt;</span> BusService.emit(&#x27;childSay&#x27;,e.target.value)  &#125;   /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">/* 父组件 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> [ childSay , setChildSay ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-comment">/* 事件绑定 , 给子组件绑定事件 */</span><br>        <span class="hljs-title class_">BusService</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;childSay&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>             <span class="hljs-title function_">setChildSay</span>(value)<br>        &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-title class_">BusService</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;childSay&#x27;</span>) <span class="hljs-comment">/* 解绑事件 */</span> &#125;<br>    &#125;,[])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;box father&quot;</span> &gt;</span></span><br><span class="language-xml">        我是父组件</span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;我对子组件说&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">e</span>)=&gt;</span> BusService.emit(&#x27;fatherSay&#x27;,e.target.value) &#125;   /&gt;</span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>  /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样做可以跨层级，不会受到 React 父子组件层级的影响。</p><p>但是有如下缺点：</p><ul><li>需要手动绑定和解绑</li><li>对于小型项目还好，但是对于中大型项目，这种方式的组件通信，会照成牵一发动全身的影响，而且后期难以维护，组件之间的状态也是未知的。</li><li>一定程度上违背了 React 的数据流向原则</li></ul><h2 id="组件的强化方式"><a href="#组件的强化方式" class="headerlink" title="组件的强化方式"></a>组件的强化方式</h2><p><strong>①类组件继承</strong></p><p>对于类组件的强化，首先想到的是继承方式。因为 React 中类组件，有良好的继承属性，所以可以针对一些基础组件，首先实现一部分基础功能，再针对项目要求进行有方向的<strong>改造</strong></p><p>基础组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 人类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello , i am person&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>)  &#125;<br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">/* 吃饭 */</span> &#125;<br>    <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">/* 睡觉 */</span>  &#125;<br>    <span class="hljs-title function_">ddd</span>(<span class="hljs-params"></span>)&#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;打豆豆&#x27;</span>)  <span class="hljs-comment">/* 打豆豆 */</span> &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            大家好，我是一个person</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 程序员 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Programmer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello , i am Programmer too&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  &#125;<br>    <span class="hljs-title function_">code</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/* 敲代码 */</span> &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;</span> &#123; <span class="hljs-attr">marginTop:</span>&#x27;<span class="hljs-attr">50px</span>&#x27; &#125; &#125; &gt;</span></span><br><span class="language-xml">            &#123; super.render() &#125; &#123; /* 让 Person 中的 render 执行 */ &#125;</span><br><span class="language-xml">            我还是一个程序员！    &#123; /* 添加自己的内容 */ &#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Programmer</span><br></code></pre></td></tr></table></figure><p>优点：</p><ol><li>可以控制父类 render，还可以添加一些其他的渲染内容</li><li>可以共享父类方法，还可以添加额外的方法和属性</li></ol><p>注意：</p><p>sate 和生命周期会被继承后的组件修改。Person 组件中的 componentDidMount 生命周期不会被执行。</p><p><strong>②函数组件自定义 Hooks</strong></p><p><strong>③HOC高阶组件</strong></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Component</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSX</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/01-JSX/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/01-JSX/</url>
    
    <content type="html"><![CDATA[<h1 id="JSX-的本质"><a href="#JSX-的本质" class="headerlink" title="JSX 的本质"></a>JSX 的本质</h1><p>JSX 元素节点会被 <code>babel</code> 编译成 <code>React Element</code> 形式。<br /><code>React.createElement</code> 的用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  type,<br>  [props],<br>  [...children]<br>)<br></code></pre></td></tr></table></figure><p><code>createElement</code>参数：</p><ul><li>第一个参数： 如果时组件类型，会传入组件对应的类或者函数；如果时 dom 元素，传入 div 或者 p 这种元素标签名字的字符串</li><li>第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props。</li><li>其他参数：依次为 children ，根据顺序排列</li></ul><p>demo：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextComponent</span> /&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello,world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="hljs-keyword">let</span> us learn <span class="hljs-title class_">React</span>!<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>上面的代码会被 babel 先编译成：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>,<br>       <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">TextComponent</span>, <span class="hljs-literal">null</span>),<br>       <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;hello,world&quot;</span>),<br>       <span class="hljs-string">&quot;let us learn React!&quot;</span><br>   )<br></code></pre></td></tr></table></figure><h1 id="JSX-的转换规则"><a href="#JSX-的转换规则" class="headerlink" title="JSX 的转换规则"></a>JSX 的转换规则</h1><table><thead><tr><th><code>jsx</code>元素类型</th><th><code>react.createElement </code>转换后</th><th><code>type</code> 属性</th></tr></thead><tbody><tr><td><code>element</code>元素类型</td><td><code>react element</code>类型</td><td>标签字符串，例如 <code>div</code></td></tr><tr><td><code>fragment</code>类型</td><td><code>react element</code>类型</td><td><code>symbolreact.fragment</code>类型</td></tr><tr><td>文本类型</td><td>直接字符串</td><td>无</td></tr><tr><td>数组类型</td><td>返回数组结构，里面元素被<code>react.createElement</code>转换</td><td>无</td></tr><tr><td>组件类型</td><td><code>react element</code>类型</td><td>组件类或者组件函数本身</td></tr><tr><td>三元运算 &#x2F; 表达式</td><td>先执行三元运算，然后按照上述规则处理</td><td>看三元运算返回结果</td></tr><tr><td>函数执行</td><td>先执行函数，然后按照上述规则处理</td><td>看函数执行返回结果</td></tr></tbody></table><h1 id="JSX-经过-React-底层调和处理后"><a href="#JSX-经过-React-底层调和处理后" class="headerlink" title="JSX 经过 React 底层调和处理后"></a>JSX 经过 React 底层调和处理后</h1><p> 最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。  <br />React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 函数组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 初始化的时候不知道是函数组件还是类组件 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>;                <span class="hljs-comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>;              <span class="hljs-comment">// 对应  ReactDOM.createPortal 产生的 Portal </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;           <span class="hljs-comment">// dom 元素 比如 &lt;div&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;                <span class="hljs-comment">// 文本节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;                <span class="hljs-comment">// 对应 &lt;React.Fragment&gt; </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;                    <span class="hljs-comment">// 对应 &lt;React.StrictMode&gt;   </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;         <span class="hljs-comment">// 对应 &lt;Context.Consumer&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;        <span class="hljs-comment">// 对应 &lt;Context.Provider&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;             <span class="hljs-comment">// 对应 React.ForwardRef</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;               <span class="hljs-comment">// 对应 &lt;Profiler/ &gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;      <span class="hljs-comment">// 对应 &lt;Suspense&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;          <span class="hljs-comment">// 对应 React.memo 返回的组件</span><br></code></pre></td></tr></table></figure><p><strong>demo：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> toLearn = [ <span class="hljs-string">&#x27;react&#x27;</span> , <span class="hljs-string">&#x27;vue&#x27;</span> , <span class="hljs-string">&#x27;webpack&#x27;</span> , <span class="hljs-string">&#x27;nodejs&#x27;</span>  ]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">TextComponent</span> = (<span class="hljs-params"></span>)=&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> hello , i am function component <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    status = <span class="hljs-literal">false</span> <span class="hljs-comment">/* 状态 */</span><br>    renderFoot=<span class="hljs-function">()=&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> i am foot<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">/* 以下都是常用的jsx元素节 */</span><br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span>&#x27;<span class="hljs-attr">100px</span>&#x27; &#125;&#125;   &gt;</span></span><br><span class="language-xml">            &#123; /* element 元素类型 */ &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello,world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            &#123; /* fragment 类型 */ &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 👽👽 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><br><span class="language-xml">            &#123; /* text 文本类型 */ &#125;</span><br><span class="language-xml">            my name is alien </span><br><span class="language-xml">            &#123; /* 数组节点类型 */ &#125;</span><br><span class="language-xml">            &#123; toLearn.map(item=&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> ) &#125;</span><br><span class="language-xml">            &#123; /* 组件类型 */ &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">TextComponent</span>/&gt;</span></span><br><span class="language-xml">            &#123; /* 三元运算 */  &#125;</span><br><span class="language-xml">            &#123; this.status ? <span class="hljs-tag">&lt;<span class="hljs-name">TextComponent</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>三元运算<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;</span><br><span class="language-xml">            &#123; /* 函数执行 */ &#125; </span><br><span class="language-xml">            &#123; this.renderFoot() &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JSX 调和之后形成的 fiber 结构图</strong><br /><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/JSX/jsx.png" alt="image.png"><br />fiber 对应关系：</p><ul><li>child： 一个由父级 fiber 指向子级 fiber 的指针。</li><li>return：一个子级 fiber 指向父级 fiber 的指针。</li><li>sibling: 一个 fiber 指向下一个兄弟 fiber 的指针</li></ul><p>注意：</p><ul><li>对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；</li><li>map 返回数组结构，作为 fragment 的子节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>JSX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>State</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/03-State/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/03-State/</url>
    
    <content type="html"><![CDATA[<h2 id="setState的基本过程"><a href="#setState的基本过程" class="headerlink" title="setState的基本过程"></a>setState的基本过程</h2><ul><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code>（<code>UNSAFE_componentWillUpdate</code> 只能在 React 17 版本及以下继续使用，未来被抛弃：原因是在 React 18 的 Concurrent 模式下和当前的 Legacy 模式下的表现不一致）</li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><p>当 <code>shouldComponentUpdate</code> 执行时，返回 true，进行下一步，<code>this.state</code> 没有被更新，返回 <code>false</code>，停止，更新 <code>this.state</code></p><p>当 <code>componentWillUpdate </code>被调用时候，<code>this.state</code> 也没有被更新</p><p>直到 <code>render </code>被调用时候，<code>this.state</code> 才被更新。</p><p>总之，直到下一次<code>render</code>函数调用(或者下一次 <code>shouldComponentUpdate</code>e返回 <code>false</code> 时)才能得到更新后的this.state</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><code>state </code>中应该只保存和渲染有关的状态。 </li><li><code>setState </code>可能会引发不必要的渲染。 </li><li><code>setState </code>是修改其中的部分状态，相当于<code>Object.assign</code>，只是覆盖，不会减少原来的状态<br><code>replaceState</code>是完全替换原来的状态，相当于赋值，将原来的 <code>state</code>替换为另一个对象，如果新状态属性减少，那么<code>state</code>中就没有这个状态了 </li><li>调用<code>setState</code>之后，<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code>、<code>componentDidUpdate </code>等生命周期函数会依次被调用（如果<code>shouldComponentUpdate</code>没有返回  false的话），如果我们在<code>render</code>、<code>componentWillUpdate</code>或<code>componentDidUpdate</code>中调用了<code>setState</code>方法，那么可能会造成循环调用，最终导致浏览器内存占满后崩溃</li></ul><p>在不同的执行环境下，或者不同的 React 模式下，State 更新流程都是不同的。</p><p>React是有多种模式的，基本平时用的都是 <code>legacy</code> 模式下的 React，除了 <code>legacy</code>模式，还有 <code>blocking</code>模式和 <code>Concurrent</code>模式，<code>blocking</code>可以视为 <code>Concurrent</code>的优雅降级版本和过渡版本，React 最终目的，不久的未来将以 <code>Concurrent </code>模式作为默认版本，这个模式下会开启一些新功能。</p><p>对于 Concurrent 模式下，会采用不同 State 更新逻辑。 React 18 版本，concurrent 将会作为一个稳定的功能出现。</p><p>以下主要是 legacy 模式下的 State 更新逻辑。</p><h2 id="class-组件中的-state"><a href="#class-组件中的-state" class="headerlink" title="class 组件中的 state"></a>class 组件中的 state</h2><h3 id="setState用法"><a href="#setState用法" class="headerlink" title="setState用法"></a>setState用法</h3><p>React 项目中的 UI 的改变来源于 state 改变，类组件中 setState 是更新组件，渲染视图的主要方式</p><p><strong>基本用法：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">State(<span class="hljs-params">obj</span>, <span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数：当 obj 为一个对象，则为即将合并的 state；如果 obj 是一个函数，那么当前组件的 state 和 props 将作为参数，返回值用于合并新的 state。 </li><li>第二个参数 callback：callback 为一个函数，函数执行上下文中可以获取当前 setState 更新后的最新 state 的值，可以作为依赖 state 变化的副作用函数，可以用来做一些基于 DOM 的操作。 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 第一个参数为 function 类型<br>this.<span class="hljs-built_in">set</span>State((<span class="hljs-keyword">state</span>, props) =&gt; &#123;<br>  return &#123; number: <span class="hljs-number">1</span> &#125;<br>&#125;)<br>// 第一个参数为 object 类型<br>this.<span class="hljs-built_in">set</span>State(&#123; number: <span class="hljs-number">1</span> &#125;, () =&gt; &#123;<br>  console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.number) // 获取最新的 number<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="Legacy-模式下的-setState-流程"><a href="#Legacy-模式下的-setState-流程" class="headerlink" title="Legacy 模式下的 setState 流程"></a>Legacy 模式下的 setState 流程</h3><p>假如上一次事件中触发一次如上 <code>setState</code>，在 React 底层主要做了一些事情。 </p><ul><li>首先，<code>setState</code> 会产生当前更新的优先级（老版本用 <code>expirationTime</code>，新版本用 <code>lane</code>）。</li><li>接下来 <code>React</code>会从 <code>fiber Root</code> 根部 <code>fiber </code>向下调和子节点，调和阶段将对比发生更新的地方，更新对比 <code>expiration Time</code>，找到发生更新的组件，合并 <code>state </code>，然后触发 <code>render</code>函数，得到新的 UI 视图层，完成 <code>render</code>阶段。</li><li>接下来到 <code>commit</code>阶段，<code>commit</code> 阶段，替换真实 <code>DOM</code>，完成此次更新流程。</li><li>此时依然在 cmomit 阶段，会执行 <code>setState</code> 中 <code>callback</code>函数，如上的 <code>() =&gt; &#123; console.log(this.state.number) &#125;</code>，到此完成了一次 <code>setState</code>全过程。</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/State/state01.png" alt="图片.png"></p><p><code>render</code>阶段 <code>render</code>函数执行 -&gt; <code>commit</code>阶段真实 DOM 替换 -&gt; <code>setState</code>回调函数执行 <code>callback</code>。</p><p><strong>类组件如何限制 state 更新视图</strong></p><p>对于类组件如何限制 <code>state</code>带来的更新作用？</p><ul><li><code>pureComponent</code>可以对 <code>state</code>和 <code>props</code>进行浅比较，如果没有发生变化，那么组件不更新。</li><li><code>shouldComponentUpdate</code> 生命周期可以通过判读前后 <code>state</code>变化来决定组件需不需要更新，需要更新返回 true，否则返回 false</li></ul><p><strong>setState原理揭秘</strong></p><p>类组件初始化过程中绑定了负责更新的 <code>Updater</code> 对象，对于如果调用 setState 方法，实际上是 React 底层调用 Updater 对象上的 <code>enqueueSetState</code>（入待更新队列）方法。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简化版</span><br><span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 每一次调用 &#x27;setState&#x27;，react 都会创建一个 update 里面保存</span><br>  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(expirationTime, suspenseConfig);<br>  <span class="hljs-comment">// callback 可以理解为 setState 回调函数，第二个参数</span><br>  callback &amp;&amp; (update.<span class="hljs-property">callback</span> = callback)<br>  <span class="hljs-comment">// enqueueUpdate 把当前的 update 传入当前 fiber，待更新队列中</span><br>  <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);<br>  <span class="hljs-comment">// 开始调度更新</span><br>  <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>enqueueSetState</code>的作用实际就是创建一个 <code>update</code>，然后放入当前 <code>fiber</code>对象的待更新队列中，最后开启调度更新，进入上述更新流程。</p><h4 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h4><p>正常 <strong>state 更新、UI 交互</strong>，都离不开用户的事件，比如点击事件，表单输入等，React 是采用了事件合成的形式，每一个事件都是由 React 事件系统统一调度的，State 的批量更新正是和<strong>事件系统</strong>息息相关的</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 legacy 模式下，所有的事件都将经过此函数统一处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventForLegacyPluginEventSystem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// handleTopLevel 事件处理函数</span><br>  <span class="hljs-title function_">batchedEventUpdates</span>(handleTopLevel, bookKeeping);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h4><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn, a</span>) &#123;<br>  <span class="hljs-comment">// 开启批量更新</span><br>  isBatchingEventUpdates = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 这里执行了事件处理函数，比如在一次点击事件中触发 setState，那么它将在这个函数内执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchedEventUpdatesImpl</span>(fn, a, b);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// try 里面 return 不会影响 finally 执行</span><br>    <span class="hljs-comment">// 完成一次事件，批量更新</span><br>    isSatchingEventUpdates = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 React 事件执行之前通过 <code>isBatchingEventUpdates=true</code>打开开关，开启事件批量更新，当该事件结束，再通过 <code>isBatchingEventUpdates=false</code>关闭开关，然后在 <code>scheduleUpdateOnFiber</code>中根据这个开关来确定是否进行批量更新。</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  state = &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> &#125;<br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">steState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback1&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> )<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback2&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> )<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback3&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> )<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123; this.state.number &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.handleClick</span> &#125;&gt;</span> &#123;number++&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击打印： <strong>0, 0, 0  callback1 1 ,callback2 1 ,callback3 1</strong></p><p><strong>React 上下文执行栈图解</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/State/state03.png" alt="图片.png"></p><h4 id="打破批量更新规则（异步环境）"><a href="#打破批量更新规则（异步环境）" class="headerlink" title="打破批量更新规则（异步环境）"></a>打破批量更新规则（异步环境）</h4><p><strong>异步操作</strong>里面的<strong>批量更新规则会被打破</strong>：</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;,<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback1&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)  &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;,<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback2&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)  &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;,<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;callback3&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)  &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>打印：**1，2，3，callback1 1 , 1, callback2 2 , 2,callback3 3 **</p><p><strong>React 上下文执行栈图解</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/State/state02.png" alt="图片.png"></p><h4 id="在异步环境下，继续开启批量更新"><a href="#在异步环境下，继续开启批量更新" class="headerlink" title="在异步环境下，继续开启批量更新"></a>在异步环境下，继续开启批量更新</h4><p>React-Dom 中提供了批量更新方法 <code>unstable_batchedUpdates</code>，可以手动批量更新，可以将上述 setTimeout 里面的内容做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">const</span> &#123; unstable_batchedUpdates &#125; = <span class="hljs-title class_">ReactDOM</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">unstable_batchedUpdates</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span> + <span class="hljs-number">1</span> &#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>打印： <strong>0 , 0 , 0 , callback1 1 , callback2 1,callback3 1</strong></p><p>在实际工作中，unstable_batchedUpdates 可用于 Ajax 数据交互之后，合并多次 setState，或者多次 useState。因为，所有的数据交互都是在异步环境下，如果没有批量更新处理，一次数据交互多次改变 state 会促使视图多次渲染。</p><h4 id="提升更新优先级"><a href="#提升更新优先级" class="headerlink" title="提升更新优先级"></a>提升更新优先级</h4><p>React-dom 提供了 <code>flushSync</code>，<code>flushSync</code>可以将回调函数中的更新任务，放在一个较高的优先级中。React 设定了很多不同优先级的更新任务。如果一次更新任务在 <code>flushSync</code>回调函数内部，那么将获得一个较高优先级的更新。</p><p><strong>flushSync说明</strong>：</p><p><code>flushSync</code>在同步条件下，会合并之前的 <code>setState | useState</code>，可以理解成，如果发现了 <code>flushSync</code>，就会先执行更新，如果之前由未更新的 <code>setState | useState</code>，就会被合并到一起。</p><p>继续修改上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">handerClick=<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-number">1</span> &#125;)<br>  &#125;)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; number； <span class="hljs-number">2</span> &#125;)<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-number">3</span> &#125;)<br>  &#125;)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">number</span>: <span class="hljs-number">4</span> &#125;)<br>&#125;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>)<br>  <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>打印 <strong>3 4 1</strong></p><ul><li>首先 <code>flushSync</code> <code>this.setState(&#123; number: 3 &#125;)</code> 设定了一个高优先级的更新，所以 2 和 3 被批量更新到 3，所以 3 先被打印。</li><li>更新为 4</li><li>最后更新 setTimeout 中的 number&#x3D; 1</li></ul><p>React 同一级别<strong>更新优先级</strong>关系是：</p><p>flushSync 中的 setState &gt; 正常执行上下文中 setState &gt; setTimeout，Promise 中的 setState</p><h2 id="funtion-组件中的-state"><a href="#funtion-组件中的-state" class="headerlink" title="funtion 组件中的 state"></a>funtion 组件中的 state</h2><p>React-hooks 正式发布以后，useState 可以使函数组件像类组件一样拥有 state，也就说明函数组件可以通过 useState 改变 UI 视图。</p><h3 id="useState-用法"><a href="#useState-用法" class="headerlink" title="useState 用法"></a>useState 用法</h3><p><strong>基本用法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[ state, dispatch ] = <span class="hljs-title function_">useState</span>(initData)<br></code></pre></td></tr></table></figure><ul><li>state，目的提供给 UI ，作为渲染视图的数据源</li><li>dispatch 改变 state 函数，可以理解为推动函数组件渲染的渲染函数</li><li>initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。第二种情况是函数，函数返回值作为 useState 初始化的值。</li></ul><p><strong>initData 为非函数的情况：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 0 作为初始值</span><br><span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>initData 为函数的情况</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [ number, setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// props 中 a = 1 state 为 0-1 随机数；a = 2 state 为 1-10随机数，否则 state 为 1-100随机数</span><br>  <span class="hljs-keyword">if</span>(props.<span class="hljs-property">a</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>  <span class="hljs-keyword">if</span>(props.<span class="hljs-property">a</span> === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于 dispatch 的参数，也有两种情况：</p><ul><li>第一种非函数情况，此时将作为新的值，赋给 state，作为下一次渲染使用：</li><li>第二种是函数的情况，如果 dispatch 的参数为一个函数，这里可以称它为 reducer，reducer 参数，是上一次返回最新的 state，返回值作为新的 state。</li></ul><p><strong>dispatch 参数是一个非函数值</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-literal">[ <span class="hljs-identifier">number</span>, <span class="hljs-identifier">setNumber</span> ]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>use<span class="hljs-constructor">State(0)</span><br><span class="hljs-comment">// 一个点击事件</span><br>const handleClick =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>  set<span class="hljs-constructor">Nmuber(1)</span><br>  set<span class="hljs-constructor">Nmuber(2)</span><br>  set<span class="hljs-constructor">Nmuber(3)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dispatch 参数是一个函数值</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [ number , <span class="hljs-built_in">set</span>Numbsr ] = React.useState(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> handleClick=()=&gt;&#123;<br>  <span class="hljs-built_in">set</span>Number((<span class="hljs-keyword">state</span>)=&gt; <span class="hljs-keyword">state</span> + <span class="hljs-number">1</span>) // <span class="hljs-keyword">state</span> -&gt; <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br>  <span class="hljs-built_in">set</span>Nmuber(<span class="hljs-number">8</span>) // <span class="hljs-keyword">state</span> -&gt; <span class="hljs-number">8</span><br>  <span class="hljs-built_in">set</span>Nmuber((<span class="hljs-keyword">state</span>)=&gt; <span class="hljs-keyword">state</span> + <span class="hljs-number">1</span>) // <span class="hljs-keyword">state</span> -&gt; <span class="hljs-number">8</span> + <span class="hljs-number">1</span> = <span class="hljs-number">9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="监听-state-变化"><a href="#监听-state-变化" class="headerlink" title="监听 state 变化"></a>监听 state 变化</h3><p>类组件 setState 中，有第二个参数 callback 或者生命周期函数 componentDidUpdate 可以检测监听到 state 改变或是组件更新。</p><p>函数组件中，useEffect 检测监听 state 改变或组件更新：</p><p>通常把 state 作为依赖项传入 useEffect 第二个参数 deps，但是注意 useEffect 初始化会默认执行一次。</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params">props</span>)&#123;<br>    <span class="hljs-keyword">const</span> [ <span class="hljs-built_in">number</span> , setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">/* 监听 number 变化 */</span><br>    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听number变化，此时的number是:  &#x27;</span> + <span class="hljs-built_in">number</span> )<br>    &#125;,[ <span class="hljs-built_in">number</span> ])<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handerClick</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>        <span class="hljs-comment">/** 高优先级更新 **/</span><br>        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>) <br>        &#125;)<br>        <span class="hljs-comment">/* 批量更新 */</span><br>        <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>) <br>        <span class="hljs-comment">/* 滞后更新 ，批量更新规则被打破 */</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">3</span>) <br>        &#125;)<br><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">number</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> &#123; number &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handerClick</span> &#125;  &gt;</span>number++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/State/state04.png" alt="图片.png"></p><p><code>dispatch</code>更新特点：</p><p>在函数组件中，dispatch 更新效果和类组件是一样的，但是 useState 有一点值得注意，就是当调用改变 state 的函数 dispatch，在本次函数执行上下文中，是获取不到最新的 state 值的，</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [ number , setNumber ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">2</span>) <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number) <br>  &#125;)<br>  <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">1</span>) <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">setNumber</span>(<span class="hljs-number">3</span>) <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number)<br>  &#125;)   <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果：0 0 0</strong></p><p>因为函数组件更新就是函数的执行，在函数一次执行过程中，函数内部所有变量重新声明，所以改变的 state，只有在下一次函数组件执行时才会被更新。所以在如上同一个函数执行上下文中，number 一直为 0 ，无论怎么打印，都拿不到最新的 state。</p><p><strong>useState 注意事项</strong></p><p>在使用 useState 的 dispatchAction 更新 state 的时候，如果传入相同的 state，这样会使视图不更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [ state, dispatchState ] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alien&#x27;</span> &#125;)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-comment">// 点击按钮，视图没有更新</span><br>    state.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Alien&#x27;</span><br>    <span class="hljs-title function_">dispatchState</span>(state) <span class="hljs-comment">// 直接改变 &#x27;state&#x27;，在内存中指向的地址相同，</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123; state.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">handleClick</span> &#125;&gt;</span>changeName++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，点击按钮发现视图没有改变，因为：</p><p>在 useState 的 dispatchAction 处理逻辑中，会浅比较两次 state，发现 state 相同，不会开启更新调度任务；demo 中两次 state 指向了相同的内存空间（地址相同），所以默认为 state 相等，就不会发生视图更新。</p><p>解决方案：dispatchState 换成 dispatchState({ …state }) 浅拷贝了对象，重新申请了一个内存空间（地址不同）</p><h2 id="类组件中的-setState-和函数组件中的-useState-的异同："><a href="#类组件中的-setState-和函数组件中的-useState-的异同：" class="headerlink" title="类组件中的 setState 和函数组件中的 useState 的异同："></a>类组件中的 <code>setState</code> 和函数组件中的 <code>useState</code> 的异同：</h2><ul><li>相同点： <ul><li>setState 和 useState 更新视图，底层都调用了 scheduleUpdateOnFiber 方法，而且事件驱动情况下都有批量更新规则。</li></ul></li><li>不同点： <ul><li>在不是 pureComponent 组件模式下，setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。</li><li>setState 有专门监听 state 变化的回调函数 callback，可以获取最新的 state ；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。</li><li>setState 在底层处理逻辑上主要是和老 state 进行合并处理，而 useState 更倾向于重新赋值。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>state</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Props</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/04-Props/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/04-Props/</url>
    
    <content type="html"><![CDATA[<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>props 是 React 组件通信最重要的手段，一次 render 的过程，就是调用 React.createElement 形成新的 element 过程，新的 element 上就会有新的 props 属性，这个新的 props 就是重新渲染视图的关键所在。</p><h2 id="props-概念"><a href="#props-概念" class="headerlink" title="props 概念"></a>props 概念</h2><p>无论是 函数子组件还是类子组件，父组件绑定在它们标签里的属性&#x2F;方法，最终会变成 props 传递给它们。除了 ref 或者 key，React 会在底层做一些额外的处理。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* children 组件 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChidrenComponent</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> In this chapter, let&#x27;s learn about react props ! <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">/* props 接受处理 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PropsComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;_this&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;  children , mes , renderName , say ,<span class="hljs-title class_">Component</span> &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>    <span class="hljs-keyword">const</span> renderFunction = children[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">const</span> renderComponent = children[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">/* 对于子组件，不同的props是怎么被处理 */</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123; renderFunction() &#125;</span><br><span class="language-xml">      &#123; mes &#125;</span><br><span class="language-xml">    &#123; renderName() &#125;</span><br><span class="language-xml">    &#123; renderComponent &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> say() &#125; &gt; change content <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br>&#125;<br><span class="hljs-comment">/* props 定义绑定 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  state=&#123;  <br>    <span class="hljs-attr">mes</span>: <span class="hljs-string">&quot;hello,React&quot;</span><br>  &#125;<br>  node = <span class="hljs-literal">null</span><br>  say= <span class="hljs-function">() =&gt;</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">mes</span>:<span class="hljs-string">&#x27;let us learn React!&#x27;</span> &#125;)<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">PropsComponent</span>  </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">mes</span>=<span class="hljs-string">&#123;this.state.mes&#125;</span>  // ① <span class="hljs-attr">props</span> <span class="hljs-attr">作为一个渲染数据源</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">say</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.say</span>  &#125;     // ② <span class="hljs-attr">props</span> <span class="hljs-attr">作为一个回调函数</span> <span class="hljs-attr">callback</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">Component</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">ChidrenComponent</span> &#125; // ③ <span class="hljs-attr">props</span> <span class="hljs-attr">作为一个组件</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">renderName</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> my name is alien <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125; // ④ props 作为渲染函数</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">      &#123; ()=&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello,world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  &#125; &#123; /* ⑤render props */ &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChidrenComponent</span> /&gt;</span>             &#123; /* ⑥render component */ &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">PropsComponent</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>① props 作为一个子组件渲染数据源。</li><li>② props 作为一个通知父组件的回调函数。</li><li>③ props 作为一个单纯的组件传递。</li><li>④ props 作为渲染函数。</li><li>⑤ render props ， 和④的区别是放在了 children 属性上。</li><li>⑥ render component 插槽组件。</li></ul><p>PropsComponent 如果是一个类组件，那么可以直接通过 this.props 访问到它：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Props/props01.png" alt="图片.png"></p><p>在标签内部的属性和方法会直接绑定在 props 对象的属性上，对于组件的插槽会被绑定在 props 的 children 属性中。</p><h2 id="React-如何定义的-props"><a href="#React-如何定义的-props" class="headerlink" title="React 如何定义的 props"></a>React 如何定义的 props</h2><p><strong>在 React 组件层级 props 的作用：</strong></p><p>父组件的 props 可以把数据层传递给子组件去渲染消费。子组件可以通过 props 中的 callback，来向父组件传递信息。还有一种可以将视图容器作为 props 进行渲染。</p><p><strong>从 React 更新机制中 props 的作用：</strong></p><p>props 在组件的更新中起到了非常重要的角色，在 fiber 调和阶段中，diff 可以说是 React 更新的驱动器。Vue 中基于响应式，数据的变化，会颗粒化到组件层级，通知其更新；但是在 React 中，无法直接检测出数据更新波及到的范围，props 可以作为组件是否更新的重要准则，变化即更新，于是有了 PureComponent，memo 等性能优化方案。</p><p><strong>从 React 插槽层面 props 的作用：</strong></p><p>React 可以把组件的闭合标签里的插槽，转化成 children 属性。</p><h2 id="监听-props-改变"><a href="#监听-props-改变" class="headerlink" title="监听 props 改变"></a>监听 props 改变</h2><p><strong>类组件中：</strong></p><ul><li>componentWillReceiveProps 可以作为监听 props 的生命周期，但是 React 已经不推荐使用 componentWillReceiveProps，未来可能会被废弃，因为这个生命周期超出了 React 的可控范围内，可能引起多次执行等情况发生。于是出现了它的替代方案 getDerivedStateFromProps，</li></ul><p><strong>函数组件中：</strong></p><ul><li>函数组件中可以使用 useEffect 来作为 props 改变后的监听函数。（注意：useEffect 初始化会默认执行一次） <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// props 中 number 改变，执行这个副作用</span><br>&#125;,[ props.<span class="hljs-property">number</span> ])<br></code></pre></td></tr></table></figure></li></ul><h2 id="props-children-模式"><a href="#props-children-模式" class="headerlink" title="props children 模式"></a>props children 模式</h2><p>props + children 在 React 中非常常用，尤其一些开源库一直在用：react-router 中的 Switch 和 Route，antd 中的 Form 和 FormItem。</p><p><strong>props 插槽组件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Container</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">Container</span>&gt;<br></code></pre></td></tr></table></figure><p>在 Container 组件中，通过 props.children 属性访问到 Children 组件，作为 React element 对象。</p><p>作用：</p><ol><li>可以根据需要，控制 Children 是否渲染。</li><li>Container 可以用 React.cloneElement 强化 props（混入新的 props），或者修改 Children 的子元素。</li></ol><p><strong>render props 模式</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span><br>    &#123; (ContainerProps) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> &#123; <span class="hljs-attr">...ContainerProps</span> &#125; /&gt;</span> &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种情况，在 Container 中，props.children 属性访问到的是函数，并不是 React element对象，针对这种情况，像下面这种情况下 children 是不能直接渲染的，直接渲染会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Container</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> props.<span class="hljs-property">children</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果上述直接这么写，汇报如下错误：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Props/props02.png" alt="图片.png"></p><p>改成如下方式，就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Container</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContainerProps</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    <span class="hljs-attr">mes</span>: <span class="hljs-string">&#x27;let us learn react&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> props.<span class="hljs-title function_">children</span>(<span class="hljs-title class_">ContainerProps</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的作用是：</p><ul><li>根据需要控制 Children 渲染与否。</li><li>可以将需要传给 Children 的 props 直接通过函数参数的方式传递给执行函数 children。</li></ul><p><strong>混合模式</strong></p><p>如果 Container 的 children 既有函数也有组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Container</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children</span> /&gt;</span></span><br>  &#123; <span class="hljs-function">(<span class="hljs-params">ContainerProps</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children</span> &#123;<span class="hljs-attr">...ContainerProps</span>&#125; <span class="hljs-attr">name</span> = <span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">hahaha</span>&#x27;&#125;/&gt;</span></span> &#125;<br>&lt;/<span class="hljs-title class_">Container</span>&gt;<br></code></pre></td></tr></table></figure><p>首先在 Container 里面打印 children：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Props/props03.png" alt="图片.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Children</span> = (<span class="hljs-params">props</span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello,my name is &#123; props.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; props.mes &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Container</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContainerProps</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    <span class="hljs-attr">mes</span>: <span class="hljs-string">&#x27;let us learn react&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> props.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">React</span>.<span class="hljs-title function_">isValidElement</span>(item))&#123; <span class="hljs-comment">// 判断是 react element 混入 props</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(item, &#123; ...<span class="hljs-title class_">ContainerProps</span> &#125;, item.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>)  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">item</span>(<span class="hljs-title class_">ContainerProps</span>)<br>    &#125; <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Index</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> /&gt;</span></span><br><span class="language-xml">      &#123; (ContainerProps) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> &#123; <span class="hljs-attr">...ContainerProps</span> &#125; <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;Bob&#125;</span> /&gt;</span> &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Props/props04.png" alt="图片.png"></p><p>这种情况需要先遍历 children，判断 children 元素类型：</p><ul><li>针对 element 节点，通过 cloneElement 混入 props</li><li>针对函数，直接传递参数，执行函数</li></ul><h2 id="操作-props-小技巧"><a href="#操作-props-小技巧" class="headerlink" title="操作 props 小技巧"></a>操作 props 小技<strong>巧</strong></h2><p><strong>抽象 props</strong></p><p>抽象 props 一般用于跨层级传递 props，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或抽离到子组件中。</p><p><strong>混入 props</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello, world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> fatherProps = &#123;<br>    <span class="hljs-attr">mes</span>: <span class="hljs-string">&#x27;let us learn React!&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Son</span> &#123; <span class="hljs-attr">...props</span> &#125; &#123; <span class="hljs-attr">...fatherProps</span> &#125;/&gt;</span></span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> indexProps = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;28&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span> &#123; <span class="hljs-attr">...indexProps</span> &#125; /&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Props/props05.png" alt="图片.png"><br>成功的将 indexProps 中的 age 属性抽离出来。</p><p><strong>注入 Props</strong></p><p><strong>显式注入 props</strong></p><p>显式注入 props，就是能够直观看见标签中绑定的 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> hello,world <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> props.<span class="hljs-property">children</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Bob&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;18&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Father</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>如上向 Son 组件绑定的 name 和 age 是能只管被看见的。</p><p><strong>隐式注入 props</strong></p><p>这种方式，一般通过 <code>React.cloneElement</code>对 props.children 克隆再混入新的 props。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> hello,world <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">prop</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(prop.<span class="hljs-property">children</span>, &#123; <span class="hljs-attr">mes</span>: <span class="hljs-string">&#x27;let us learn React!&#x27;</span> &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Bob&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;18&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Father</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，将 mes 属性，隐式混入到了 Son 的 props 中。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Props</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lifeCycle</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/05-lifeCycle/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/05-lifeCycle/</url>
    
    <content type="html"><![CDATA[<h1 id="lifeCycle"><a href="#lifeCycle" class="headerlink" title="lifeCycle"></a>lifeCycle</h1><h2 id="类组件生命周期介绍"><a href="#类组件生命周期介绍" class="headerlink" title="类组件生命周期介绍"></a>类组件生命周期介绍</h2><p>React 有两个重要阶段，render 阶段和 commit 阶段，React 在调和（render）阶段会深度遍历 React fiber 树，目的就是发现不同（diff），不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了 commit 阶段，commit 阶段会创建修改真实的 DOM 节点。</p><p>如果在一次调和的过程中，发现了一个 <code>fiber tag = 1</code>类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// workLoop React 处理类组件的主要功能方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> shouldUpdate<br>  <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span> <span class="hljs-comment">// stateNode 是 fiber 指向 类组件实例的指针</span><br>  <span class="hljs-keyword">if</span> (instance === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// instance 为组件实例，如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span><br>    <span class="hljs-title function_">constructClassInstance</span>(workInprogress, <span class="hljs-title class_">Component</span>, nextProps); <span class="hljs-comment">// 组件实例将在这个方法中被 new</span><br>    <span class="hljs-title function_">mountClassInstance</span>( workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderExpirationTime ); <span class="hljs-comment">// 初始化挂载组件流程</span><br>    shouldUpdate = <span class="hljs-literal">true</span>; <span class="hljs-comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    shouldUpdate = <span class="hljs-title function_">updateClassInstance</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderExpirationTime) <span class="hljs-comment">// 更新组件流程</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (shouldUpdate) &#123;<br>    nextChildren = instance.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 执行 render 函数，得到子节点</span><br>    <span class="hljs-title function_">reconcileChildren</span>(current, workInprogress, nextChildren, renderExpirationTime) <span class="hljs-comment">// 继续调和子节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要概念：</p><ul><li><code>instace</code> 类组件对应实例。</li><li><code>workInProgress</code>树，当前正在调和的 fiber 树，一次更新中，React 回自上而下深度遍历子代 fiber，如果遍历到一个 fiber，会把当前 fiber 指向 workInProgress 。</li><li><code>current</code>树，在初始化更新中，current &#x3D; null，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 用来 workInProgress 和current 来确保一次更新中，快速构建，并且状态不丢失。</li><li><code>Component</code>就是项目中的 class 组件</li><li><code>nextProps</code>作为组件在一次更新中新的 props</li><li><code>renderExpirationTime</code>作为下一次渲染的过期时间。</li></ul><p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 <code>stateNode</code>来访问当前 fiber 对应的组件实例。两者关系图如下</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/lifeCycle/lifeCycle01.png" alt="图片.png"></p><p>React 的大部分生命周期的执行，都在 <code>mountClassInstance</code>和<code>updateClassInstance</code>这两个方法中被执行，。主要流程有 mount（初始化渲染）和 update（更新）两个方向。</p><h3 id="生命周期的三个阶段"><a href="#生命周期的三个阶段" class="headerlink" title="生命周期的三个阶段"></a>生命周期的三个阶段</h3><p>主要分为三个大阶段：<strong>组件初始化</strong>，<strong>组件更新</strong>，<strong>组件销毁</strong></p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><ul><li>constructor 执行</li></ul><p>在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，这个函数就是在 constructor 里面执行的</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps, renderExporationTime</span>) &#123;<br>  <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;<br>  <span class="hljs-keyword">const</span> getDerivedStateFromProps = ctor.<span class="hljs-property">getDerivedStateFromProps</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// ctor 就是我们写的类组件，获取组件的静态规范</span><br>    <span class="hljs-keyword">const</span> partialState = <span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState);<span class="hljs-comment">// 这个时候执行 getDerivedStateFromProps 生命周期，得到将合并的 state</span><br>    <span class="hljs-keyword">const</span> memoizedState = partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span> ? prevState : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, prevState, partialState); <span class="hljs-comment">// 合并 state</span><br>    instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>; <span class="hljs-comment">// 将 state 赋值给我们的实例上，instance.state 就是我们组件中 this.state 获取 state</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBedoreUpdate</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    instance.<span class="hljs-title function_">componentWillMount</span>(); <span class="hljs-comment">// 当getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候，执行 componentWillMount</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>getDerivedStateFromProps 执行<br>在初始化阶段，<code>getDerivedStateFromProps</code>是第二个执行的生命周期，值得注意的是它从 ctor 类上直接绑定的静态方法，传入 props，state。返回值将和之前的 state 合并，作为新的 state，传递给组件实例使用。 </li><li>componentWillMount 执行<br>如果存在 <code>getDerivedStateFromProps</code>和<code>getSnapshotBeforeUpdate</code>就不会执行生命周期<code>componentWillMount</code>。 </li><li>render 函数执行<br>到此为止<code>mountClassInstancec</code>函数完成，但是上面<code>updateClassComponent</code>函数，在执行完<code>mountClassInstacec</code>后，执行了 render 渲染函数，形成了 children，接下来 React 调用 reconcileChildren 方法深度调和 children。</li></ul><p>上面主要是 render 阶段</p><ul><li>componentDidMount 执行<br>一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 <code>componentDidMount</code> <blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLifeCycles</span>(<span class="hljs-params">finishedRoot, current, finishedWork</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;                <span class="hljs-comment">// fiber tag </span><br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;                                     <span class="hljs-comment">// 如果是 类组件 类型</span><br>      <span class="hljs-keyword">const</span> instance = finishedWork.<span class="hljs-property">stateNode</span><span class="hljs-comment">// 类实例</span><br>      <span class="hljs-keyword">if</span>(current === <span class="hljs-literal">null</span>) &#123;                                 <span class="hljs-comment">// 类组件第一次调和渲染</span><br>        instance.<span class="hljs-title function_">componentDidMount</span>()<br>      &#125; <span class="hljs-keyword">else</span> &#123;                                                             <span class="hljs-comment">// 类组件更新</span><br>        instance.<span class="hljs-title function_">componentDidUpdate</span>(prevProps, prevState, instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>componentDidMount</code>执行时机 和 <code>componentDidUpdate</code>执行时机是相同的，只不过是针对初始化，一个针对组件的再更新。到此初始化阶段，生命周期执行完毕。</p><p>执行顺序：constructor -&gt; getDerivedStateFromProps &#x2F; componentWillMount -&gt; render -&gt; componentDidMount</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1646966746152-0e3e28b9-334e-4777-8b32-6ea55003d187.png#clientId=u5fa9003e-03f6-4&from=paste&height=670&id=u39a971a2&originHeight=838&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=514692&status=done&style=none&taskId=u4c49d0a1-c118-49d2-929c-253e9e0c3a5&title=&width=556.8" alt="图片.png"></p><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>类组件的更新阶段，回到 <code>updateClassComponent</code>函数，当发现 current 不为 null 的情况下，说明该组件被挂载过，那么直接按照更新逻辑来处理。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassInstance</span>(<span class="hljs-params">current, workInProgress, ctor, newProps, renderExpirationTime</span>) &#123;<br>  <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// 类组件实例</span><br>  <span class="hljs-keyword">const</span> hasNewLifecycles = <span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> <span class="hljs-comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span><br>  <span class="hljs-keyword">if</span>(!hasNewLifecycles &amp;&amp; <span class="hljs-keyword">typeof</span> instace.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) &#123; <span class="hljs-comment">// 浅比较 props 不相等</span><br>      instance.<span class="hljs-title function_">componentWillReceiveProps</span>(newProps, nextContext); <span class="hljs-comment">// 执行生命周期 componentWillReceiveProps</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> newState = (instance.<span class="hljs-property">state</span> = oldState);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    ctor.<span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState) <span class="hljs-comment">// 执行生命周期 getDerivedStateFromProps，逻辑和 mounted 类似，合并 state</span><br>    newState = workInProgress.<span class="hljs-property">memoizedState</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> shouldUpdate = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">shouldComponentUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// 执行生命周期 shouldComponentUpdate 返回值决定是否执行 render，调和子节点</span><br>    ctor.<span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState) <span class="hljs-comment">// 执行生命周期 getDerivedStateFromProps，逻辑和 mounted 类型，合并 state</span><br>    newState = workInProgress.<span class="hljs-property">memoizedState</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> shouldUpdate = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">shouldComponentUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// 执行生命周期 shouldComponentUpdate 返回值决定是否执行 render，调和子节点</span><br>    shouldUpdate = instance.<span class="hljs-title function_">shouldComponentUpdate</span>(newProps, newState, nextContext);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(shouldUpdate)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      instance.<span class="hljs-title function_">componentWillUpdate</span>(); <span class="hljs-comment">// 执行生命周期 componentWillUpdate</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> shouldUpdate<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行生命周期 componentWillReceiveProps</strong></p><p>首先判断 <code>getDerivedStateFromProps</code>生命周期是否存在，如果不存在就执行<code>componentWillReceiveProps</code>生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext。</p><p><strong>执行生命周期 getDerivedStateFromProps</strong></p><p>接下来执行生命周期 <code>getDerivedStateFromProps</code>，返回的值用于合并 state，生成新的state。</p><p><strong>执行生命周期 shouldComponentUpdate</strong></p><p>接下来执行生命周期<code>shouldComponentUpdate</code>，传入新的 props，新的 state，和新的 context，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意：getDerivedStateFromProps 的返回值可以作为新的 state，传递给 shouldComponentUpdate。</p><p><strong>执行生命周期 componentWillUpdate</strong></p><p>接下来执行生命周期 <code>componentWillUpdate</code>。updateClassInstance 方法到此执行完毕了。</p><p><strong>执行 render 函数</strong></p><p>接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。</p><p><strong>执行 getSnapshotBeforeUpdate</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationLifeCycles</span>(<span class="hljs-params">current, finishedWork</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> snapshot = instance.<span class="hljs-title function_">getSnapshotBeforeUpdate</span>(prevProps, prevState) <span class="hljs-comment">// 执行生命周期 getSnapshotBeforeUpdate</span><br>      instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span> = snapshot <span class="hljs-comment">// 返回值将作为__reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code>的执行也是再 commit 阶段，commit 阶段细分为 <code>beforeMutation</code>（DOM 修改前），<code>Mutation</code>（DOM 修改）,<code>Layout</code>（DOM 修改后）三个阶段，getSnapshotBeforeUpdate 发生在 <code>before Mutation</code>阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate。</p><p><strong>执行 componentDidUpdate</strong></p><p>接下来执行生命周期 componentDidUpdate，此时 DOM 已经修改完成。可以操作修改之后的 DOM。到此为止更新阶段的生命周期执行完毕。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1646966814123-177d22dd-ec68-4140-b29c-ccae492e253d.png#clientId=u5fa9003e-03f6-4&from=paste&height=653&id=uab494325&originHeight=816&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=750724&status=done&style=none&taskId=uf64ec58e-8627-4a10-88f4-3c1141ee0e8&title=&width=724" alt="图片.png"></p><p>更新阶段对应的生命周期的执行顺序：</p><p>componentWillReceiveProps（props 改变）&#x2F; getDerivedStateFromProp -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate -&gt; componentDidUpdate</p><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentWillUnmountWithTimer</span>() &#123;<br>  instance.componentWillUnmount();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行生命周期 componentWillUnmount</strong></p><p>在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签，然后在 commit 阶段就会调用 <code>componentWillUnmount</code>生命周期，接下来统一卸载组件以及 DOM 元素。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1646966839110-bef2de0d-e3e3-4c59-ab21-0f2556c53072.png#clientId=u5fa9003e-03f6-4&from=paste&height=683&id=uc81df81b&originHeight=854&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179401&status=done&style=none&taskId=uf754ad8d-6958-4205-a2cf-720491ec69e&title=&width=554.4" alt="图片.png"></p><p>三个阶段生命周期+无状态组件总览图</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1646966867328-af6519ae-e280-4c30-8568-3b852095b4d3.png#clientId=u5fa9003e-03f6-4&from=paste&height=418&id=u9003d170&originHeight=522&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=546345&status=done&style=none&taskId=uf8321983-c4b4-4e61-a232-0e540034e0b&title=&width=933.6" alt="图片.png"></p><h2 id="React-各个阶段生命周期能做些什么"><a href="#React-各个阶段生命周期能做些什么" class="headerlink" title="React 各个阶段生命周期能做些什么"></a>React 各个阶段生命周期能做些什么</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 中做一些初始化的工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(props) <span class="hljs-comment">// 执行 super，传递 props，才能在接下来的上下文中，获取到 props。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-comment">// 可以用来初始化 state，比如可以用来获取路由中的</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 绑定 this</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span>, <span class="hljs-number">500</span>) <span class="hljs-comment">// 绑定防抖函数，防抖 500 毫秒</span><br>  <span class="hljs-keyword">const</span> _render = <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> _render.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 劫持修改类组件上的一些生命周期</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 点击事件</span><br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* ... */</span>&#125;<br><span class="hljs-comment">// 表单输入</span><br><span class="hljs-title function_">handleInputChange</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* ... */</span>&#125;<br></code></pre></td></tr></table></figure><p>constructor 作用：</p><ul><li>初始化 state，比如可以用来截取路由中的参数，赋值给 state。</li><li>对类组件的事件做一些处理，比如绑定 this，节流，防抖等。</li><li>对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更合适反向继承的 HOC，在 HOC  环节，会详细讲解反向继承这种模式</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState)<br></code></pre></td></tr></table></figure><p>两个参数：</p><ul><li>nextProps 父组件新传递的 props</li><li>prevState 组件在此次更新前的 state</li></ul><p><code>getDerivedStateFromProps</code>方法作为类的静态属性方法执行，内部是访问不到 <code>this</code> 的，它更趋向于纯函数，从源码中就能体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps。</p><p>get | Derived | State | From | Props：得到 派生的 state 从 props 中</p><p>这个生命周期用于初始化和更新阶段，接收父组件的 props 数据，可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并 到 state 中，供给视图渲染层消费。</p><p>从源码中可以看到，只要组件更新，就会执行 <code>getDerivedStateFromProps</code> ，不管是 props 改变，还是 setState，或是 forceUpdate。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">newProps</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type &#125; = newProps<br>  <span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fruit&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">list</span>:[<span class="hljs-string">&#x27;苹果&#x27;</span>,<span class="hljs-string">&#x27;香蕉&#x27;</span>,<span class="hljs-string">&#x27;葡萄&#x27;</span>] &#125; <span class="hljs-comment">// 接收 props 变化，返回值将作为新的  state，用于 渲染 或传递给 shouldComponentUpdate</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;vegetables&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">list</span>:[<span class="hljs-string">&#x27;菠菜&#x27;</span>,<span class="hljs-string">&#x27;西红柿&#x27;</span>,<span class="hljs-string">&#x27;土豆&#x27;</span>] &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;this.state.list.map((item)=&gt;<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span>&gt;</span>&#123; item &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>getDerivedStateFromProps 作用：</p><ul><li>代替 componentWillMount 和 componentWillRectiveProps</li><li>组件初始化或者更新时，将 props 映射到 state</li><li>返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数 newState，可以判断是否渲染组件。（getDerivedStateFromProps 和 shouldComponentUpdate 没有必然联系）</li></ul><h3 id="componentWillMount-和-UNSAFE-componentWillMount"><a href="#componentWillMount-和-UNSAFE-componentWillMount" class="headerlink" title="componentWillMount 和 UNSAFE_componentWillMount"></a>componentWillMount 和 UNSAFE_componentWillMount</h3><p>在 React V16.3 componentWillMount，componentWillReceiveProps，componentWillUpdate 三个生命周期加上不安全的标识 <code>UNSAFE</code>，变成了如下形式，在 React V17.0.2 也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除，</p><p>为什么要加上不安全标识？</p><ul><li>因为这三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。 <ul><li>UNSAFE_componentWillMount</li><li>UNSAFE_componentWillReceiveProps</li><li>UNSAFE_componentWillUpdate</li></ul></li></ul><p>UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。</p><h3 id="componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps"><a href="#componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps"></a>componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</h3><p>UNSAFE_componentWillReceivePRops 函数的执行是在更新组件阶段，该声明周期执行驱动时因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。</p><p>componentWillReceiveProps 的作用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">UNSAFE_componentWillReceiveProps</span>(<span class="hljs-params">newProps</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; type &#125; = newProps<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父组件 render 执行&#x27;</span>) <span class="hljs-comment">// 监听父组件执行 render</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 异步控制 props 改变，派生出来的 state 的修改</span><br>    <span class="hljs-keyword">switch</span>(type)&#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fruit&#x27;</span>:<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">list</span>:[<span class="hljs-string">&#x27;苹果&#x27;</span>,<span class="hljs-string">&#x27;香蕉&#x27;</span>,<span class="hljs-string">&#x27;葡萄&#x27;</span>]&#125;)<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;vagetables&#x27;</span>:<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">list</span>:[<span class="hljs-string">&#x27;苹果&#x27;</span>,<span class="hljs-string">&#x27;香蕉&#x27;</span>,<span class="hljs-string">&#x27;葡萄&#x27;</span>]&#125;)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>componentWillReceiveProps 可以用来监听父组件是否执行 render。 </li><li>componentWillReceiveProps 可以用来接受 props 改变，组件可以根据 props 改变，来决定是否更新 state，因为可以访问到 this，所以可以在异步成功回调（接口请求数据）改变 state。这个是 getDerivedStateFromProps 不能实现的<br>不建议采用这种方式，props 改变，再触发 componentWillRectiveProps 异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变 state。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props，nextProps 判断 props 到底改变与否。所以完全可以换一种思路，那就是状态提升，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。</li></ul><p>当 props 不变的前提下，PureComponent 组件能否阻止 componentWillReceiveProps 执行？</p><p>不能，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。</p><h3 id="componentWillUpdate-和-UNDAFE-componentWillUpdate"><a href="#componentWillUpdate-和-UNDAFE-componentWillUpdate" class="headerlink" title="componentWillUpdate 和 UNDAFE_componentWillUpdate"></a>componentWillUpdate 和 UNDAFE_componentWillUpdate</h3><p>UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。就比如说在一次更新中，保存 DOM 之前的信息（记录上一次位置）。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">UNSAFE_componentWillUpdate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPostion</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>) <span class="hljs-comment">// 获取元素节点 node 位置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>获取组件更新之前的状态。比如 DOM 元素位置等</li></ul><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>render 函数就是 jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。</p><ul><li>那么可以在 render 里面做一些 createElement 创建元素，cloneElement 克隆元素，React.children 遍历 children 的操作。</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, preState</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>两个参数：</p><ul><li>prevProps 更新前的 props</li><li>preState 更新前的 state</li></ul><p>把 getSnapshotBeforeUpdate 拆分一下 get | snap shot | before | update，中文翻译：<strong>获取更新前的快照</strong>，可以进一步理解为 获取更新前 DOM 的状态。该生命周期是在 commit 阶段的 before Mutation（DOM 修改前），此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个<code>snapShot</code>（快照），传递给 componentDidUpdate 作为第三个参数。</p><p>注意：如果没有返回值会给予警告，如果没有 <code>componentDidUpdate</code>也会给予警告。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, preState</span>) &#123;<br>  <span class="hljs-keyword">const</span> sytle = <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>)<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 传递更新前的元素位置</span><br>    <span class="hljs-attr">cx</span>: style.<span class="hljs-property">cx</span>,<br>    <span class="hljs-attr">cy</span>: style.<span class="hljs-property">cy</span><br>  &#125;<br>&#125;<br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>  <span class="hljs-comment">// 获取元素绘制之前的位置</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(snapshot)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个快照 <code>snapShot</code>不限于 DOM 的信息，也可以是根据 DOM 计算出来的产物。</p><p>作用：</p><ul><li>getSnapshotBeforeUpdate 这个生命周期意义就是配合 componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate。保存一次更新前的信息。</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>  <span class="hljs-keyword">const</span> style = <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>)<br>  <span class="hljs-keyword">const</span> newPosition = &#123; <span class="hljs-comment">// 获取元素最新位置信息</span><br>    <span class="hljs-attr">cx</span>: style.<span class="hljs-property">cx</span>,<br>    <span class="hljs-attr">cy</span>: style.<span class="hljs-property">cy</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三个参数：</p><ul><li>prevProps 更新之前的 props</li><li>prevState 更新之前的 state</li><li>snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。</li></ul><p>作用：</p><ul><li>componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState，一定要加以限制，否则会引起无限循环。</li><li>接受 getSnapshotBeforeUpdate 保存的快照信息。</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在<strong>初始化</strong>，一个是<strong>组件更新</strong>，此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作， DOM 事件监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">addEventLister</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// 事件监听</span><br>  &#125;)<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getData</span>() <span class="hljs-comment">// 数据请求</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。</li><li>对于初始化向服务器请求数据，渲染视图，这个生命周期非常合适。</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">newProps, newState, nextContext</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>shouldComponentUpdate 三个参数，第一个参数新的 props，第二个参数新的 state，第三个参数新的 context。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">newProps, newState</span>) &#123;<br>  <span class="hljs-keyword">if</span>(newProps.<span class="hljs-property">a</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">a</span>) &#123; <span class="hljs-comment">// props 中 a 属性发生变化 渲染组件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newState.<span class="hljs-property">b</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">b</span>) &#123; <span class="hljs-comment">// state 中 b 属性发生变化 渲染组件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则组件不渲染</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState，如果有 getDerivedStateFromProps 生命周期，它的返回值将合并到 newState，供 shouldComponentUpdate 使用。</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清理一些可能会造成内存泄漏的定时器，延时器，或者是一些事件监听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>) <span class="hljs-comment">// 清除延时器</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handerClick</span>) <span class="hljs-comment">// 卸载事件监听器</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用</p><ul><li>清理延时器，定时器</li><li>一些基于 DOM 的操作，比如事件监听器</li></ul><h2 id="函数组件生命周期替代方案"><a href="#函数组件生命周期替代方案" class="headerlink" title="函数组件生命周期替代方案"></a>函数组件生命周期替代方案</h2><h3 id="useEffect-和-useLayoutEffect"><a href="#useEffect-和-useLayoutEffect" class="headerlink" title="useEffect 和 useLayoutEffect"></a>useEffect 和 useLayoutEffect</h3><p><strong>useEffect</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> destory<br>&#125;,dep)<br></code></pre></td></tr></table></figure><p>useEffect 第一个参数 callback，返回的 destory，destory 作为下一次 callback 执行之前调用，用于清除上一次 callback 产生的副作用。</p><p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，以来项改变，执行上一次 callback 返回的 destory，和执行新的 effect 第一个参数 callback。React 会像 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p><p><strong>useLayoutEffect</strong></p><p>useLayoutEffect 和  useEffect 不同的地方是采用了同步执行，区别：</p><ul><li>首先 useLayoutEffect 是在 DOM 绘制之前·，这样可以方便修改 DOM，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM，就可能会导致浏览器再次回流重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。</li><li>useLayoutEffect callback 中代码执行会阻塞浏览器绘制。</li></ul><p><strong>修改 DOM ，改变布局就用 useLayoutEffect，其他情况就用 useEffect。</strong></p><p>useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount&#x2F;componentDidUpdate 是同步执行的，useEffect 代码不会阻塞浏览器绘制。在时机上，componentDidMount&#x2F;componentDidUpdate 和 useLayoutEffect 更类似。</p><h3 id="componentDidMount-替代方案"><a href="#componentDidMount-替代方案" class="headerlink" title="componentDidMount 替代方案"></a>componentDidMount 替代方案</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 请求数据，事件监听，操作 dom</span><br>&#125;,[]) <span class="hljs-comment">// 切记 dep = []</span><br></code></pre></td></tr></table></figure><p>在 componentDidMount 的前提下，useEffect 第一函数的返回函数，可以作为 componentWillUnmount 使用。</p><h3 id="componentWillUnmount-方案"><a href="#componentWillUnmount-方案" class="headerlink" title="componentWillUnmount 方案"></a>componentWillUnmount 方案</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 请求数据，事件监听，操作dom，增加定时器，延时器</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 解除事件监听器，清除定时器，延时器</span><br>  &#125;<br>&#125;,[]) <span class="hljs-comment">// 切记 dep = []</span><br></code></pre></td></tr></table></figure><p>在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 ccomponentWillUnmount 使用。</p><h3 id="componentWillReceiveProps-替代方案"><a href="#componentWillReceiveProps-替代方案" class="headerlink" title="componentWillReceiveProps 替代方案"></a>componentWillReceiveProps 替代方案</h3><ul><li>useEffect 和 componentWillReceiveProps 执行阶段不同，一个是在 render 阶段，一个是在commit 阶段。</li><li>其次 useEffect 会初始化执行一次，但是 componentWillReceiveProps 只有在组件更新 props 变化的时候才会执行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)<br>&#125;,[ props ])<br></code></pre></td></tr></table></figure><p>此时依赖性就是 props，props 变化，执行此时的 useEffect 钩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;props中number变化：componentWillReceiveProps&#x27;</span>)<br>&#125;,[props,number]) <span class="hljs-comment">// 当前仅仅当 props 中 number 变化，执行当前 effect 钩子</span><br></code></pre></td></tr></table></figure><p>useEffect 还可以针对 props 的某一个属性进行追踪。此时依赖项为 props 的追踪属性。上述代码，只有 props 中的 number 变化，执行 effect。</p><h3 id="componentDidUpdate-替代方案"><a href="#componentDidUpdate-替代方案" class="headerlink" title="componentDidUpdate 替代方案"></a>componentDidUpdate 替代方案</h3><p>useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行，但都是在 commit 阶段。但是 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成之后执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件更新完成：componentDidUpdate&#x27;</span>)<br>&#125;) <span class="hljs-comment">// 没有 dep 依赖项</span><br></code></pre></td></tr></table></figure><p>注意此时 useEffect 没有第二个参数</p><p>没有第二个参数，那么每一次执行函数组件，都会执行该 effect。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>lifeCycle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ref</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/06-Ref/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/06-Ref/</url>
    
    <content type="html"><![CDATA[<h1 id="ref-基本概念和使用"><a href="#ref-基本概念和使用" class="headerlink" title="ref 基本概念和使用"></a>ref 基本概念和使用</h1><p>分成两个部分来理解：</p><ul><li>Ref 对象的创建 <ul><li>通过 React.createRef 或者 React.useRef 来创建一个 Ref 原始对象</li></ul></li><li>React 本身对 Ref 的处理。 <ul><li>主要指对于标签中 ref 属性，React 是如何处理以及 React 转发 Ref</li></ul></li></ul><h2 id="Ref-对象创建"><a href="#Ref-对象创建" class="headerlink" title="Ref 对象创建"></a>Ref 对象创建</h2><p>ref 对象就是用 createRef 或者 useRef 创建出来的对象，一个标准的 ref 的对象应该是如下样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// current 指向 ref 对象获取到的实际内容，可以是 dom 元素，组件实例，或者其他</span><br></code></pre></td></tr></table></figure><p>React 提供两种方法创建 Ref 对象</p><ol><li>类组件 React。createRef<br>第一种方式通过 React.createRef 创建一个 ref 对象 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentDom</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>(<span class="hljs-literal">null</span>)<br>  &#125;<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentDom</span>)<br>  &#125;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">this.currentDom</span> &#125;&gt;</span></span><br><span class="language-xml">      ref 对象模式获取元素或组件</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>执行结果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref01.png" alt="图片.png"></p><p>React.createRef 的底层逻辑</p><blockquote><p>react&#x2F;src&#x2F;ReactCreateRef.js    </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> refObject = &#123;<br>    <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,<br>  &#125;<br>  <span class="hljs-keyword">return</span> refObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>createRef 只做了一件事，就是创建了一个对象，对象上的 current 属性 用于保存 通过 ref 获取的 DOM 元素，组件实例等。createRef 一般用于类组件创建 Ref 对象，可以将 Ref 对象绑定在类组件实例上，这样更方便后续操作 Ref</p><ol start="2"><li>函数组件 useRef<br>hooks 中的 useRef 来达到同样效果。 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> currentDom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( currentDom.<span class="hljs-property">current</span> ) <span class="hljs-comment">// div</span><br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">currentDom</span> &#125;&gt;</span></span><br><span class="language-xml">  ref 对象模式获取元素或组件</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>useRef 底层逻辑和 createRef 差不多，就是 ref 保存位置不相同，类组件有一个实例 instance 能够维护像 ref 这种信息，但是由于函数组件每次更新都是一次新的开始，所有变量重新声明，所以 useRef 不能像 createRef 把 ref 对象直接暴露出去，如果这样每一次函数组件执行就会重新声明 Ref，此时 ref 就会随着函数组件执行被重置，所以在函数组件中不能使用 createRef。<br>为了解决这个问题，hooks 和函数组件对于的 fiber 对象建立起关联，将 useRef 产生的 ref 对象挂载到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数字节对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来。 </p><h2 id="React-对-Ref-属性的处理-标记ref"><a href="#React-对-Ref-属性的处理-标记ref" class="headerlink" title="React 对 Ref 属性的处理-标记ref"></a>React 对 Ref 属性的处理-标记ref</h2><p>DOM 元素 和组件实例，并不是必须要用 ref 对象获取的，React 类组件提供了多种方法获取 DOM 元素和组件实例，React 对标签里面 ref 属性的处理逻辑多样化。</p><p><strong>类组件获取 Ref 三种方式：</strong></p><ol><li>Ref 属性是一个字符串 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Componetn</span> &#123;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello,world</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Ref 属性是一个字符串</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>)<br>  &#125;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;currentDom&quot;</span>&gt;</span></span><br><span class="language-xml">        字符串模板获取元素或组件</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;currentComInstance&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>打印：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref02.png" alt="图片.png"></p><p>如上面代码片段，用一个字符串 ref 标记一个 DOM 元素，一个类组件（函数组件没有实例，不能被 Ref 标记）。React 在底层逻辑，会判断类型，如果是 DOM 元素，会把真实 DOM 绑定在组件 this.refs （组件实例下的 refs）属性上，如果是类组件，会把子组件的实例绑定在 this.refs 上。</p><ol start="2"><li>Ref 属性是一个函数 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello, world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Ref 属性是一个函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  currentDom = <span class="hljs-literal">null</span><br>  currentComponentInstance = <span class="hljs-literal">null</span><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentDom</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentComponentInstance</span>)<br>  &#125;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">node</span>) =&gt;</span> this.currentDom = node &#125;&gt;Ref模式获取元素或组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">node</span>) =&gt;</span> this.currentComponentInstance = node &#125;/&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>打印：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref03.png" alt="图片.png"><br>如上代码片段，当用一个函数来标记 Ref 的时候，将作为 callback 形式，等到真实 DOM 创建阶段，执行 callback，获取的 DOM 元素或组件实例，将以回调函数第一个参数形式传入，所以可以像上述代码片段中，用组件实例下的属性<code>currentDom</code>和<code>currentComponentInstancr</code>来接受真实 DOM 和组件实例。 </p><ol start="3"><li>Ref 属性是一个 ref 对象<br>第三种方式就是上述通过 ref 对象方式获取。 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello, world</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  currentDom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>(<span class="hljs-literal">null</span>)<br>  currentComponentInstance = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentDom</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentComponentInstance</span>)<br>  &#125;<br>  render = <span class="hljs-function">() =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">this.currentDom</span> &#125;&gt;</span>Ref对象模式获取元素或组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.currentComponentInstance</span> &#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>打印：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref04.png" alt="图片.png"></p><h1 id="ref-高阶用法"><a href="#ref-高阶用法" class="headerlink" title="ref 高阶用法"></a>ref 高阶用法</h1><h2 id="forwardRef-转发-Ref"><a href="#forwardRef-转发-Ref" class="headerlink" title="forwardRef 转发 Ref"></a>forwardRef 转发 Ref</h2><p>forwardRef 的初衷就是解决 ref 不能跨层级捕获和传递的问题。forwardRef 接受了父级元素标记的 ref 信息，并把它转发下去，使得子组件可以通过 props 来接受到上一层级或者是更上层级的 ref</p><p><strong>具体场景分析：</strong></p><p><strong>场景一：跨层级获取</strong></p><blockquote><p>场景：想要在 GrandFather 组件通过标记 ref，来获取孙组件 Son 的组件实例</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 孙组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span> (props) &#123;<br>  <span class="hljs-keyword">const</span> &#123; grandRef &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> i am Bob <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;grandRef&#125;</span> &gt;</span>这个是想要获取元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">grandRef</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">this.props.grandRef</span> &#125; /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NewFather</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span> <span class="hljs-attr">grandRef</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">ref</span> &#125;&#123; <span class="hljs-attr">...props</span> &#125; /&gt;</span></span> )<br><br><span class="hljs-comment">// 爷组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandFather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>  &#125;<br>  node = <span class="hljs-literal">null</span> <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>) <span class="hljs-comment">// span #text 这个是想要获取元素</span><br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">NewFather</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(node)</span>=&gt;</span> this.node = node &#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref05.png" alt="图片.png"></p><p><strong>场景二：合并转发 ref</strong></p><p>通过 forwardRef 转发的 ref 也可以用来传递合并之后的自定义 ref</p><blockquote><p>场景：想通过 Home 绑定 ref，来获取子组件 Index 的实例 index，dom 元素 button，以及孙组件 Form 的实例</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 表单组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;...&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-comment">// index 组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; forwardRef &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>    forwardRef.<span class="hljs-property">current</span> = &#123;<br>      <span class="hljs-attr">form</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">form</span>,     <span class="hljs-comment">// 给 form 组件实例，绑定 ref form 属性</span><br>      <span class="hljs-attr">index</span>: <span class="hljs-variable language_">this</span>,                 <span class="hljs-comment">// 给 index 组件实例，绑定给 ref index 属性</span><br>      <span class="hljs-attr">button</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">button</span>, <span class="hljs-comment">// 给 button dom 元素，绑定给 ref button 属性</span><br>    &#125;<br>  &#125;<br>  form = <span class="hljs-literal">null</span><br>  button = <span class="hljs-literal">null</span><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(button)</span> =&gt;</span> this.button = button&#125;&gt;点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(form)</span> =&gt;</span> this.form = form&#125;/&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRefIndex</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props,ref</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Index</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">forwardRef</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span>)<br><br><span class="hljs-comment">// home 组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">current</span>)<br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ForwardRefIndex</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref06.png" alt="图片.png"></p><p>上面代码流程主要分为：</p><ul><li>通过 useRef 创建一个 ref 对象，通过 forwardRef 将当前 ref 对象传递给子组件。</li><li>向 Home 组件传递的 ref 对象上，绑定 form 孙组件实例，index 子组件实例，和 button DOM 元素。</li></ul><p><code>forwardRef</code>让 ref 可以通过 props 传递，那么如果用 ref 对象标记的 ref，那么 ref 对象就可以通过 props 的形式，提供给子孙组件消费，当然子孙组件也可以改变 ref 对象里面的属性，或者像如上代码中赋予新的属性，这种 forwardref + ref 模式一定程度上打破了 React 单向数据流动的原则。当然绑定在 ref 对象上的属性，不限于组件实例或者 DOM 元素，也可以是属性值或方法。</p><p><strong>场景三：高阶组件转发</strong></p><p>如果通过高阶组件包裹一个原始类组件，就会产生一个问题，如果高阶组件 HOC 没有处理 ref，那么由于高阶组件本身会返回一个新组件，所以当使用 HOC 包装后组件的时候，标记的 ref 会指向 HOC 返回的组件，而并不是 HOC 包裹的原始类组件，为了解决这个问题，forwardRef 可以对 HOC 做一层处理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; forwardeRef, ...otherprops &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">forwardedRef</span> &#125; &#123; <span class="hljs-attr">...otherprops</span> &#125;/&gt;</span></span><br>      )<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props,ref</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Warp</span> <span class="hljs-attr">forwardedRef</span> = <span class="hljs-string">&#123;ref&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125;/&gt;</span></span>)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello,world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HocIndex</span> =  <span class="hljs-title function_">HOC</span>(<span class="hljs-title class_">Index</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;&#123;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">current</span>)  <span class="hljs-comment">/* Index 组件实例  */</span> <br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">HocIndex</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;node&#125;</span>  /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过 forwardRef 处理后的 HOC ，就可以正常访问到 Index 组件实例了。</p><h2 id="Ref-实现组件通信"><a href="#Ref-实现组件通信" class="headerlink" title="Ref 实现组件通信"></a>Ref 实现组件通信</h2><p>如果有场景不想通过父组件 render 改变 props 的方式，来触发子组件的更新，也就是子组件通过 state 单独管理数据层，针对这种情况父组件可以通过 ref 模式标记子组件实例，从而操纵子组件方法，这种情况通常发生在一些<strong>数据托管</strong>的组件上，比如<code>&lt;Form/&gt;</code>表单，经典案例可以参考 antd 里面的 form 表单，暴露出来对外的 <code>resetFields</code>，<code>setFieldsValue</code>等接口，可以通过表单实例调用这些 API。</p><p><strong>类组件 ref：</strong></p><p>对于类组件可以通过 ref 直接获取组件实例，实现组件通信。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 子组件 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span>&#123;<br>  state=&#123;<br>    <span class="hljs-attr">fatherMes</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">sonMes</span>:<span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br>  fatherSay=<span class="hljs-function">(<span class="hljs-params">fatherMes</span>)=&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; fatherMes  &#125;) <span class="hljs-comment">/* 提供给父组件的API */</span><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123; fatherMes, sonMes &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;sonbox&quot;</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;title&quot;</span> &gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件对我说：&#123; fatherMes &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;label&quot;</span> &gt;</span>对父组件说<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span>=&gt;</span>this.setState(&#123; sonMes:e.target.value &#125;)&#125;   className=&quot;input&quot;  /&gt; </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;searchbtn&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> this.props.toFather(sonMes) &#125;  &gt;to father<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><span class="hljs-comment">/* 父组件 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> [ sonMes , setSonMes ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>) <br>  <span class="hljs-keyword">const</span> sonInstance = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">/* 用来获取子组件实例 */</span><br>  <span class="hljs-keyword">const</span> [ fatherMes , setFatherMes ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toSon</span> =(<span class="hljs-params"></span>)=&gt; sonInstance.<span class="hljs-property">current</span>.<span class="hljs-title function_">fatherSay</span>(fatherMes) <span class="hljs-comment">/* 调用子组件实例方法，改变子组件state */</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;box&quot;</span> &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;title&quot;</span> &gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件对我说：&#123; sonMes &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;label&quot;</span> &gt;</span>对子组件说<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;</span> (<span class="hljs-attr">e</span>) =&gt;</span> setFatherMes(e.target.value) &#125;  className=&quot;input&quot;  /&gt; </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;searchbtn&quot;</span>  <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toSon&#125;</span>  &gt;</span>to son<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;sonInstance&#125;</span> <span class="hljs-attr">toFather</span>=<span class="hljs-string">&#123;setSonMes&#125;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数组件 forwardRef + useImperativeHandle</strong></p><p>对于函数组件，本身没有实例，但是 React Hooks 提供了，useImperativeHandle 一方面第一个参数接受父组件传递的 ref 对象，另一方面第二个参数是一个函数，函数返回值，作为 ref 对象获取的内容。</p><p>useImperativeHandle 接受三个参数：</p><ul><li>第一个参数 ref：接受 forWardRef 传递过来的 ref</li><li>第二个参数 createHandle：处理函数，返回值作为暴露给父组件的 ref 对象</li><li>第三个参数 deps：依赖性 deps ，依赖项更改形成新的 ref 对象。</li></ul><p>forwardRef + useImperativeHandle 可以完全让函数组件也能流畅的使用 Ref 通信。</p><p><strong>流程图：</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref07.png" alt="图片.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span> (props,ref) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> [ inputValue , setInputValue ] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> handleRefs = &#123;<br>      <span class="hljs-title function_">onFocus</span>(<span class="hljs-params"></span>)&#123;              <span class="hljs-comment">/* 声明方法用于聚焦input框 */</span><br>        inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>      &#125;,<br>      <span class="hljs-title function_">onChangeValue</span>(<span class="hljs-params">value</span>)&#123;   <span class="hljs-comment">/* 声明方法用于改变input的值 */</span><br>        <span class="hljs-title function_">setInputValue</span>(value)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> handleRefs<br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入内容&quot;</span>  <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;inputValue&#125;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwarSon</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">Son</span>)<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  cur = <span class="hljs-literal">null</span><br>  <span class="hljs-title function_">handerClick</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123; onFocus , onChangeValue &#125; =<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur</span><br>    <span class="hljs-title function_">onFocus</span>() <span class="hljs-comment">// 让子组件的输入框获取焦点</span><br>    <span class="hljs-title function_">onChangeValue</span>(<span class="hljs-string">&#x27;let us learn React!&#x27;</span>) <span class="hljs-comment">// 让子组件input  </span><br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span>&#x27;<span class="hljs-attr">50px</span>&#x27; &#125;&#125; &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ForwarSon</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;cur</span> =&gt;</span> (this.cur = cur)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handerClick.bind(this)&#125;</span> &gt;</span>操控子组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程分析：</p><ul><li>父组件用 ref 标记子组件，由于子组件 Son 是函数组件没有实例，所以用 forwardRef 转发 ref</li><li>子组件 Son 用 useImperativeHandle 接受父组件 ref，将让 input 聚焦的方法 onFocus 和改变 input 输入框的值的方法 onChangeValue 传递给 ref。</li><li>父子局可以通过调用 ref 下的 onFocus 和 onChangeValue 控制子组件中 input 赋值和聚焦。</li></ul><h2 id="函数组件换成数据"><a href="#函数组件换成数据" class="headerlink" title="函数组件换成数据"></a>函数组件换成数据</h2><p>函数组件每一次 render，函数上下文都会重新指向，那么有一种情况就是，在执行一些事件方法改变数据或者保存新数据的时候，没有必要更新视图，没有必要把数据放到 state 中。如果视图层更新不依赖想要改变的数据，那么 state 改变带来的更新效果就是多余的。此时更新就是浪费性能。</p><p>这种情况下，可以使用 useRef，useRef 可以创建出一个 ref 原始对象，只要组件没有销毁，ref 对象就一直存在，那么完全可以把一些不依赖于视图更新的数据存储到 ref 对象中，这样做的好处有：</p><ul><li>第一个能直接修改数据，不会造成函数组件冗余的更新作用</li><li>第二个 useRef 保存数据，如果有 useEffect，useMemo 引用 ref 对象中的数据，无需将 ref 对象添加到 dep 依赖项，因为 useRef 始终指向一个内存空间，<strong>可以随时访问到变化后的值</strong></li></ul><blockquote><p>应用场景 demo</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> toLearn = [ &#123; <span class="hljs-attr">type</span>: <span class="hljs-number">1</span> , <span class="hljs-attr">mes</span>:<span class="hljs-string">&#x27;let us learn React&#x27;</span> &#125; , &#123; <span class="hljs-attr">type</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">mes</span>:<span class="hljs-string">&#x27;let us learn Vue3.0&#x27;</span> &#125;  ]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params">&#123; id &#125;</span>)&#123;<br>  <span class="hljs-keyword">const</span> typeInfo = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(toLearn[<span class="hljs-number">0</span>])<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeType</span> = (<span class="hljs-params">info</span>)=&gt;&#123;<br>    typeInfo.<span class="hljs-property">current</span> = info <span class="hljs-comment">/* typeInfo 的改变，不需要视图变化 */</span><br>  &#125;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(typeInfo.<span class="hljs-property">current</span>.<span class="hljs-property">type</span>===<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-comment">/* ... */</span><br>    &#125;<br>  &#125;,[ id ]) <span class="hljs-comment">/* 无须将 typeInfo 添加依赖项  */</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    &#123;</span><br><span class="language-xml">      toLearn.map(item=&gt; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.type&#125;</span>  <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">changeType.bind</span>(<span class="hljs-attr">null</span>,<span class="hljs-attr">item</span>) &#125; &gt;</span>&#123; item.mes &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> )</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>设计思路：</p><ul><li>用一个 useRef 保存 type 的信息，type 改变不需要视图变化</li><li>按钮切换直接改变 useRef 内容</li><li>useEffect 里面可以直接访问到改变后的 typeInfo 的内容，不需要添加依赖项</li></ul><h2 id="ref-原理揭秘"><a href="#ref-原理揭秘" class="headerlink" title="ref 原理揭秘"></a>ref 原理揭秘</h2><p>对于 Ref 标签引用，React 是如何处理的？从 Demo 中发现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  state=&#123; <span class="hljs-attr">num</span>:<span class="hljs-number">0</span> &#125;<br>  node = <span class="hljs-literal">null</span><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(node)</span>=&gt;</span>&#123;</span><br><span class="language-xml">          this.node = node</span><br><span class="language-xml">          console.log(&#x27;此时的参数是什么：&#x27;, this.node )</span><br><span class="language-xml">        &#125;&#125;  &gt;ref元素节点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;) &#125; &gt;点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref08.png" alt="图片.png"></p><p>第一次打印 null 第二次才是 div</p><p><strong>ref 执行时机和处理逻辑</strong></p><p>对于整个 Ref 的处理，都是在 commit 阶段发生的。commit 阶段会进行真正的 Dom 操作，此时 ref 就是用来获取真实的 DOM 以及组件实例的，所以需要 commit 阶段处理。</p><p>但是对于 Ref 处理函数，React 底层用两个方法处理：<strong>commitDetachRef</strong> 和 <strong>commitAttachRef</strong>，上述两次 console.log 一次为 null，一次为 div 就是分别调用了上述方法。</p><p>这两次正好，一次在 DOM 更新之前，一次在 DOM 更新之后。</p><ul><li>第一阶段：一次更新中，在 commit 的 mutation 阶段，执行 commitDetachRef，commitDetachRef 会清空之前 ref 值，使其重置为 null。 <blockquote><p>react-reconclier&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDetachRef</span>(<span class="hljs-params">current: Fiber</span>) &#123;<br>  <span class="hljs-keyword">const</span> currentRef = current.<span class="hljs-property">ref</span>;<br>  <span class="hljs-keyword">if</span> (currentRef !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> currentRef === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// function 和 字符串获取方式</span><br>      <span class="hljs-title function_">currentRef</span>(<span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Ref 对象获取方式</span><br>      currentRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二阶段：DOM 更新阶段，这个阶段会根据不同的 effect 标签，真实操作 DOM。 </li><li>第三阶段：layout 阶段，在更新真实元素节点之后，此时需要更新 ref。 <blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitAttachRef</span> (<span class="hljs-attr">finishedWork</span>: <span class="hljs-title class_">Fiber</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = finishedWork.<span class="hljs-property">ref</span>;<br>  <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> instance = finishedWork.<span class="hljs-property">stateNode</span>;<br>    <span class="hljs-keyword">let</span> instanceToUse;<br>    <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: <span class="hljs-comment">// 元素节点 获取元素</span><br>        instanceToUse = <span class="hljs-title function_">getPublicInstance</span>(instance);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>: <span class="hljs-comment">// 类组件直接使用实例</span><br>        instanceToUse = instance;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-title function_">ref</span>(instanceToUse); <span class="hljs-comment">// function 和 字符串获取方式</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ref.<span class="hljs-property">current</span> = instanceToUse; <span class="hljs-comment">// ref 对象方式</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一阶段，主要判断 ref 获取的是组件还是 DOM 元素，如果 DOM 元素，就会获取更新之后最新的 DOM 元素。上面流程中讲了三种获取 ref 的方式。如果是字符串 ref &#x3D; “node” 或是 函数式 ref&#x3D;{(node) &#x3D;&gt; this.node &#x3D; node} 会执行 ref 函数，重置新的 ref。</p><p>如果是 ref 对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">node = React.createRef()<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">node</span> &#125; &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为什么 ref &#x3D; “node” 字符串，最后会按照函数方式处理？</p><p>因为 ref 属性是一个字符串的时候，React 会自动绑定一个函数，用来处理 ref 逻辑</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactChildFiber.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">let</span> refs = inst.<span class="hljs-property">refs</span>;<br>  <span class="hljs-keyword">if</span> (refs === emptyRefsObject) &#123;<br>    refs = inst.<span class="hljs-property">refs</span> = &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">delete</span> refs[stringRef];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    refs[stringRef] = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以当这样绑定 ref&#x3D;”node”，会被绑定在组件实例的 refs 属性下面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;node&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ref 函数在 commitAttachRef 中最终会这么处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">ref</span>(&lt;div&gt;)<br>等于 inst.<span class="hljs-property">refs</span>.<span class="hljs-property">node</span> = &lt;div&gt;<br></code></pre></td></tr></table></figure><p><strong>Ref 的处理特性</strong></p><p>接下来 ref 的一些特性，首先来看一下，上述没有提及一个问题，React 被 ref 标记的 fiber，那么每一次 fiber 更新都会调用 <strong>commitDetachRef</strong> 和 <strong>commitAttachRef</strong> 更新 Ref 吗？</p><p><strong>答案是否定的，只有在 ref 更新的时候，才会调用如上方法更新 ref，原因在如上两个方法的执行时期</strong></p><p><strong>更新 ref</strong></p><p>在 commit 阶段 commitDetachRef 和 commitAttachRef 是在什么条件下被执行的？</p><p><code>commitDetachRef</code>调用时机</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffects</span> () &#123;<br>  <span class="hljs-keyword">if</span> (effectTag &amp; <span class="hljs-title class_">Ref</span>) &#123;<br>    <span class="hljs-keyword">const</span> current = nextEffect.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">commitDetacRef</span>(current);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commitAttachRef</code> 调用时机</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffects</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (effectTag &amp; <span class="hljs-title class_">Ref</span>) &#123;<br>    <span class="hljs-title function_">commitAttachRef</span>(nextEffect);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只有含有 Ref tag 的时候，才会执行更新 ref，那么是每一次更新都会打 Ref tag 吗？看一下是什么时候标记的 Ref。 <blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">markRef</span>(<span class="hljs-params">current: Fiber | <span class="hljs-literal">null</span>, workInprogress: Fiber</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = workInProgress.<span class="hljs-property">ref</span>;<br>  <span class="hljs-keyword">if</span> (<br>    (current === <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">null</span>) || <span class="hljs-comment">// 初始化的时候</span><br>    (current === <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">ref</span> !== ref) <span class="hljs-comment">// ref 指向发生改变</span><br>  ) &#123;<br>    workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Ref</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先 <code>markRef</code>方法执行在两种情况下：</p><ul><li>第一种就是类组件更新的过程中</li><li>第二种就是更新 <code>HostComponent</code> 的时候，<code>HostComponetn</code>（比如 <code>&lt;div /&gt;</code>等元素）</li></ul><p><code>markRef</code>会在以下两种情况下给 effectTag 标记 Ref，只有标记了 Ref tag 才会有后续的 <code>commitAttachRef</code>和<code>commitDetachRef</code>流程。（current 为当前调和的 fiber 节点）</p><ul><li>第一种 <code>current === null &amp;&amp; ref !== null</code>：就是在 fiber 初始化的时候，第一次 ref 处理的时候，是一定要标记 Ref 的。</li><li>第二种 <code>current !== null &amp;&amp; current.ref !== ref</code>：就是 fiber 更新的时候，但是 ref 对象的指向变了</li></ul><p>只有在 Ref tag 存在的时候才会更新 ref，那么回到最初的 DemoRef 上来，为什么每点击一次按钮，都会打印 ref，那么也就是 ref 的回调函数执行了，ref 更新了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">    <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(node)</span> =&gt;</span> &#123;<br>      this.node = node<br>      console.log(&#x27;此时的参数是什么：&#x27;, this.node)<br>  &#125;<br>&#125;<br>&gt;<br>  ref 元素节点<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如上很简单，每一次更新的时候，都给 ref 赋值了新的函数，那么<code>markRef</code>中就会判断成 <code>current.ref !== ref</code>，所以就会重新打 Ref 标签，那么在 commit 节点，就会更新 ref 执行 ref 回调函数了。</li></ul><p>如果给 DemoRef 做如下修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  state=&#123; <span class="hljs-attr">num</span>:<span class="hljs-number">0</span> &#125;<br>  node = <span class="hljs-literal">null</span><br>  getDom= <span class="hljs-function">(<span class="hljs-params">node</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span> = node<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;此时的参数是什么：&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span> )<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.getDom&#125;</span>&gt;</span>ref元素节点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;)&#125; &gt;点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个时候，在点击按钮更新的时候，由于此时 ref 指向相同的函数 <code>getDom</code> ，所以就不会打 Ref 标签，不会更新 ref 逻辑，直观上的体现就是 <code>getDom</code> 函数不会再执行。</li></ul><p><strong>卸载 ref</strong></p><p>当组件或者元素卸载的时候，ref 的处理逻辑：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">this.state.isShow &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>this.node = node&#125;&gt;元素节点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如上，在一次更新的时候，改变<code>isShow</code>属性，使之由<code>true</code>变成了<code>false</code>，那么<code>div</code>元素会被卸载，那么 ref 会怎么处理呢？<br>被卸载的 fiber 会被打成 <code>Deletion</code> effect tag，然后在 commit 阶段会进行 commitDeletion 流程。对于有 ref 的 ClassCompoent（类组件）和HostComponent（元素），会统一走<code>safelyDetachRef</code>流程，这个方法就是用来卸载 ref。 <blockquote><p>react-reaconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">safelyDetachRef</span>(<span class="hljs-params">current</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = current.<span class="hljs-property">ref</span>;<br>  <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// 函数式 | 字符串</span><br>      <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ref 对象</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于字符串 <code>ref=&quot;dom&quot;</code>和函数类型 <code>ref=&#123;(node)=&gt;this.node=node&#125;</code>的 ref，会执行传入 null 置空 ref。</li><li>对于 ref 对象类型，会清空 ref 对象上的 current 属性</li></ul><p>借此完成卸载 ref 流程。</p><p><strong>逻辑流程图：</strong><br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Ref/Ref09.png" alt="图片.png"></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Ref</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Context</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/07-Context/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/07-Context/</url>
    
    <content type="html"><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>但是需要注意： <strong>提供者永远要在消费者上层</strong></p><h2 id="新旧版本的-context-的使用"><a href="#新旧版本的-context-的使用" class="headerlink" title="新旧版本的 context 的使用"></a>新旧版本的 context 的使用</h2><h3 id="老版本-context-的使用"><a href="#老版本-context-的使用" class="headerlink" title="老版本 context 的使用"></a>老版本 context 的使用</h3><p><code>v16.3.0</code>之前，React 用 PropTypes 来声明 context 类型，提供者需要 getChildContext 来返回需要提供的 context，并且用静态属性 childContextTypes 声明需要提供的 context 数据类型。</p><p><strong>老版本提供者</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 提供者</span><br><span class="hljs-keyword">import</span> propsTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;proptypes&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">getChildContext</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> theme = &#123; <span class="hljs-comment">// 提供者需要提供的主题颜色，供消费者消费</span><br>      <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ccc&#x27;</span>,<br>      <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;pink&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123; theme &#125;<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        hello,let us learn React!</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ProviderDemo</span>.<span class="hljs-property">childContextTypes</span> = &#123;<br>  <span class="hljs-attr">theme</span>: propsTypes.<span class="hljs-property">object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>老版本 api 在 v16 版本还能正常使用，对于提供者，需要通过 getChildContext 方法，将传递的 theme 信息返回出去，并通过 childContextTypes 声明要传递的 theme 是一个对象结构。声明类型需要<code>propsTypes</code>库来助力。</p><p><strong>老版本消费者</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 消费者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Componetn</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">theme</span>) <span class="hljs-comment">// &#123; color:&#x27;#ccc&#x27;,  bgcolor:&#x27;pink&#x27; &#125;</span><br>    <span class="hljs-keyword">const</span> &#123; color, background &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">theme</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color</span>, <span class="hljs-attr">background</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">        消费者</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ConsumerDemo</span>.<span class="hljs-property">contextTypes</span> = &#123;<br>  <span class="hljs-attr">theme</span>:propsTypes.<span class="hljs-property">object</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Son</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>效果：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Context/Context01.png" alt="图片.png"></p><p>作为消费者，需要在组件的静态属性指明我到底需要哪个提供者提供的状态，在 demo 项目中，ConsumerDemo 的  contextTypes 明确的指明了需要 ProviderDemo 提供的 theme信息，然后就可以通过  this.context.theme 访问到 theme ，用做渲染消费。</p><p>这种模式和 vue 中的 provide 和 inject  数据传输模式很像，在提供者中声明到底传递什么，然后消费者指出需要哪个提供者提供的 context  。打个比方，就好比去一个高档餐厅，每一个厨师都可以理解成一个提供者，而且每个厨师各有所长，有的擅长中餐，有的擅长西餐，每个厨师都把擅长的用 <code>childContextTypes</code> 贴出来，你作为消费者，用 <code>contextTypes</code> 明确出想要吃哪个厨师做的餐饮，借此做到物尽所需。</p><h3 id="新版本-context-的使用"><a href="#新版本-context-的使用" class="headerlink" title="新版本 context 的使用"></a>新版本 context 的使用</h3><p>上述的 API 用起来流程可能会很繁琐，而且还依赖于 propsTypes 等第三方库。所以 <code>v16.3.0</code> 之后，context api 正式发布了，所以可以直接用 createContext 创建出一个 context 上下文对象，context 对象提供两个组件，<code>Provider</code>和 <code>Consumer</code>作为新的提供者和消费者，这种 context 模式，更便捷的传递 context ，还增加了一些新的特性，但是也引出了一些新的问题，什么问题后面会讲到。接下来需要重点研究一下新版本的 context 。</p><h4 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h4><p><code>React.createContext</code>的基本用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 创建</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeProvider</span> = <span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Provider</span> <span class="hljs-comment">// 提供者</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeConsumer</span> = <span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Consumer</span> <span class="hljs-comment">// 订阅消费者</span><br></code></pre></td></tr></table></figure><p>createContext 接受一个参数，作为初始化 context 的内容，返回一个 context 对象，Context 对象上的 Provider 作为提供者，Context 对象上的 Consumer 作为消费者。</p><h4 id="新版本提供者"><a href="#新版本提供者" class="headerlink" title="新版本提供者"></a>新版本提供者</h4><p>首先来看一下 Provider 的用法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeProvider</span> = <span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Provider</span> <span class="hljs-comment">// 提供者</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProviderDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [ contextValue, setContextValue ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#ccc&#x27;</span>, <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;pink&#x27;</span> &#125;)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;</span> <span class="hljs-attr">contextValue</span> &#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>provider 作用有两个：</p><ul><li>value 属性传递 context，供给 Consumer 使用。</li><li>vlaue 属性改变，ThemeProvider 会让消费 Provider value 的组件重新渲染。</li></ul><h4 id="新版本消费者"><a href="#新版本消费者" class="headerlink" title="新版本消费者"></a>新版本消费者</h4><p>对于新版本想要获取 context 的消费者，React 提供了 3 种形式：</p><p><strong>1.类组件之 contextType 方式</strong></p><p><code>React v16.6</code>提供了 contextType 静态属性，用来获取上面 Provider 提供的 value 属性，这里注意的是 contextType，不是上述老版的 contextTypes，对于 React 起的两个名字，真是太相像了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-comment">// 类组件 contextType 方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; color, background &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color</span>, <span class="hljs-attr">background</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">        消费者</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ConsumerDemo</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">ThemeContext</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Son</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>类组件的静态属性上的 contextType 属性，指向需要获取的 context（demo 中的 ThemeContext），就可以方便获取到最近一层 Provider 提供的 contextValue 值。</li><li>这种方式只适用于类组件</li></ul><p><strong>函数组件之 useContext 方式</strong></p><p>v16.8 React hooks 提供了 <code>useContext</code>，下面看一下 useContext 使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-comment">// 函数组件 - useContext 方式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ConsumerDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> contextvalue = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)<br>  <span class="hljs-keyword">const</span> &#123; color, bakcground &#125; = contextValue<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color,</span> <span class="hljs-attr">background</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">      消费者</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Son</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>useContext 接受一个参数，就是想要获取的 context，返回一个 value 值，就是最近的 provider 提供 contextValue 值。</p><p><strong>3.订阅者之 Consumer 方式</strong></p><p>React 还提供了一种 Consumer 订阅消费者方式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeConsumer</span> = <span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Consumer</span> <span class="hljs-comment">// 订阅消费者</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ConsumerDemo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; color, background &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color,</span> <span class="hljs-attr">background</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">      消费者</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Son</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeConsumer</span>&gt;</span></span><br><span class="language-xml">    &#123; /* 将 context 内容转化成 props */ &#125;</span><br><span class="language-xml">    &#123; (contextValue) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> &#123;<span class="hljs-attr">..contextValue</span>&#125; /&gt;</span> &#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeConsumer</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Consumer 订阅者采用 render props 方式，接受最近一层 provider 中 value属性，作为 render props 函数的参数，可以将参数取出来，作为 props 混入 <code>ConsumerDemo</code>组件，其实是 context 变成了 props。</li></ul><p><strong>4.动态 context</strong></p><p>场景：切换主题（动态改变 context 的内容）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 创建</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ConsumerDemo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> &#123; color,background &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color</span>,<span class="hljs-attr">background</span> &#125; &#125; &gt;</span>消费者<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">()=&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span>) <span class="hljs-comment">// 子组件</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeProvider</span> = <span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Provider</span> <span class="hljs-comment">//提供者</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProviderDemo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> [ contextValue , setContextValue ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123;  <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#ccc&#x27;</span>, <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;pink&#x27;</span> &#125;)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">contextValue</span> &#125; &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> setContextValue(&#123; color:&#x27;#fff&#x27; , background:&#x27;blue&#x27; &#125;)  &#125; &gt;切换主题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>Provider 模式下 context 有一个显著的特点，就是 <strong>Provder 的 value 改变，会使所有消费 value 的组件重新渲染</strong>，如果通过上一个 useState 来改变 contextValue 的值，contextValue 改变，会使 ConsumerDemo 自动更新，注意这个更新并不是由父组件 son render 造成的，因为 给 son 用 memo 处理过，这种情况下，Son 没有触发 render，而是 ConsumerDemo 自发的 render。</p><p>**总结：在 Provider 里 value 的改变，会使引用 **<code>**contextType**</code><strong>，</strong><code>**useContext**</code><strong>消费该 context 的组件重新 render，同样会使 Consumer 的 children 函数重新执行，与之前两种方式不同的是 Consumer 方式，当 context 内容改变的时候，不会让引用 Consumer 的父组件重新更新</strong></p><p><strong>暴露问题</strong></p><p>上述的 demo 中的 Son 组件如果没有用 memo 处理，useState 会让 <code>ProviderDemo</code>重新 render，此时 Son 没有处理，就会跟随父组件 render，问题是如果 son 还有好多子组件，那么全部 render 一遍，很耗费性能。<strong>如何阻止 Provider value 改变造成的 children（demo 中的 Son）不必要渲染？</strong></p><ul><li><p>利用 memo，pureComponent 对子组件 props 进行浅比较处理。 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span>)<br></code></pre></td></tr></table></figure></li><li><p>利用 React 本身对 React element 对象的缓存。 React 每次 执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新。 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">ThemeProvider</span> value=&#123; contextValue &#125; &gt;<br>  &#123; <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()=&gt;</span>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Son</span> /&gt;</span></span> ,[]) &#125;<br>&lt;/<span class="hljs-title class_">ThemeProvider</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>5.其他api</strong></p><ol><li>displayName<br>context 对象接受一个名为 <code>displayName</code>的property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-comment">/* 初始化内容 */</span>);<br><span class="hljs-title class_">MyContext</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">&#x27;MyDisplayName&#x27;</span>;<br><br>&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span>&gt; <span class="hljs-comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span><br>&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Consumer</span>&gt; <span class="hljs-comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span><br></code></pre></td></tr></table></figure></li></ol><p>context 与 props 和 react-redux 的对比？</p><p>context解决了：</p><ul><li>解决了 props 需要每一层都手动添加 props 的缺陷。</li><li>解决了改变 value ，组件全部重新渲染的缺陷。</li></ul><p>react-redux 就是通过 Provider 模式把 redux 中的 store 注入到组件中的。</p><h2 id="context-高阶用法"><a href="#context-高阶用法" class="headerlink" title="context 高阶用法"></a>context 高阶用法</h2><p><strong>嵌套 Provider</strong></p><p>多个 Provider 之间可以相互嵌套，来保存&#x2F;切换一些全局数据：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 主题颜色 Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LanContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 主题语言</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ConsumerDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        (themeContextValue) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">LanContext.Consumer</span>&gt;</span></span><br><span class="language-xml">            &#123;</span><br><span class="language-xml">              (lanContextValue) =&gt; &#123;</span><br><span class="language-xml">                const &#123; color, background &#125; = themeContextValue</span><br><span class="language-xml">                return (</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;P&#123;</span> <span class="hljs-attr">color</span>, <span class="hljs-attr">background</span> &#125;&#125;&gt;</span>&#123;lanContextValue === &#x27;CH&#x27; ? &#x27;大家好，让我们一起学习React！&#x27;: &#x27;Hello,let us learn React!&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                )</span><br><span class="language-xml">              &#125;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">LanContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConsumerDemo</span> /&gt;</span></span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProviderDemo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> [ themeContextValue ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123;  <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#FFF&#x27;</span>, <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;blue&#x27;</span> &#125;)<br>  <span class="hljs-keyword">const</span> [ lanContextValue ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;CH&#x27;</span>) <span class="hljs-comment">// CH -&gt; 中文 ， EN -&gt; 英文</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themeContextValue&#125;</span>  &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LanContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;lanContextValue&#125;</span> &gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>  /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">LanContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Context/Context02.png" alt="图片.png"></p><ul><li>ThemeContext 保存主题信息，用 LanContext 保存语言信息。</li><li>两个 Provider 嵌套来传递全局信息。</li><li>用两个 Consumer 嵌套来接受信息。</li></ul><p><strong>逐层传递 Provider</strong></p><p>Provider 还有一个良好的特性，就是可以逐层传递 context，也就是一个 context 可以用多个 Provider 传递，下一层级的 Provider 会覆盖上一层的 Provider。React-redux 中 connect 就是用这个良好特性传递订阅器的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 逐层传递Provder</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son2</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">    &#123; (themeContextValue2)=&gt;&#123;</span><br><span class="language-xml">      const &#123; color , background &#125; = themeContextValue2</span><br><span class="language-xml">      return  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;sonbox&quot;</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color</span>,<span class="hljs-attr">background</span> &#125; &#125; &gt;</span>  第二层Provder <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    &#125;  &#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> &#123; color, background &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)<br>  <span class="hljs-keyword">const</span> [ themeContextValue2 ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123;  <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#fff&#x27;</span>, <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;blue&#x27;</span> &#125;) <br>  <span class="hljs-comment">/* 第二层 Provder 传递内容 */</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;box&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color</span>,<span class="hljs-attr">background</span> &#125; &#125; &gt;</span></span><br><span class="language-xml">    第一层Provder</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">themeContextValue2</span> &#125; &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son2</span>  /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Provider1Demo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> [ themeContextValue ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123;  <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;pink&#x27;</span> &#125;)<br>  <span class="hljs-comment">/* 第一层  Provider 传递内容  */</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">themeContextValue</span> &#125; &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span> <br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Context/Context03.png" alt="图片.png"></p><ul><li>全局只有一个 ThemeContext，两次用 provider 传递两个不容 context。</li><li>组件获取 context 时候，会获取离当前组件最近的上一层 Provider。</li><li>下一层的 provider 会覆盖上一层的 provider</li></ul><p>Provider 特性总结</p><ul><li>Provier 作为提供者传递 context，provider 中 value 属性改变会使所有 消费 context 的组件重新更新。</li><li>Provider 可以逐层传递 context，下一层 Provider 会覆盖上一层 Provider</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS模块化</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/08-CSS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/08-CSS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化-css"><a href="#模块化-css" class="headerlink" title="模块化 css"></a>模块化 css</h1><p>React 没有像 Vue 中 <code>style scoped</code>的模板写法，可以直接在 .vue 文件中声明 css 作用’域’。</p><h2 id="css-模块化的几个重要作用"><a href="#css-模块化的几个重要作用" class="headerlink" title="css 模块化的几个重要作用"></a>css 模块化的几个重要作用</h2><ul><li>防止全局污染，样式覆盖<br>Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但是它的做法有点极端，样式彻底局部化，造成无法重写样式，损失了灵活性。 </li><li>命名混乱<br>没有 css 模块化和统一的规范，会使得多人开发，没有一个规范，比如命名一个类名，有的人用驼峰<code>.contextBox</code>，有的人用下划线<code>.context_box</code>，还有的人用中划线<code>.context-box</code>，使得项目不堪入目。 </li><li>3 css 代码冗余，体积庞大。<br>这种情况也普遍存在，因为 React 中各个组件是独立的，所以导致引入的 css 文件也是相互独立的，比如在两个 css 中，有很多相似的样式代码，如果没有用到 css 模块化，构建打包上线的时候全部打包在一起，那么无疑会增加项目的体积。</li></ul><p>为了解决上述问题 css 模块化应运而生。React 使用 css 模块化的思路主要有两种：</p><ul><li><code>css module</code>，依赖于 webpack 构建的 css-loader 等 loader 处理，将 css 交给 js 来动态加载</li><li>直接放弃 css，采用<code>css in js</code>用 js 对象方式写 css，然后作为 style 方式赋予给 React 组件的 DOM 元素，这种写法将不需要 .css .less .scss 等文件，取而代之的是每一个组件都有一个写对应样式的 js 文件。</li></ul><h2 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h2><p>css Modules ，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css  类名，从根本上解决 css 全局污染，样式覆盖的问题。对于 css modules 的配置，推荐使用 css-loader，因为它对 CSS  Modules 的支持最好，而且很容易使用。接下来介绍一下配置的流程。</p><p><strong>css-loader配置</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  test<span class="hljs-punctuation">:</span> /\.css$/<span class="hljs-punctuation">,</span><span class="hljs-comment">/* 对于 css 文件的处理 */</span><br>  use<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    &#x27;css-loader?modules&#x27; <span class="hljs-comment">/* 配置css-loader ,加一个 modules */</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>css文件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js文件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>+ &#123; <span class="hljs-attr">style.text</span> &#125;&gt;</span>验证 css modules<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure><p>效果：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css01.png" alt="图片.png"><br>样式类名被编译成：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css02.png" alt="图片.png"></p><h3 id="自定义命名规则"><a href="#自定义命名规则" class="headerlink" title="自定义命名规则"></a>自定义命名规则</h3><p>上述的命名规则有一个致命问题，就是命名中没有了 text，在调试阶段，不容易找到对应的元素。</p><p>可以在 css-loader 的配置项中配置 自己的命名规则</p><p><strong>自定义规则命名</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  test<span class="hljs-punctuation">:</span> /\.css$/<span class="hljs-punctuation">,</span> <span class="hljs-comment">// 对于 css 文件的处理</span><br>  use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      loader<span class="hljs-punctuation">:</span>&#x27;css-loader&#x27;<span class="hljs-punctuation">,</span><br>      options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        modules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          localIdentName<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">/* 命名规则  [path][name]__[local] 开发环境 - 便于调试   */</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>样式类名被编译成：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css03.png" alt="图片.png"></p><p>此时类名变成了，<code>src-pages-cssMoudle-style__text--1WHQz</code>，这个命名规则意义如下</p><ul><li><code>**[path][name]_[local]**</code> -&gt; 开发环境，便于调试。可以直接通过 <code>src-pages-cssModule-style</code>找到此类名对应的文件。</li><li><code>**[hash:base64:5]**</code> -&gt; 生产环境，<code>1WHQz</code>便于生产环境压缩类名。</li></ul><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>一旦经过 css modules 处理的 css 文件类名，再引用的时候已经无效了。因为声明的类名，比如上面的 .text 已经被处理成了哈希形式。那么如何快速引用声明好的全局类名呢？</p><p>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局类名。凡是这样声明的 class，都不会被编译成哈希字符串。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br>:<span class="hljs-built_in">global</span>(.text_bg) &#123;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">style.text</span> + &#x27; <span class="hljs-attr">text_bg</span>&#x27;&#125; &gt;</span>验证 CSS Modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css04.png" alt="图片.png"></p><p>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.text)</code>，等同于.text。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span>&#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-comment">/* 等价于 */</span><br>:<span class="hljs-built_in">local</span>(.text_bg) &#123;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合样式"><a href="#组合样式" class="headerlink" title="组合样式"></a>组合样式</h3><p>CSS Modules 提供了一种 <code>composes</code>组合方式，实现对样式的复用。比如通过 composes 方式的实现上面的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.base</span>&#123; <span class="hljs-comment">/* 基础样式 */</span><br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.text</span> &#123; <span class="hljs-comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span><br>    composes:base;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p>js 这么写：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>同样达到了上述效果。此时的 DOM 元素上的类名变成了如下的样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;src-pages-cssModule-style__text--1WHQz src-pages-cssModule-style__base--2gced&quot;</span>&gt;</span>验证 css modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述可以看到，用了 composes 可以将多个 class 类名添加到元素中。composes 还有一个更灵活的方法，支持动态引入别的模块下的类名。比如上述写的 <code>.base</code> 样式在另外一个文件中，完全可以如下这么写：</p><p><strong>style1.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span>&#123;<br>    <span class="hljs-attribute">color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>style.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span> &#123; <span class="hljs-comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span><br>    composes:base from <span class="hljs-string">&#x27;./style1.css&#x27;</span>;  <span class="hljs-comment">/* base 样式在 style1.css 文件中 */</span><br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置-less-和-sass"><a href="#配置-less-和-sass" class="headerlink" title="配置 less 和 sass"></a>配置 less 和 sass</h3><p>配置 less 和 sass 的 CSS Modules 和配置 css 一模一样。以 less 为例子。接下来在刚才的基础上，配置一下 less 的 CSS Modules。</p><p><strong>less webpack配置</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  test<span class="hljs-punctuation">:</span> /\.less$/<span class="hljs-punctuation">,</span><br>  use<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      loader<span class="hljs-punctuation">:</span> &#x27;css-loader&#x27;<span class="hljs-punctuation">,</span><br>      options<span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        modules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          localIdentName<span class="hljs-punctuation">:</span>&#x27;<span class="hljs-punctuation">[</span>path<span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span>name<span class="hljs-punctuation">]</span>---<span class="hljs-punctuation">[</span>local<span class="hljs-punctuation">]</span>---<span class="hljs-punctuation">[</span>hash<span class="hljs-punctuation">:</span>base64<span class="hljs-punctuation">:</span><span class="hljs-number">5</span><span class="hljs-punctuation">]</span>&#x27;<br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 可能是其他 loader, 不过不重要。</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    &#x27;less-loader&#x27;<br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后在刚才的文件同级目录下，新建 <code>index.less</code></p><p><strong>index.less 这么写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text</span>&#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js 中这么写</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span>  <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.css&#x27;</span>      <span class="hljs-comment">/* css  module*/</span> <br><span class="hljs-keyword">import</span> lessStyle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.less&#x27;</span> <span class="hljs-comment">/*  less css module */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">lessStyle.text</span> &#125; &gt;</span>验证 less + css modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css05.png" alt="图片.png"></p><h3 id="组合方案"><a href="#组合方案" class="headerlink" title="组合方案"></a>组合方案</h3><p>正常情况下，React 项目可能在使用 css 处理样式之外，还会使用 scss 或者 less 预处理。那么可不可以使用一种组合方法。</p><ul><li>可以约定对于<strong>全局样式或者是公共组件样式</strong>，可以用 .css 文件 ，不需要做 CSS Modules 处理，这样就不需要写 :global 等繁琐语法。</li><li>对于项目中开发的<strong>页面和业务组件</strong>，统一用 scss 或者 less 等做 CSS Module，也就是 <strong>css 全局样式 + less &#x2F; scss CSS Modules</strong> 方案。这样就会让 React 项目更加灵活的处理 CSS 模块化。我写一个 demo 如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span>  <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.less&#x27;</span> <span class="hljs-comment">/*  less css module */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  &#123;/* 公共样式 */&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;searchbtn&quot;</span> &gt;</span>公共按钮组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">Style.text</span> &#125; &gt;</span>验证 less + css modules <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>效果：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css06.png" alt="图片.png"></p><h3 id="手动添加-class"><a href="#手动添加-class" class="headerlink" title="手动添加 class"></a>手动添加 class</h3><p>CSS Modules 可以配合 classNames 库 实现更灵活的动态添加类名。</p><p>比如在less 中这么写</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.base</span>&#123; <span class="hljs-comment">/* ...基础样式 */</span> &#125;<br><span class="hljs-selector-class">.dark</span>&#123; <span class="hljs-comment">// 主题样式-暗色调</span><br>    <span class="hljs-attribute">background</span>:<span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-selector-class">.light</span>&#123;<span class="hljs-comment">// 主题样式-亮色调</span><br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组件中引入 classNames 库：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;classnames&#x27;</span> <br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.less&#x27;</span> <span class="hljs-comment">/*  less css module */</span><br><span class="hljs-comment">/* 动态加载 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> [ theme , setTheme  ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>  &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">classNames</span>(<span class="hljs-attr">Style.base</span>, <span class="hljs-attr">theme</span> === <span class="hljs-string">&#x27;light&#x27;</span> ? <span class="hljs-attr">Style.light</span> <span class="hljs-attr">:</span> <span class="hljs-attr">Style.dark</span> ) &#125;  </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> setTheme(theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)  &#125;</span><br><span class="language-xml">      &gt; </span><br><span class="language-xml">      切换主题 </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p>通过 CSS Modules 配合 classNames 灵活的实现了样式的动态加载。</p><p>CSS Modules 的注意事项：</p><ul><li>仅用 class 类名定义 css ，不使用其他选择器。</li><li>不要嵌套 <code>css .a&#123; .b&#123;&#125; &#125;</code> 或者重叠 <code>css .a .b &#123;&#125;</code> 。</li></ul><h2 id="CSS-IN-JS"><a href="#CSS-IN-JS" class="headerlink" title="CSS IN JS"></a>CSS IN JS</h2><h3 id="概念和使用"><a href="#概念和使用" class="headerlink" title="概念和使用"></a>概念和使用</h3><p><code>CSS IN JS</code> 相比 CSS Modules 更加简单， CSS IN JS 放弃css ，用 js 对象形式直接写 style 。先写一个例子尝尝鲜。</p><p>在 index.js 写 React 组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">Style.boxStyle</span> &#125;  &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">Style.textStyle</span> &#125;  &gt;</span>hi , i am CSS IN JS!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>在同级目录下，新建 style.js 用来写样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 容器的背景颜色 */</span><br><span class="hljs-keyword">const</span> boxStyle = &#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;<br><span class="hljs-comment">/* 字体颜色 */</span><br><span class="hljs-keyword">const</span> textStyle = &#123;<br>    <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;orange&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    boxStyle,<br>    textStyle<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><h3 id="灵活运用"><a href="#灵活运用" class="headerlink" title="灵活运用"></a>灵活运用</h3><p>由于 CSS IN JS 本质上就是运用 js 中对象形式保存样式， 所以 js 对象的操作方法都可以灵活的用在 CSS IN JS上。<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css07.png" alt="图片.png"><br><strong>拓展运算符实现样式继承</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> baseStyle = &#123; <span class="hljs-comment">/* 基础样式 */</span> &#125;<br><br><span class="hljs-keyword">const</span> containerStyle = &#123; <br>    ...baseStyle,  <span class="hljs-comment">// 继承  baseStyle 样式</span><br>    <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#ccc&#x27;</span>   <span class="hljs-comment">// 添加的额外样式</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动态添加样式变得更加灵活</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 暗色调  */</span><br><span class="hljs-keyword">const</span> dark = &#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;black&#x27;</span>,<br>&#125;<br><span class="hljs-comment">/* 亮色调 */</span><br><span class="hljs-keyword">const</span> light = &#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;white&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">theme</span>===<span class="hljs-string">&#x27;light&#x27;</span> ? <span class="hljs-attr">Style.light</span> <span class="hljs-attr">:</span> <span class="hljs-attr">Style.dark</span>  &#125;  &gt;</span>hi , i am CSS IN JS!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更复杂的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;</span> &#123; <span class="hljs-attr">...Style.textStyle</span> , <span class="hljs-attr">...</span>(<span class="hljs-attr">theme</span>===<span class="hljs-string">&#x27;light&#x27;</span> ? <span class="hljs-attr">Style.light</span> <span class="hljs-attr">:</span> <span class="hljs-attr">Style.dark</span>  ) &#125;&#125;  &gt;</span>hi , i am CSS IN JS!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-3-3-style-components-的使用"><a href="#8-3-3-style-components-的使用" class="headerlink" title="8.3.3 style-components 的使用"></a>8.3.3 style-components 的使用</h3><p>CSS IN JS 也可以由一些第三方库支持，比如 <code>style-components</code>。<code>style-components</code>可以把写好的 css 样式注入到组件中，项目中应用的已经是含有样式的组件。</p><p><strong>基础用法</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span><br><span class="hljs-comment">/* 给button标签添加样式，形成 Button React 组件 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><br><span class="hljs-string">background: #6a8bad;</span><br><span class="hljs-string">color: #fff;</span><br><span class="hljs-string">min-width: 96px;</span><br><span class="hljs-string">height :36px;</span><br><span class="hljs-string">border :none;</span><br><span class="hljs-string">border-radius: 18px;</span><br><span class="hljs-string">font-size: 14px;</span><br><span class="hljs-string">font-weight: 500;</span><br><span class="hljs-string">cursor: pointer;</span><br><span class="hljs-string">margin-left: 20px !important;</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css08.png" alt="图片.png"></p><p><strong>基于 props 动态添加样式</strong></p><p>style-components 可以通过给生成的组件 添加 props 属性，来动态添加样式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><br><span class="hljs-string">background: <span class="hljs-subst">$&#123; props =&gt; props.theme ? props.theme : <span class="hljs-string">&#x27;#6a8bad&#x27;</span>  &#125;</span>;</span><br><span class="hljs-string">color: #fff;</span><br><span class="hljs-string">min-width: 96px;</span><br><span class="hljs-string">height :36px;</span><br><span class="hljs-string">border :none;</span><br><span class="hljs-string">border-radius: 18px;</span><br><span class="hljs-string">font-size: 14px;</span><br><span class="hljs-string">font-weight: 500;</span><br><span class="hljs-string">cursor: pointer;</span><br><span class="hljs-string">margin-left: 20px !important;</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;</span>&#x27;#<span class="hljs-attr">fc4838</span>&#x27;&#125;  &gt;</span>props主题按钮<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>效果：<br><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/Css/Css09.png" alt="图片.png"><br><strong>继承样式</strong></p><p>style-components 可以通过继承方式来达到样式的复用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NewButton</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-title class_">Button</span>)<span class="hljs-string">`</span><br><span class="hljs-string">background: orange;</span><br><span class="hljs-string">color: pink;</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">NewButton</span> &gt;</span> 继承按钮<span class="hljs-tag">&lt;/<span class="hljs-name">NewButton</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>style-components 还有一些其他的功能，官网：<a href="https://styled-components.com/docs/basics#extending-styles">styled-components</a></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>CSS模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高阶组件</title>
    <link href="/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/09-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/07/18/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/09-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><h2 id="高阶组件基本介绍-能解决什么问题？"><a href="#高阶组件基本介绍-能解决什么问题？" class="headerlink" title="高阶组件基本介绍-能解决什么问题？"></a>高阶组件基本介绍-能解决什么问题？</h2><p><strong>案例：</strong></p><p>话说小明负责开发一个 web 应用，应用的结构如下所示，而且这个功能小明已经开发完了。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High01.png" alt="image.png"></p><p>但是，有一天老板突然提出了一个权限隔离的需求，就是部分模块组件受到权限控制，后台的数据交互的结果权限控制着模块展示与否，而且没有权限会默认展示无权限提示页面。（如下图，黄色部分是受到权限控制的组件模块）</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High02.png" alt="image.png"><br>那么小明面临的问题是，如何给需要权限隔离的模块，绑定权限呢？那第一种思路是把所有的需要权限隔离的模块重新绑定权限，通过权限来判断组件是否展示。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High03.png" alt="image.png"></p><p>这样无疑会给小明带来很多的工作量，而且后续项目可能还有受权限控制的页面或者组件，都需要手动绑定权限。那么如何解决这个问题呢，思考一下，既然是判断权限，那么可以把逻辑都写在一个容器里，然后将每个需要权限的组件通过容器包装一层，这样不就不需要逐一手动绑定权限了吗？所以 HOC 可以合理的解决这个问题，通过 HOC 模式结构如下图所示：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High04.png" alt="image.png"></p><p>综上所述，HOC的产生根本作用就是解决大量的代码复用，逻辑复用问题。既然说到了逻辑复用，那么具体复用了哪些逻辑呢？</p><ul><li>首先第一种就是像上述的拦截问题，本质上是对渲染的控制，对渲染的控制可不仅仅指是否渲染组件，还可以像 dva 中 dynamic 那样懒加载&#x2F;动态加载组件。</li><li>还有一种场景，比如项目中想让一个非 Route 组件，也能通过 props 获取路由实现跳转，但是不想通过父级路由组件层层绑定 props ，这个时候就需要一个 HOC 把改变路由的 history 对象混入 props 中，于是 withRoute 诞生了。所以 HOC  还有一个重要的作用就是让 props 中混入一些你需要的东西。</li><li>还有一种情况，如果不想改变组件，只是监控组件的内部状态，对组件做一些赋能，HOC 也是一个不错的选择，比如对组件内的点击事件做一些监控，或者加一次额外的生命周期。</li></ul><h3 id="高阶组件的概念"><a href="#高阶组件的概念" class="headerlink" title="高阶组件的概念"></a>高阶组件的概念</h3><p>高阶组件真的很好理解，都知道高阶函数就是一个将函数作为参数并且返回值也是函数的函数。高阶组件是以组件作为参数，返回组件的函数。返回的组件把传进去的组件进行功能强化。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High05.png" alt="image.png"></p><p><strong>两种不同的高阶组件</strong></p><p>常用的高阶组件有<strong>属性代理</strong>和<strong>反向继承</strong>两种，两者之间有一些共性和区别。</p><p><strong>属性代理</strong></p><p>属性代理，就是用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作。</p><p>注意：属性代理返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-params">WrapComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span><br>    &#125;<br>      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> (<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WarpComponent</span> &#123; <span class="hljs-attr">...this.props</span> &#125; &#123; <span class="hljs-attr">...this.state</span> &#125; /&gt;</span></span><br>      )<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无需知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC，目前开源的 HOC 基本都是通过这个模式实现的。</li><li>同样适用于类组件和函数组件</li><li>可以完全隔离业务组件的渲染，因为属性代理说白了就是一个新的组件，相比反向继承可以完全控制业务组件是否渲染。</li><li>可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。</li></ul><p>缺点：</p><ul><li>一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。</li><li>无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。</li><li>因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref</li></ul><p><strong>反向继承</strong></p><p>反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          hello, world!</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span> (<span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">wrapComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-title class_">Index</span>)<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>方便获取组件内部状态，比如 state，props，生命周期，绑定的事件函数等。</li><li>es6 继承可以良好继承静态属性。所以无需对静态属性和方法进行额外的处理。</li></ul><p>缺点：</p><ul><li>函数组件无法使用。</li><li>和被包装的组件耦合度高，需要知道被包装的组件的内部状态，具体做了些啥？</li><li>如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态，这样带来的隐患是非常大的，比如说有多个 componentDidMount，当前 componentDidMount 会覆盖上一个 componentDidMount。这样副作用串联起来，影响很大。</li></ul><h2 id="高阶组件功能说明-如何编写高阶组件？"><a href="#高阶组件功能说明-如何编写高阶组件？" class="headerlink" title="高阶组件功能说明-如何编写高阶组件？"></a>高阶组件功能说明-如何编写高阶组件？</h2><h3 id="强化-props"><a href="#强化-props" class="headerlink" title="强化 props"></a>强化 props</h3><p>强化 props 就是在原始组件的 props 基础上，加入一些其他的 props，强化原始组件功能。</p><p>例子：为了让组件也可以获取到路由对象，进行路由跳转等操作，所以 React Router 提供了类似 withRouter 的 HOC。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withRouter</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">const</span> displayName = <span class="hljs-string">`withRouter($(Component.displayName || Component.name))`</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">C</span> = props =&gt; &#123;<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterContext.Consumer</span>&gt;</span></span><br><span class="language-xml">          &#123;context =&gt; &#123;</span><br><span class="language-xml">             return (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Component</span></span></span><br><span class="hljs-tag"><span class="language-xml">              &#123;<span class="hljs-attr">...remainingProps</span>&#125; // <span class="hljs-attr">组件原始的</span> <span class="hljs-attr">props</span></span></span><br><span class="hljs-tag"><span class="language-xml">              &#123;<span class="hljs-attr">...context</span>&#125;        // <span class="hljs-attr">存在路由对象的上下文</span>，<span class="hljs-attr">history</span> <span class="hljs-attr">location</span> <span class="hljs-attr">等</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;wrappedComponentRef&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span></span><br><span class="language-xml">             );</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">RouterContext.Consumer</span>&gt;</span></span><br>    )<br>  &#125;<br>  C.<span class="hljs-property">displayName</span> = displayName;<br>    C.<span class="hljs-property">WrappedComponent</span> = <span class="hljs-title class_">Component</span>;<br>    <span class="hljs-comment">// 继承静态属性</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">hoistStatics</span>(C, <span class="hljs-title class_">Component</span>);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withRouter<br></code></pre></td></tr></table></figure><p>流程分析：</p><ul><li>分离出 props 中 wrappedComponentRef 和 remainingProps，remainingProps 是原始组件真正的 props，wrappedComponentRef 用于转发 ref。</li><li>用 Context.Consumer 上下文模式获取保存的路由信息。（React Router 中路由状态是通过 context 上下文保存传递的）</li><li>将路由对象和原始 props 传递给原始组件，所以可以在原始组件中获取 history，location 等信息。</li></ul><h3 id="控制渲染"><a href="#控制渲染" class="headerlink" title="控制渲染"></a>控制渲染</h3><p><strong>渲染劫持</strong></p><p>HOC 反向继承模式，可以通过 super.render() 得到 render 之后的内容，利用这一点，可以做·渲染劫持，更有甚者修改 render  之后的 React element 对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">HOC</span> = (<span class="hljs-params">WarpComponent</span>) =&gt; <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> = <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WrapCompoent</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">visble</span>) &#123;<br>        renturn <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>暂无数据<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>修改渲染树</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>react<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Angular<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span> (<span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>()<br>      <span class="hljs-keyword">const</span> otherProps = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alien&#x27;</span><br>      &#125;<br>      <span class="hljs-comment">// 替换 Angular 元素节点</span><br>      <span class="hljs-keyword">const</span> appendElement = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>,&#123;&#125;,<span class="hljs-string">`hello ,world , my name  is <span class="hljs-subst">$&#123; otherProps.name &#125;</span>`</span>)<br>      <span class="hljs-keyword">const</span> newchild = <span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">map</span>(element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>,<span class="hljs-function">(<span class="hljs-params">child,index</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span> (index === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> appendElement<br>        <span class="hljs-keyword">return</span> child<br>      &#125;)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(element, element.<span class="hljs-property">props</span>, newchild)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-title class_">Index</span>)<br></code></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High06.png" alt="image.png"><br><strong>动态加载</strong></p><p>dva 中 dynamic 就是配合 import，实现组件的动态加载的，而且每次切换路由，都会有 Loading 效果</p><p><strong>实现思路：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicHoc</span>(<span class="hljs-params">loadRouter</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<span class="hljs-title class_">Component</span>: <span class="hljs-literal">null</span>&#125;<br>      <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">Component</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-title function_">loadRouter</span>()<br>          .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>) <span class="hljs-comment">// 动态加载 component 组件</span><br>          .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-title class_">Component</span>&#125;,))<br>    &#125;<br>      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Component</span> &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Component</span> ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;</span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">...this.props</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &#125; /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Index</span> = <span class="hljs-title class_">AsyncRouter</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/index&#x27;</span>))<br></code></pre></td></tr></table></figure><p>实现思路：</p><ul><li>Index 组件中，在 componentDidMount 生命周期动态加载上述的路由组件 Component，如果在切换路由或者没有加载完毕时候，显示的是 Loading 效果。</li></ul><h3 id="组件赋能"><a href="#组件赋能" class="headerlink" title="组件赋能"></a>组件赋能</h3><p><strong>ref 获取实例</strong></p><p>对于属性代理虽然不能直接获取组件内部的状态，但是可以通过 ref 获取组件实例，获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：类组件才存在实例，函数组件不存在实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hoc</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">super</span>()<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span> = <span class="hljs-literal">null</span> <span class="hljs-comment">// 获取组件实例，可以做一些其他的操作</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...this.props</span>&#125; <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;(node)</span> =&gt;</span> this.node = node&#125; /&gt;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件监控</strong></p><p>HOC 也可以单纯增加一些事件监听，错误监控。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClickHoc</span> (<span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Warp</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> dom = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handerClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生点击事件&#x27;</span>)<br>      dom.<span class="hljs-property">current</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handerClick)<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> dom.<span class="hljs-property">current</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,handerClick)<br>    &#125;,[])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;dom&#125;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span> = <span class="hljs-string">&#x27;index&#x27;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello, world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>组件内部点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Index</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>组件外部点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高阶组件注意事项"><a href="#高阶组件注意事项" class="headerlink" title="高阶组件注意事项"></a>高阶组件注意事项</h2><h3 id="谨慎修改原型链"><a href="#谨慎修改原型链" class="headerlink" title="谨慎修改原型链"></a>谨慎修改原型链</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span> (<span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">const</span> proDidMount = <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">componentDidMount</span><br>  <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">componentDidMount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;劫持生命周期：componentDidMount&#x27;</span>)<br>    proDidMount.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Component</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上 HOC 作用仅仅是修改了原来组件原型链上的 componentDidMount 生命周期。但是这样有一个弊端就是如果再用另外一个 HOC 修改原型链上的 componentDidMount ，那么这个HOC的功能即将失效。</p><h3 id="不要再函数组件内部或者类组件-render-函数中使用-HOC"><a href="#不要再函数组件内部或者类组件-render-函数中使用-HOC" class="headerlink" title="不要再函数组件内部或者类组件 render 函数中使用 HOC"></a>不要再函数组件内部或者类组件 render 函数中使用 HOC</h3><p>类组件中的错误写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">const</span> <span class="hljs-title class_">WrapHome</span> = <span class="hljs-title function_">HOC</span>(<span class="hljs-title class_">Home</span>)<br>     <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapHome</span> /&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数组件中的错误写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">WrapHome</span> = <span class="hljs-title function_">HOC</span>(<span class="hljs-title class_">Home</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapHome</span> /&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这么写的话每一次类组件触发 render 或者函数组件执行都会产生一个新的WrapHome，<code>react diff</code> 会判定两次不是同一个组件，那么就会卸载老组件，重新挂载新组件，老组件内部的真实 DOM 节点，都不会合理的复用，从而造成了性能的浪费，而且原始组件会被初始化多次。</p><h3 id="ref-的处理"><a href="#ref-的处理" class="headerlink" title="ref 的处理"></a>ref 的处理</h3><p>高阶组件的约定是将所有 props 传递给被包装组件，但是对于 ref 并不适用。那是因为 ref 实际上并不是一个 prop，就像 key 一样，对于 ref 属性它是由 React 专门处理的，可以通过 <code>forwardRef</code>做 ref 的转发处理。</p><h3 id="注意多个-HOC-嵌套顺序问题"><a href="#注意多个-HOC-嵌套顺序问题" class="headerlink" title="注意多个 HOC 嵌套顺序问题"></a>注意多个 HOC 嵌套顺序问题</h3><p>多个 HOC 嵌套，需要留意 HOC 的顺序，还要分析出各个 HOC 之间是否由依赖关系。</p><p>对于 class 声明的类组件，可以用装饰器模式，对类组件进行包装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title class_">HOC1</span>(styles)<br>@<span class="hljs-title class_">HOC2</span><br>@<span class="hljs-title class_">HOC3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于函数组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span> () &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HOC1</span>(styles)(<span class="hljs-title class_">HOC2</span>( <span class="hljs-title class_">HOC3</span>(<span class="hljs-title class_">Index</span>) ))<br></code></pre></td></tr></table></figure><p>HOC1 -&gt; HOC2 -&gt; HOC3 -&gt; Index</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/React/%E5%9F%BA%E7%A1%80/High/High07.png" alt="image.png"></p><p><strong>要注意一下包装顺序，越靠近 <strong><code>**Index**</code></strong> 组件的，就是越内层的 HOC ,离组件 <strong><code>**Index**</code></strong> 也就越近。</strong></p><p>小细节：</p><ul><li>如果2 个 HOC 互相之间由依赖，比如 HOC1 依赖 HOC2，那么 HOC1 应该在 HOC2 内部。</li><li>如果想通过 HOC 方式给原始组件添加一些额外生命周期，因为涉及到获取原始组件的实例 instance，那么当前的 HOC 要离原始组件最近。</li></ul><h3 id="继承静态属性"><a href="#继承静态属性" class="headerlink" title="继承静态属性"></a>继承静态属性</h3><p>上述讲到在属性代理 HOC 本质上返回了一个新的 component ，那么如果给原来的 component 绑定一些静态属性方法，如果不处理，新的 component 上就会丢失这些静态属性方法。那么如何解决这个问题呢。</p><p><strong>手动继承</strong></p><p>当然可以手动将原始组件的静态方法 copy 到 HOC 组件上来，但前提是必须准确知道应该拷贝哪些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrappedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">// 必须准确知道应该拷贝哪些方法</span><br>  <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">staticMetheod</span> = <span class="hljs-title class_">Component</span>.<span class="hljs-property">staticMethod</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">WrappedComponent</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引入第三方库</strong></p><p>每个静态属性方法都手动绑定会很累，尤其对于开源的 HOC，对于原生组件的静态方法是未知，可以使用<code>hoist-non-react-statics</code>自动拷贝所有的静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> hoistNonReactStatic <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hoist-non-react-statics&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HOC</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrappedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>      <span class="hljs-comment">/*...*/</span><br>  &#125;<br>  <span class="hljs-title function_">hoistNonReactStatic</span>(<span class="hljs-title class_">WrappedComponent</span>,<span class="hljs-title class_">Component</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">WrappedComponent</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进阶实践-权限拦截"><a href="#进阶实践-权限拦截" class="headerlink" title="进阶实践-权限拦截"></a>进阶实践-权限拦截</h2><p>demo展示：</p><p>假设期望效果：</p><ul><li>将文档管理和标签管理模块，配置成权限拦截的页面。</li><li>模拟数据交互，返回模拟数据拦截文档录入和标签录入两个页面。</li></ul><p>思路：</p><ul><li>需要权限的页面或者组件，用 HOC 包裹，并输入唯一的权限签名。</li><li>用 Context 上下文保存全局的权限菜单列表，用 Provider 注入异步获取到的权限菜单。</li><li>HOC 中用 Consumer 获取权限列表，并且和签名做匹配，如果有权限，就展示，如果没有权限，展示默认没有权限组件。</li></ul><p><strong>第一步：在根部注入权限</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Permission</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>([])<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> = <span class="hljs-title class_">Index</span>() &#123;<br>  <span class="hljs-keyword">const</span> [ rootPermission, setRootPermission ] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>([])<br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取权限列表</span><br>    <span class="hljs-title function_">getRootPermission</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> &#123; code, data &#125; = res <span class="hljs-keyword">as</span> any<br>      code === <span class="hljs-number">200</span> &amp;&amp; <span class="hljs-title function_">setRootPermission</span>(data) <span class="hljs-comment">// [ &#x27;docList&#x27;, &#x27;tagList&#x27; ]</span><br>    &#125;)<br>  &#125;,[])<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Permission.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;rootPermission&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RootRouter</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Permission.Provider</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>useState 用于动态注入获取的权限列表</li><li>根组件通过 Context.Provider 包裹。权限列表改变，所有消费权限列表的组件重新更新。</li></ul><p>（假设一下数据交互返回的权限列表<code>[ &#39;docList&#39; , &#39;tagList&#39; ]</code>）</p><p><strong>第二步：重点编写HOC</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 没有权限</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">NoPermission</span> () &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>您暂时没有权限，请联系管理员开通权限<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 编写 HOC</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PermissionHoc</span>(<span class="hljs-params">authorization</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">Component</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span> (props) &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">matchPermission</span> = (<span class="hljs-params">value,list</span>) =&gt; list.<span class="hljs-title function_">indeOf</span>(value) <span class="hljs-comment">// 匹配权限</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Permission.Consumer</span>&gt;</span></span><br><span class="language-xml">          &#123;</span><br><span class="language-xml">          (permissionList) =&gt; matchPermission(authorization,permissionList) &gt;= 0 ? <span class="hljs-tag">&lt;<span class="hljs-name">Component</span>  &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">NoPermission</span> /&gt;</span></span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Permission.Consumer</span>&gt;</span></span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HOC 编写</p><ul><li>用两层包装函数的 HOC，第一层用于获取 HOC 绑定的当前组件的权限签名，因为要用这个权限签名和权限列表做匹配，第二层接受的原始组件。</li><li>在 HOC 中用 Context.Consumer 接收权限列表，做权限匹配。组件有权限展示，没有权限展示无权限组件。</li></ul><p><strong>第三部：绑定权限</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title class_">PermissionHoc</span>(<span class="hljs-string">&#x27;writeDoc&#x27;</span>) <span class="hljs-comment">// 绑定文档录入页面</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">PermissionHoc</span>(<span class="hljs-string">&#x27;writeTag&#x27;</span>)(index) <span class="hljs-comment">// 绑定标签录入页面</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">PermissionHoc</span>(<span class="hljs-string">&#x27;tagList&#x27;</span>)(index) <span class="hljs-comment">// 绑定标签列表页面</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">PermissionHoc</span>(<span class="hljs-string">&#x27;docList&#x27;</span>)(<span class="hljs-title class_">Index</span>) <span class="hljs-comment">// 绑定文档列表页面</span><br></code></pre></td></tr></table></figure><ul><li>对于业务组件进行权限 HOC 的包裹。</li></ul><p>因为上述模拟数据返回的是<code>[ &#39;docList&#39; , &#39;tagList&#39; ]</code>，所以最终只能看到 标签列表 和 文档列表 页面。</p><p><strong>第四步：验证效果</strong></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>React</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>高阶组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul><li><code>undefined</code></li><li><code>Null</code></li><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code> (ES6)</li><li><code>Bigint</code> (ES6)</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li><code>Object</code><ul><li><code>Object</code> (<code>Array</code>, <code>Date</code>…)</li><li><code>Function</code></li></ul></li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>在发生转换的时候，js其实都是会将操作对象转化为原始的对象</p><h2 id="ToPrimitive-原始值转换算法"><a href="#ToPrimitive-原始值转换算法" class="headerlink" title="ToPrimitive(原始值转换算法)"></a>ToPrimitive(原始值转换算法)</h2><p>注意：<code>Date</code>类型按照<code>String</code>去调用</p><ol><li>输入为原始类型，直接返回</li><li>输入非原始类型，调用该对象的<code>valueOf()</code>方法，如果结果是原始类型，返回</li><li>调用<code>valueOf()</code>结果不是原始类型，再对结果，调用<code>toString()</code>方法，如果结果为原始类型，返回</li><li>如果返回不是原始类型，抛出异常<code>TypeError</code></li></ol><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> srt = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-keyword">let</span> num = str - <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = =<span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> str = num + <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这种类似的数学运算会做类型转换<br><code>*</code>，<code>/</code>和<code>-</code>操作符都是数字运算专用的。当这些运算符与字符串一起使用时，会强制转换字符串为数字类型的值。<br><code>+</code>的特殊之处 </p><ul><li><code>+</code>作为双目运算符，例如<code>a + b</code><ul><li>计算两个操作数的原始类型<code>prima = Toprimitive(a), prima = ToPrimitive(b)</code></li><li>如果原始类型有<code>String</code>,全部转换为<code>String</code>，返回<code>String</code>相加后的结果</li><li>如果原始类型没有<code>String</code>，则全部转换为<code>Number</code>，返回<code>Number</code>相加后的结果</li></ul></li><li><code>+</code>作为单目运算符，例如<code>+a</code><ul><li>将<code>a</code>转换为<code>Number</code>，<code>Number(a)</code></li></ul></li></ul><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id=""><a href="#" class="headerlink" title="[]+[]"></a><code>[]+[]</code></h2><ol><li>转换为原始类型 <code>toPrimitive([])</code><ol><li><code>[].valueOf()</code>返回<code>[]</code>不是原始类型</li><li><code>[].toString()</code>返回<code>&#39;&#39;</code></li></ol></li><li>都为<code>String</code>所以返回字符串相加的结果</li><li><code>return &#39;&#39; + &#39;&#39;</code></li></ol><h2 id="-1"><a href="#-1" class="headerlink" title="{} + []"></a><code>&#123;&#125; + []</code></h2><ol><li>在浏览器中，<code>JS</code>引擎认为第一个<code>&#123;&#125;</code>为空代码，所以 这里的<code>+</code>是单目运算符<ol><li><code>node</code>中认为是对象，解析为<code>&quot;[object Object]&quot;</code></li></ol></li><li>转换为原始类型<code>toPrimitive([])</code>返回<code>&#39;&#39;</code></li><li><code>Number(&#39;&#39;)</code>返回<code>0</code></li></ol><h2 id="-2"><a href="#-2" class="headerlink" title="[] + {}"></a><code>[] + &#123;&#125;</code></h2><p>注意： <code>[].valueOf</code> 为<code>[]</code>, 但在ES6中JS会优先调用<code>[Symbol ToPrimitive]</code>来转换为原始类型。</p><ol><li>转换为原始类型<ol><li><code>[].toString()</code>返回<code>&#39;&#39;</code></li><li><code>&#123;&#125;.toString()</code>返回<code>&quot;[object Object]&quot;</code></li></ol></li><li>都为<code>String</code>返回字符串相加的结果<code>&quot;[object Object]&quot;</code></li></ol><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等==="></a>严格相等<code>===</code></h2><p>首先判断类型，类型一致，再判断值，都一致才会<code>return true</code>，否则<code>return false</code></p><h2 id="宽松相等"><a href="#宽松相等" class="headerlink" title="宽松相等=="></a>宽松相等<code>==</code></h2><p>先将操作数转换为相同类型，再做比较<br>例如<code>x == y</code></p><ol><li><code>x,y</code>都为<code>Null</code>或<code>undefined</code>，<code>return true</code></li><li><code>x</code>或<code>y</code>为<code>NaN</code>，<code>return false</code></li><li>如果<code>x</code>和<code>y</code>为<code>String``Number``Boolean</code>并且类型不一致，都转为<code>Number</code>再进行比较</li><li>如果存在<code>Object</code>，则转换为原始类型比较</li></ol><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><h3 id="false"><a href="#false" class="headerlink" title="[] == false"></a><code>[] == false</code></h3><ol><li>存在<code>Object</code>，转换为原始类型<ol><li><code>ToPrimitive([])</code>返回<code>&#39;&#39;</code></li></ol></li><li>存在一个<code>String</code>，另一个是<code>Boolean</code>；都转为<code>Number</code></li><li>都转为<code>Number</code><ol><li><code>Number(&#39;&#39;)</code>返回<code>0</code></li><li><code>Number(false)</code>返回<code>0</code></li></ol></li><li>再进行比较<ol><li><code>return 0 == 0</code>返回<code>true</code></li></ol></li></ol><h1 id="ToPrimitive转换规则"><a href="#ToPrimitive转换规则" class="headerlink" title="ToPrimitive转换规则"></a>ToPrimitive转换规则</h1><table><thead><tr><th>value</th><th>toNumber</th><th>toString</th><th>toBoolean</th></tr></thead><tbody><tr><td>NaN</td><td>NaN</td><td>“NaN”</td><td>false</td></tr><tr><td>Infinity</td><td>Infinity</td><td>“Infinity”</td><td>true</td></tr><tr><td>[]</td><td>0</td><td>‘“”</td><td>true</td></tr><tr><td>[1]</td><td>1</td><td>“1”</td><td>true</td></tr><tr><td>null</td><td>0</td><td>“null”</td><td>false</td></tr><tr><td>undefined</td><td>NaN</td><td>“undefined”</td><td>false</td></tr><tr><td>{}</td><td>NaN</td><td>“[object Object]”</td><td>true</td></tr><tr><td>function()</td><td>NaN</td><td>“function”</td><td>true</td></tr></tbody></table><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>NaN</td></tr><tr><td>null</td><td>0</td></tr><tr><td>Boolean值</td><td>true转换为1，false转换为+0</td></tr><tr><td>Number</td><td>无需转换</td></tr><tr><td>String</td><td>例如”1.1”转换成1.1</td></tr></tbody></table><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td></tr><tr><td>null</td><td>“null”</td></tr><tr><td>Boolean值</td><td>“true”或者”false”</td></tr><tr><td>String</td><td>无需转换</td></tr><tr><td>Number</td><td>例如1.1转换成”1.1”</td></tr></tbody></table><blockquote><p><code>toPrimitive([]) = &#39;&#39;</code>，可以想成<code>[].join()</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用堆栈与this</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02.%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E4%B8%8Ethis/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02.%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E4%B8%8Ethis/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的执行上下文和执行栈"><a href="#JavaScript-中的执行上下文和执行栈" class="headerlink" title="JavaScript 中的执行上下文和执行栈"></a>JavaScript 中的执行上下文和执行栈</h1><p>执行上下文是当前 Javascript 代码被解析和执行时所在环境的抽象概念。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><ul><li><strong>全局执行上下文：</strong>只有一个，浏览器中的全局对象：window ，<code>this</code>指向这个全局对象。</li><li><strong>函数执行上下文：</strong>函数每被调用一次，就会创建一个函数执行上下文。</li><li><strong>Eval 函数执行上下文：</strong>运行在<code>eval</code>函数中的代码，不常用</li></ul><h3 id="执行上下文的三个重要属性"><a href="#执行上下文的三个重要属性" class="headerlink" title="执行上下文的三个重要属性"></a>执行上下文的三个重要属性</h3><ul><li>变量对象（Variable Object，VO）</li><li>作用域链（Scope chain）</li><li>this</li></ul><h3 id="执行上下文的创建阶段"><a href="#执行上下文的创建阶段" class="headerlink" title="执行上下文的创建阶段"></a>执行上下文的创建阶段</h3><ul><li>确定 this 的值，This Binding</li><li>LexicalEnvironment（词法环境）组件被创建</li><li>VariableEnvironment（变量环境）组件被创建</li></ul><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ExecutionContext</span> = &#123;<br>  <span class="hljs-title class_">ThisBinding</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">this</span> <span class="hljs-attr">value</span>&gt;</span>, // 确定 this</span><br><span class="language-xml">  LexicalEnvironment = &#123;...&#125;, // 词法环境</span><br><span class="language-xml">  VariableEnvironment = &#123;...&#125;, // 变量环境</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h4><ul><li><strong>全局</strong>执行上下文中，<code>this</code> 指向全局对象，在浏览器指向 <code>window</code>，在<code>nodejs</code>中指向这个文件的<code>module</code>对象。</li><li><strong>函数</strong>执行上下文中，<code>this</code>的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定（硬绑定）、<code>new</code>绑定、箭头函数</li></ul><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><ul><li><strong>环境记录：</strong>存储变量和函数声明的实际位置</li><li><strong>对外部环境的引用：</strong>可以访问其外部词法环境</li></ul><p>词法环境又分为：</p><ul><li><strong>全局环境：</strong>没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</li><li><strong>函数环境：</strong>用户在函数中定义的变量被存储在<strong>环境记录</strong>中，包含了<code>arguments</code>对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li></ul><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GlobalExectionContext</span> = &#123; <span class="hljs-comment">// 全局执行上下文</span><br>  <span class="hljs-title class_">LexicalEnvironment</span>: &#123; <span class="hljs-comment">// 词法环境</span><br>  <span class="hljs-title class_">EnvironmentRecord</span>: &#123; <span class="hljs-comment">// 环境记录</span><br>    <span class="hljs-title class_">Type</span>: <span class="hljs-string">&quot;Object&quot;</span>,    <span class="hljs-comment">// 全局环境</span><br>      <span class="hljs-comment">// 标识符绑定在这里</span><br>      <span class="hljs-attr">outer</span>:&lt;<span class="hljs-literal">null</span>&gt;       <span class="hljs-comment">// 对外部环境的引用</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">FunctionExectionContext</span> = &#123; <span class="hljs-comment">// 函数执行上下文</span><br>  <span class="hljs-title class_">LexicalEnvironment</span>: &#123; <span class="hljs-comment">// 词法环境</span><br>  <span class="hljs-title class_">EnvironmentRecord</span>: &#123; <span class="hljs-comment">// 环境记录</span><br>  <span class="hljs-title class_">Type</span>: <span class="hljs-string">&quot;Declarative&quot;</span>, <span class="hljs-comment">// 函数环境</span><br>  <span class="hljs-comment">// 标识符绑定在这里     // 对外部环境的引用</span><br>  <span class="hljs-attr">outer</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Global</span> <span class="hljs-attr">or</span> <span class="hljs-attr">outer</span> <span class="hljs-attr">function</span> <span class="hljs-attr">environment</span> <span class="hljs-attr">reference</span>&gt;</span></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，<strong>词法</strong>环境和<strong>变量</strong>环境的区别在于<strong>前者用于存储函数声明和变量（</strong><code>**let**</code><strong>和</strong><code>**const**</code><strong>）绑定，而后者仅用于存储变量（</strong><code>**var**</code><strong>）绑定</strong></p><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> c;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">e, f</span>) &#123;<br>  <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">return</span> e * f * g;<br>&#125;<br>c = <span class="hljs-title function_">multiply</span>(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>执行上下文如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GlobalExectionContext</span> = &#123;<br>  <span class="hljs-title class_">ThisBinding</span>: &lt;Global Object&gt;,<br>  <br>  LexicalEnvironment: &#123;<br>  EnvironmentRecord: &#123;<br>  Type: &quot;Object&quot;,<br>  // 标识符绑定在这里<br>  a: &lt; uninitialized&gt;,<br>  b: &lt; uninitialized&gt;,<br>  multiply: &lt; func &gt;<br>&#125;<br>outer: &lt;null&gt;<br>&#125;,<br><br>VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 标识符绑定在这里<br>      c: undefined,<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  ThisBinding: &lt;Global Object&gt;,<br>  <br>  LexicalEnvironment: &#123;<br>  EnvironmentRecord: &#123;<br>  Type: &quot;Declarative&quot;,<br>  // 标识符绑定在这里<br>  Arguments: &#123;0: 20, 1: 30, length: 2&#125;,<br>&#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>&#125;,<br>  <br>  VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 标识符绑定在这里<br>      g: undefined<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 <code>undefined</code>（在 <code>var</code> 的情况下）或保持未初始化（在 <code>let</code> 和 <code>const</code> 的情况下）。所以这就是为什么可以在声明之前访问 <code>var</code> 定义的变量（尽管是 <code>undefined</code> ），但如果在声明之前访问 <code>let</code> 和 <code>const</code> 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h3 id="执行上下文的执行阶段"><a href="#执行上下文的执行阶段" class="headerlink" title="执行上下文的执行阶段"></a>执行上下文的执行阶段</h3><p>此阶段，完成对所有变量的分配，最后执行代码。</p><p>如果 JS 引擎在源代码中声明的实际位置找不到 <code>let</code> 变量的值，那么为其分配 <code>undefined</code> 值。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>是一个 LIFO（后进先出）的栈结构的数据类型，用于存储在代码执行期间所创建的执行上下文。</p><p>在 JS 的环境中：</p><p>首次运行 JS 代码时，会创建一个<strong>全局</strong>执行上下文并 push 到当前的执行栈中，每当发生函数调用，JS引擎都会为该函数创建一个新的函数执行上下文并且 push 到当前执行栈的栈顶。</p><p>当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中 pop 出，上下文控制权会交到当前执行栈的下一个执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside Global Exection Context&#x27;</span>)<br><span class="hljs-comment">// Inside first function</span><br><span class="hljs-comment">// Inside second function</span><br><span class="hljs-comment">// Again inside first function</span><br><span class="hljs-comment">// Inside Global Execution Context</span><br></code></pre></td></tr></table></figure><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/stack.png" alt="image.png"></p><h1 id="JavaScript-中的执行上下文栈和变量对象"><a href="#JavaScript-中的执行上下文栈和变量对象" class="headerlink" title="JavaScript 中的执行上下文栈和变量对象"></a>JavaScript 中的执行上下文栈和变量对象</h1><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>JS 引擎创建了很多的执行上下文，所以 JS 引擎创建了<strong>执行上下文栈</strong>（Execution context stack，ECS）来<strong>管理</strong>执行上下文。</p><p>当 JavaScript 初始化的时候会向执行上下文栈压入一个<strong>全局执行上下文</strong>，可以用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前，执行栈最底部永远有个 globalContext。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span> = [ <span class="hljs-comment">// 使用数组模拟栈</span><br>  globalContext<br>];<br></code></pre></td></tr></table></figure><p>demo1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> scope;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br></code></pre></td></tr></table></figure><p>demo2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> scope;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure><p>demo1 的执行上下文栈的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure><p>deno2 的执行上下文栈的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;checkscope&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">push</span>(&lt;f&gt; functionContext);<br><span class="hljs-title class_">ECStack</span>.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，用活动对象（activation object，AO）来表示变量对象</p><p>活动对象和变量对象的区别在于</p><ul><li>变量对象（VO）是规范上或者是 JS 引擎上实现的，并不能在 JS 环境中直接访问。</li><li>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。</li></ul><p>调用函数时，会为其创建一个 <strong>Arguments 对象</strong>，并且自动初始化局部变量 arguments，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象数组元素。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ul><li>进入执行上下文</li><li>代码执行</li></ul><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li>函数所有形参（函数上下文）：没有实参，属性值设为 undefined。</li><li>函数声明：如果变量对象已经存在相同名称的属性，则完全<strong>替换</strong>这个属性。</li><li>变量声明：如果变量名称和已经声明的形成或函数相同，则变量声明不会干扰已经存在的这类属性。</li></ul><p>demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-title function_">funcion</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>  b = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>此时的 AO：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">AO</span> = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>形参 arguments 这时候已经有赋值了，但是变量还是 undefined，只是初始化的值</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">AO</span> = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">d</span>: reference to <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>全局上下文的变量对象初始化时全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象<strong>添加形参、函数声明、变量声明</strong>等初始的属性</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ul><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>调用位置就是函数在代码中<strong>被调用的位置</strong>（而不是声明的位置）。</p><p>查找方法：</p><ul><li><p>分析调用栈：调用位置就是当前正在执行的函数的<strong>前一个调用</strong>中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz</span><br>    <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;baz&quot;</span> );<br>    <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar的调用位置</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz --&gt; bar</span><br>    <span class="hljs-comment">// 因此，当前调用位置在baz中</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;bar&quot;</span> );<br>    <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo的调用位置</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span><br>    <span class="hljs-comment">// 因此，当前调用位置在bar中</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> );<br>&#125;<br><br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz的调用位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用开发者工具得到调用栈：<br>设置断点或者插入<code>debugger;</code>语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是<strong>调用栈</strong>。找到栈中的<strong>第二个元素</strong>，这就是真正的调用位置。</p></li></ul><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul><li><strong>独立函数调用</strong>，无法应用其他规则时的默认规则，this 指向<strong>全局对象</strong>。</li><li><strong>严格模式</strong>下，不能将全局对象用于默认绑定，this 会绑定到 <code>undefined</code>。只有函数<strong>运行</strong>在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下<strong>调用</strong>函数则不影响默绑定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 运行在严格模式下，this会绑定到undefined</span><br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 调用</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span><br><br><span class="hljs-comment">// --------------------------------------</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 运行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 严格模式下调用函数则不影响默认绑定</span><br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>当函数引用有<strong>上下文对象</strong>时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><blockquote><p>隐式丢失</p></blockquote><p>被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span><br><span class="hljs-comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a是全局对象的属性</span><br><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">// fn其实引用的是foo</span><br>    <br>    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a是全局对象的属性</span><br><br><span class="hljs-title function_">doFoo</span>( obj.<span class="hljs-property">foo</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br><br><span class="hljs-comment">// ----------------------------------------</span><br><br><span class="hljs-comment">// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-comment">// 等待delay毫秒</span><br>    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>通过<code>call()</code>或者<code>apply()</code>方法。一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2  调用foo时强制把foo的this绑定到obj上</span><br></code></pre></td></tr></table></figure><p>显示绑定无法解决丢失绑定问题</p><p>解决方案：</p><ul><li>硬绑定</li></ul><p> 创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>foo.<span class="hljs-title function_">call</span>(obj)<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this</span><br></code></pre></td></tr></table></figure><p>应用场景：创建一个包裹函数，负责接收参数并返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p> 创建一个可以重复使用的辅助函数。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something );<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>( foo, obj );<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p> ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something );<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj );<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li>API 调用的”上下文“</li></ul><p> JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。<br>例如：forEach</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">// 调用foo(..)时把this绑定到obj</span><br>myArray.<span class="hljs-title function_">forEach</span>( foo, obj );<br><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span><br></code></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><ul><li>JS 中 <code>构造函数</code>只是使用 <code>new</code>操作符时被调用的<code>普通</code>函数</li><li>包括内置对象函数（比如<code>String(...)</code>）在内的所有函数都可以用<code>new</code>来调用，这种函数调用被称为构造函数调用</li><li>实际上不存在<code>构造函数</code>，只存在<code>对函数的构造调用</code></li></ul><h4 id="new-发生了什么"><a href="#new-发生了什么" class="headerlink" title="new 发生了什么"></a>new 发生了什么</h4><ul><li>创建（或者说构造）一个新对象</li><li>这个新对象会被执行<code>[[Prototype]]</code>连接</li><li>这个新对象会绑定到函数调用的<code>this</code></li><li>如果这个函数没有返回其他的对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 粗糙版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 创建一个空对象</span><br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-comment">// 获得构造函数 arguments 中第一个参数（即构造函数）</span><br>  <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 链接到原型， obj 可以访问到构造函数中的属性</span><br>  obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Con</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 优先返回构造函数返回的对象</span><br>  <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? ret : obj;<br>&#125;<br><span class="hljs-comment">// 精简版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">__new</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-keyword">const</span> ret = fn.<span class="hljs-title function_">apply</span>(obj, args);<br>  <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? ret : obj;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h3><p>以上四种都是<strong>this总是指向调用该函数的对象</strong></p><p>但是箭头函数是根据外层（函数或者全局）作用域（<strong>词法作用域</strong>）来决定this。<br>对于箭头函数的this总结如下：</p><ol><li>箭头函数不绑定this，箭头函数中的this相当于普通变量。</li><li>箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。</li><li>箭头函数的this<strong>无法通过bind，call，apply来直接修改</strong>（可以间接修改）。</li><li>改变作用域中this的指向可以改变箭头函数的this。</li><li><code>eg. function closure()&#123;()=&gt;&#123;//code &#125;&#125;</code>，在此例中，我们通过改变封包环境<code>closure.bind(another)()</code>，来改变箭头函数this的指向。</li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的内存空间"><a href="#JavaScript-的内存空间" class="headerlink" title="JavaScript 的内存空间"></a>JavaScript 的内存空间</h1><p>调用堆栈溢出：</p><p>调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.png" alt="image.png"></p><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈的结构就是后进先出（LIFO）</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.png" alt="image.png"></p><h2 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h2><p>堆数据结构是一种树状结构。它是以 <code>key-value</code> 的形式存取数据的，是无序的，只需要知道 <code>key</code> ，就可以取出 <code>value</code></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）的数据结构，是事件循环（Event Loop）的基础结构</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.png" alt="image.png"></p><h2 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h2><ul><li>基本数据类型：存放在<strong>栈</strong>内存中<strong>（不包含闭包中的变量）</strong>，因为这些类型在内存中分别占有固定大小的空间，通过<strong>按值访问</strong>。基本数据类型一共有 6 种：Undefined、Null、Bolleam、Number、String 和 Symbol</li><li>引用数据类型：<strong>值</strong>存放在<strong>堆</strong>内存中，因为这些类型所占的空间不确定，但是对应的<strong>引用地址</strong>存放在<strong>栈</strong>内存中。当查询引用类型的变量时，先从<strong>栈中读取相应的引用地址</strong>，然后再通过地址<strong>找到堆中对应的值</strong>，这种叫做<strong>按引用访问</strong>。</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.png" alt="image.png"></p><p>栈比堆的运算速度快，Object 是一个复杂结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将它们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中实际对象再进行操作。</p><h2 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h2><p>JavaScript 的内存生命周期：</p><ul><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放、归还</li></ul><p>JavaScript 有自动垃圾回收机制，最常用的是通过<strong>标记清除</strong>的算法来找到不再继续使用的对象，使用 <code>obj = null</code> 其实仅仅只是做了一个释放引用的操作，让 obj 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并且释放。</p><p>在函数作用域中，当函数执行完毕，函数作用域中的变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局的变量什么时候需要自动释放内存空间则很难判断，因此在开发中，尽量避免使用全局变量。</p><p>demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> b = a;<br>a.<span class="hljs-property">x</span> = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">x</span>)  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">x</span>)  <span class="hljs-comment">// &#123;n: 2&#125;</span><br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>优先级<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>&#123;n:1&#125;</code>就会变成<code>&#123;n: 1, x: undefined&#125;</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li><li>赋值操作是<code>从右到左</code>，所以先执行<code>a = &#123;n: 2&#125;</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，<strong>需要注意</strong>此时的<code>a.x</code>是第一步中的<code>&#123;n: 1, x: undefined&#125;</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = &#123;n:2&#125;</code></li></ul><h1 id="JavaScript-的内存机制"><a href="#JavaScript-的内存机制" class="headerlink" title="JavaScript 的内存机制"></a>JavaScript 的内存机制</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>:::info<br>对垃圾回收来说，核心思想就是如何判断对象已经不再具有<code>可达性</code>。<br>:::<br>JavaScript 有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值（不具有<code>可达性</code>的对象），然后释放其占用的内存。</p><ul><li>变量的销毁 <ul><li><strong>局部变量：</strong>局部作用域中，当函数执行完毕，局部变量就被垃圾收集器回收</li><li><strong>全局变量：</strong>全局变量什么时候需要自动释放内存空间很难判断，所以要尽量<strong>避免</strong>使用全局变量</li></ul></li><li>V8 引擎中所有的 JS 对象都是通过<strong>堆</strong>来进行内存分配的 <ul><li><strong>初始分配：</strong>当声明变量并赋值时，V8 引擎就会在堆内存中分配给这个变量。</li><li><strong>继续申请：</strong>当已申请的内存不足以存储这个变量时，V8 引擎就会继续申请内存，直到堆的大小达到了 V8 引擎的内存上限为止。</li></ul></li><li>V8 引擎对堆内存中的 JS 对象进行 <strong>分代管理</strong> <ul><li><strong>新生代：</strong>存活周期较短的 JS 对象，如临时变量、字符串等。</li><li><strong>老生代：</strong>经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul></li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>常用垃圾回收算法有下面两种。</p><ul><li>引用计数（现代浏览器不再使用）</li><li>标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>看一个对象是否有指向它的<strong>引用</strong>。如果没有其他对象指向它了，说明该对象需要被回收了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个对象 person，它有两个指向属性 age 和 name 的引用</span><br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bob&#x27;</span><br>&#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 虽然 name 设置为 null，但因为 person 对象还有指向 name 的引用，因此 name 不会被回收</span><br><span class="hljs-keyword">var</span> p = person;<br>person = <span class="hljs-number">1</span>; <span class="hljs-comment">// 原来的 person 对象被赋值为1，但因为有新引用 p 指向原 person 对象，因此它不会被回收</span><br>p = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 原 person 对象已经没有引用，很快会被回收</span><br></code></pre></td></tr></table></figure><h5 id="引用计数致命缺点-循环引用"><a href="#引用计数致命缺点-循环引用" class="headerlink" title="引用计数致命缺点-循环引用"></a>引用计数致命缺点-循环引用</h5><p>如果两个对象相互引用，尽管它们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cycle</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br>  <span class="hljs-keyword">var</span> o2 = &#123;&#125;;<br>  o1.<span class="hljs-property">a</span> = o2;<br>  o2.<span class="hljs-property">a</span> = o1;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cycle reference!&quot;</span><br>&#125;<br><span class="hljs-title function_">cycle</span>();<br></code></pre></td></tr></table></figure><p><code>cycle</code>函数执行完成之后，对象<code>o1</code>和<code>o2</code>实际上已经不再需要了，但根据引用计数的原则，它们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器<strong>不再使用</strong>这个垃圾回收算法。</p><p>但是 IE 依旧使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>div.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;click&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>变量 div 有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为<strong>“无法到达的对象”（不具有可达性的对象）</strong>。即从根部（全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象就认为<strong>此对象具有可达性，保留</strong>；那些从根部出发无法到达的对象就被标记为<strong>此对象不具有可达性</strong>，稍后进行回收。</p><p>无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。</p><p>所以上面的例子就可以正确被垃圾回收处理了。</p><p>所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">email.<span class="hljs-property">message</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>)<br>displayList.<span class="hljs-title function_">appendChild</span>(email.<span class="hljs-property">message</span>)<br><span class="hljs-comment">// 稍后从 displayList 中清除 DOM 元素</span><br>displayList.<span class="hljs-title function_">removeAllChildren</span>();<br></code></pre></td></tr></table></figure><p>上面代码中，<code>div</code>元素已经从DOM树中清除，但是该<code>div</code>元素还绑定在email对象中，所以如果email对象存在，那么该<code>div</code>元素就会一直保存在内存中。<br><strong>缺点：</strong></p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块， 还可能会出现分配所需内存过大的对象时找不到合适的块</li></ul><h4 id="标记整理（有效解决内存碎片化）"><a href="#标记整理（有效解决内存碎片化）" class="headerlink" title="标记整理（有效解决内存碎片化）"></a>标记整理（有效解决内存碎片化）</h4><p> 它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.png" alt="image.png"></p><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><ul><li><strong>新生代：</strong>存活周期较短的 JS 对象，如临时变量、字符串等。（1-8M）</li><li><strong>老生代：</strong>经过新生代垃圾回收后还存活下的对象，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><p>内存分代管理图<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/06.png" alt="image.png"><br> 对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控  </p><h4 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h4><p>通过<code>Scavenge</code>的算法进行垃圾回收，主要采用其中的<code>Cheney</code>算法<br><code>Cheney算法</code>中将堆内存分成：处于使用状态的空间（使用区），处于闲置状态的空间（空闲区）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/07.png" alt="image.png"><br>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作  </p><p>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段（将非活动对象占用的空间清理掉）。最后把原来的使用区和空闲区互换。<br><strong>情况一：</strong><br>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理  。<br><strong>情况二：</strong><br>如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配  </p><h4 id="老生代垃圾回收"><a href="#老生代垃圾回收" class="headerlink" title="老生代垃圾回收"></a>老生代垃圾回收</h4><ul><li>垃圾收集器创建一个“<strong>roots</strong>”列表。<strong>roots</strong>通常是代码中全局变量的引用。在浏览器中 <strong>window</strong> 对象就被当作是 <strong>root</strong>。<strong>window</strong>对象总是存在的，因此垃圾收集器可以检查它和它的所有子对象是否存在（即是不是垃圾，需不需要回收）。</li><li>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是<strong>可达</strong>的，它就不被当作垃圾。</li><li>所有未被标记的内存会被当作垃圾，垃圾收集器现在可以释放内存，归还给操作系统了。</li></ul><h3 id="并行回收（Parallel）"><a href="#并行回收（Parallel）" class="headerlink" title="并行回收（Parallel）"></a>并行回收（Parallel）</h3><p>因为 <code>JavaScript</code>是一门单线程的语言，并且垃圾回收是运行在主线程上的，在进行垃圾回收时会阻塞<code>JavaScript</code>脚本执行，需要等待垃圾回收完毕后再恢复脚本执行（<code>全停顿标记</code>）。<br>比如一次<code>GC</code>要 60ms，那么 JS 脚本执行就需要等待 60ms，如果一次 <code>GC</code>的时间过长，用户会觉得页面卡顿。<br><code>V8</code>提出了并行<code>GC</code>机制，引入多个辅助线程来执行<code>GC</code>：<br><code>GC</code>再主线程执行的过程中，开启多个辅助线程，同事执行同样的回收工作。<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/08.png" alt="image.png"><br>如图：本来一个线程的的事情交给三个线程来做，大大加速了<code>GC</code>， 对于新生代垃圾回收器能够有很好的优化  </p><h3 id="增量标记与惰性清理"><a href="#增量标记与惰性清理" class="headerlink" title="增量标记与惰性清理"></a>增量标记与惰性清理</h3><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>把一次<code>GC</code>的过程分成很多小步，每执行完一步就让 JS 主线程执行一会儿， 这样交替多次后完成一轮 GC 标记（如下图）<br><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/09.png" alt="image.png"></p><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p><code>V8</code>通过三色标记法来实现增量标记，实现 <code>JS</code> 主线程和 <code>GC</code> 线程的交替执行<br> 三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑 </p><ul><li>白色指的是未被标记的对象</li><li>灰色指自身被标记，成员变量（该对象的引用对象）未被标记</li><li>黑色指自身和成员变量皆被标记</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png" alt="image.png"><br>最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色。就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）<br>可以<strong>直接通过当前内存中有没有灰色节点来判断整个标记是否完成</strong>，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以<br>三色标记法的标记操作是可以渐进执行的而不需要每次都扫描整个内存空间， 可以很好的配合增量回收进行暂停恢复的一些操作，从而减少<code>全停顿</code>的时间  </p><h4 id="惰性清理"><a href="#惰性清理" class="headerlink" title="惰性清理"></a>惰性清理</h4><p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以快速的执行代码，此时是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h2 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h2><h3 id="浏览器方法"><a href="#浏览器方法" class="headerlink" title="浏览器方法"></a>浏览器方法</h3><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的 Select profiling type 字段里面勾选 timeline</li><li>点击左上角的录制按钮。</li><li>在页面进行各种操作，模拟用户的使用情况。</li><li>在一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol><h3 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h3><p>使用 <code>Node</code> 提供的 <code>process.memoryUsage</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">memoryUsage</span>());<br><span class="hljs-comment">// 输出</span><br>&#123;<br>  <span class="hljs-attr">rss</span>: <span class="hljs-number">27709440</span>,<span class="hljs-comment">// resident set size，所有内存占用，包括指令区和堆栈</span><br>  <span class="hljs-attr">heapTotal</span>: <span class="hljs-number">5685248</span>,   <span class="hljs-comment">// &quot;堆&quot;占用的内存，包括用到的和没用到的</span><br>  <span class="hljs-attr">heapUsed</span>: <span class="hljs-number">3449392</span>,<span class="hljs-comment">// 用到的堆的部分</span><br>  <span class="hljs-attr">external</span>: <span class="hljs-number">8772</span> <span class="hljs-comment">// V8 引擎内部的 C++ 对象占用的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断内存泄漏，以<code>heapUsed</code>字段为准。</p><h2 id="WeakMap-WeakSet"><a href="#WeakMap-WeakSet" class="headerlink" title="WeakMap WeakSet"></a>WeakMap WeakSet</h2><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的；因此，只要所引用的对象的其他引用被清除，垃圾回收机制就会释放该对象所占用的内存，不再需要手动删除引用。</p><p>demo1：没用 WeakMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> e1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">const</span> e2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-keyword">const</span> arr = [<br>  [e1, <span class="hljs-string">&#x27;foo 元素&#x27;</span>],<br>  [e2, <span class="hljs-string">&#x27;bar 元素&#x27;</span>],<br>];<br></code></pre></td></tr></table></figure><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不需要 e1 和 e2 的时候</span><br><span class="hljs-comment">// 必须手动删除引用</span><br>arr [<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br>arr [<span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><strong>一旦忘了手动删除引用，就会造成内存泄漏</strong>。</p><p>demo2：用了 WeakMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>);<br><br>wm.<span class="hljs-title function_">set</span>(element, <span class="hljs-string">&#x27;some information&#x27;</span>);<br>wm.<span class="hljs-title function_">get</span>(element) <span class="hljs-comment">// &quot;some information&quot;</span><br></code></pre></td></tr></table></figure><p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。<strong>不需要手动删除引用</strong>。</p><h2 id="javaScript-四类常见的内存泄漏及如何避免"><a href="#javaScript-四类常见的内存泄漏及如何避免" class="headerlink" title="javaScript 四类常见的内存泄漏及如何避免"></a>javaScript 四类常见的内存泄漏及如何避免</h2><h3 id="四类常见的-JS-内存泄漏"><a href="#四类常见的-JS-内存泄漏" class="headerlink" title="四类常见的 JS 内存泄漏"></a>四类常见的 JS 内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg</span>) &#123;<br>  bar = <span class="hljs-string">&quot;this is a hidden global variable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>foo</code> 内部忘记使用 <code>var</code> ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&quot;this is an explicit global variable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个意外的全局变量可能由 <code>this</code> 创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">varible</span> = <span class="hljs-string">&quot;potential accidental global&quot;</span>;<br>&#125;<br><span class="hljs-comment">// Foo 调用自己，this 指向了全局对象（window）</span><br><span class="hljs-comment">// 而不是 undefined</span><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，使用严格模式避免意外的全局变量，此时<strong>上例中的this指向</strong><code>**undefined**</code>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> someResource = <span class="hljs-title function_">getData</span>();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;Node&#x27;</span>);<br>  <span class="hljs-keyword">if</span>(node) &#123;<br>    <span class="hljs-comment">// 处理 node 和 someResource</span><br>    node.<span class="hljs-property">innerHTML</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(someResource)<br>  &#125;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。</p><p><strong>但是</strong>，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 <code>removeEventListener</code> 了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> elements = &#123;<br>    <span class="hljs-attr">button</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>),<br>    <span class="hljs-attr">image</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;image&#x27;</span>),<br>    <span class="hljs-attr">text</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>)<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStuff</span>(<span class="hljs-params"></span>) &#123;<br>    image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://some.url/image&#x27;</span>;<br>    button.<span class="hljs-title function_">click</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-property">innerHTML</span>);<br>    <span class="hljs-comment">// 更多逻辑</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeButton</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 按钮是 body 的后代元素</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>));<br>    <span class="hljs-comment">// 此时，仍旧存在一个全局的 #button 的引用</span><br>    <span class="hljs-comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果代码中保存了表格某一个 <code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <code>&lt;td&gt;</code> 以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码<strong>保留了 <strong><code>**&lt;td&gt;**</code></strong> 的引用</strong>，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键在于匿名函数可以访问父级作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> replaceThing = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> originalThing = theThing;<br>  <span class="hljs-keyword">var</span> unused = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (originalThing)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>    <br>  theThing = &#123;<br>    <span class="hljs-attr">longStr</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;*&#x27;</span>),<br>    <span class="hljs-attr">someMethod</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(someMessage);<br>    &#125;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-built_in">setInterval</span>(replaceThing, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>每次调用 <code>replaceThing</code> ，<code>theThing</code> 得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量 <code>unused</code> 是一个引用 <code>originalThing</code> 的闭包（先前的 <code>replaceThing</code> 又调用了 <code>theThing</code> ）。<code>someMethod</code> 可以通过 <code>theThing</code> 使用，<code>someMethod</code> 与 <code>unused</code> 分享闭包作用域，尽管 <code>unused</code> 从未使用，它引用的 <code>originalThing</code> 迫使它保留在内存中（防止被回收）。</p><p><strong>解决方法</strong>：</p><p>在 <code>replaceThing</code> 的最后添加 <code>originalThing = null</code> 。</p><h3 id="从内存的角度来看-null-和-undefined-本质的区别是什么？"><a href="#从内存的角度来看-null-和-undefined-本质的区别是什么？" class="headerlink" title="从内存的角度来看 null 和 undefined 本质的区别是什么？"></a>从内存的角度来看 null 和 undefined 本质的区别是什么？</h3><p>给一个全局变量赋值为 null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性赋值为 null，或者局部变量赋值为 null，相当于给这个属性分配了一块空的内存，然后值为 null，JS 回收全局变量为 null 的对象。</p><p>给一个全局变量赋值为 undefined，相当于将这个对象的值清空，但是这个对象依旧存在，如果是给对象的属性赋值为 undefined，说明这个值为空值。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链和闭包</title>
    <link href="/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <url>/2023/04/28/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>执行上下文定义了变量或者函数访问其他数据的权限，和它们各自的行为。每个执行上下文环境都有有一个与之关联的当前活动对象（AO），环境中定义的所有变量和函数都保存在这个对象中。</p><p><strong>作用域链：</strong>当访问一个变量时，JS 解释器会首先在当前上下文中的变量对象查找标识符，如果没有找到，就去父级（词法层面上的父级）执行上下文中的变量对象中查找，一直找到全局上下文中的变量对象（全局对象），这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p><strong>作用域链和原型链查找的区别：</strong>如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 <strong>undefined</strong>；但查找的属性在作用域链中不存在的话就会抛出 <strong>ReferenceError</strong>。</p><p>作用域链的顶端是全局对象，在全局环境中定义的变量就会绑定到全局对象中。</p><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><h3 id="无嵌套的函数"><a href="#无嵌套的函数" class="headerlink" title="无嵌套的函数"></a>无嵌套的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// my_script.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) &#123;<br>  <br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">3</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inside myFunc&quot;</span>);<br>  <br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br><span class="hljs-title function_">myFunc</span>();<br></code></pre></td></tr></table></figure><p>定义时：当 myFunc 被定义的时候，myFunc 的标识符（identifier）就被加到了全局对象中，这个标识符所引用的是一个函数对象（myFunc function object）。</p><p>内部属性<code>[[scope]]</code>指向当前的作用域对象，也就是函数的标识符被创建的时候，我们所能够直接访问的那个作用域对象（即全局对象）。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/01.png" alt="image.png"></p><p>myFunc 所引用的函数对象，其实本身不仅仅含有函数的代码，并且还含有指向其被创建的时候的作用域对象。</p><p><strong>调用时：</strong>当 myFunc 函数被调用的时候，一个新的作用域对象（执行上下文中的变量对象）被创建了。新的作用域对象中包含 myFunc 函数所定义的本地变量，以及其参数（arguments）。这个新的作用域对象的父作用域对象就是运行 myFunc 时能够直接访问的那个作用域对象（即全局对象）。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/02.png" alt="image.png"></p><h3 id="有嵌套的函数"><a href="#有嵌套的函数" class="headerlink" title="有嵌套的函数"></a>有嵌套的函数</h3><p>当函数返回没有被引用的时候，就会被垃圾收集器回收。但是对于闭包，即使外部函数返回了，函数对象仍会引用它被<strong>创建时</strong>的作用域对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-keyword">var</span> counter = initial;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">value</span>) &#123;<br>    counter += value;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">get</span>: get<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> myCounter = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 100</span><br><br>myCounter.<span class="hljs-title function_">increment</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCounter.<span class="hljs-title function_">get</span>());   <span class="hljs-comment">// 返回 105</span><br></code></pre></td></tr></table></figure><p>当调用 createCounter(100) 时，内嵌函数increment和get都有指向createCounter(100) scope的引用。<strong>假设</strong>createCounter(100)没有任何返回值，那么createCounter(100) scope不再被引用，于是就可以被垃圾回收。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/03.png" alt="image.png"></p><p>但是 createCounter(100) 实际上是有返回值的，并且返回值被存储在了 myCounter 中，所以对象之间的引用关系如下图：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/04.png" alt="image.png"></p><p>即使createCounter(100)已经返回，但是其作用域仍在，并且只能被内联函数访问。可以通过调用myCounter.increment() 或 myCounter.get()来直接访问createCounter(100)的作用域。</p><p>当myCounter.increment() 或 myCounter.get()被调用时，新的作用域对象会被创建，并且该作用域对象的父作用域对象会是当前可以直接访问的作用域对象。</p><p>调用<code>get()</code>时，当执行到<code>return counter</code>时，在get()所在的作用域并没有找到对应的标示符，就会沿着作用域链往上找，直到找到变量<code>counter</code>，然后返回该变量。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/05.png" alt="image.png"></p><p>单独调用increment(5)时，参数value保存在当前的作用域对象。当函数要访问counter时，没有找到，于是沿着作用域链向上查找，在createCounter(100)的作用域找到了对应的标示符，increment()就会修改counter的值。除此之外，没有其他方式来修改这个变量。闭包的强大也在于此，能够存贮私有数据。</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/06.png" alt="image.png"></p><p>创建两个函数：<code>myCounter1</code>和<code>myCounter2</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//my_script.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">initial</span>) &#123;<br>  <span class="hljs-comment">/* ... see the code from previous example ... */</span><br>&#125;<br><br><span class="hljs-comment">//-- create counter objects</span><br><span class="hljs-keyword">var</span> myCounter1 = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">var</span> myCounter2 = <span class="hljs-title function_">createCounter</span>(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>关系图如下：</p><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/07.png" alt="image.png"></p><p>myCounter1.increment和myCounter2.increment的函数对象拥有着一样的代码以及一样的属性值（name，length等等），但是它们的[[scope]]指向的是不一样的作用域对象。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的定义：<code>有权访问另一个函数作用域中的变量的函数</code></p><ul><li>是一个函数（比如，内部函数从父函数中返回）</li><li>能够访问另一个函数作用域中的变量（哪怕上级函数上下文已经销毁）</li></ul><p>简单概括：<strong>本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。</strong></p><p>这也是闭包保存的自由变量（即使是原始类型）存放在堆内存里面的原因</p><p><strong>闭包的三个特性：</strong></p><ul><li><p>闭包可以访问当前函数以外的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOuter</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bob&#x27;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str + name) <span class="hljs-comment">// 访问外部的 name</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getName</span>(<span class="hljs-string">&#x27;名字是：&#x27;</span>) <span class="hljs-comment">// &quot;名字是：bob&quot;</span><br>&#125;<br><span class="hljs-title function_">getOuter</span>();<br></code></pre></td></tr></table></figure></li><li><p>即使外部函数已经返回，闭包仍然能访问外部函数定义的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOuter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bob&#x27;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str + name) <span class="hljs-comment">// 访问外部的 name</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> getName; <span class="hljs-comment">// 外部函数返回</span><br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getOuter</span>();<br><span class="hljs-title function_">today</span>(<span class="hljs-string">&#x27;名字是：&#x27;</span>); <span class="hljs-comment">// &quot;名字是：bob&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>闭包可以更新外部变量的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateCount</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCount</span>(<span class="hljs-params">val</span>) &#123;<br>    count = val;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;<br>  <span class="hljs-keyword">return</span> getCount; <span class="hljs-comment">// 外部函数返回</span><br>&#125;<br><span class="hljs-keyword">var</span> count = <span class="hljs-title function_">updateCount</span>()<br><span class="hljs-title function_">count</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123</span><br><span class="hljs-title function_">count</span>(<span class="hljs-number">1234</span>) <span class="hljs-comment">// 1234</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="结合作用域链分析闭包"><a href="#结合作用域链分析闭包" class="headerlink" title="结合作用域链分析闭包"></a>结合作用域链分析闭包</h2><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> scope;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-title function_">checkscope</span>(); <span class="hljs-comment">// foo 指向函数f</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 调用函数f()</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><ul><li>进入全局代码，创建全局执行上下文，全局执行上下文<strong>压入执行上下文栈</strong></li><li>全局执行<strong>上下文初始化</strong></li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行山下文被压入执行上下文栈</li><li>f 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈弹出</li></ul><p><img src="/img/web%E5%89%8D%E7%AB%AF/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/08.png" alt="image.png"></p><p>函数 f 执行上下文维护了一个作用域链，会指向<code>checkscope</code>作用域，作用域链是一个数组，结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fContext = &#123;<br>  <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>, checkscopeContext.<span class="hljs-property">AO</span>, globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>指向关系是：当前作用域 –&gt; <code>checkscope</code>作用域–&gt;全局作用域</p><p>即使 checkscopeContext 被销毁了，但是 Javascript 依然会让 checkscopeContext.AO（活动对象）活在内存中，f 函数依然可以通过自身的作用域链找到它，<strong>这就是闭包实现的关键</strong></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器与js</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器与JS"><a href="#浏览器与JS" class="headerlink" title="浏览器与JS"></a>浏览器与JS</h1><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p>进程是 cpu 资源分配的最小单位（系统会给他分配内存），进程之间相互独立（也可以相互通信，但是代价很大）。</p><p>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程），线程之间有共享空间。</p><p>区别：</p><ol><li>每启动一个进程，这个进程至少得有一个线程。</li><li>进程本身只是一个资源单位，并不是真正执行，进程内的线程才是执行单位。</li><li>一个进程内可以有多个线程，进程在内存中相互隔离，而同一个进程内的线程是共享资源的，各线程之间地位平等。</li><li>进程更消耗资源，而线程开销小，是在已有的进程内占用。</li></ol><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2><h3 id="1-包含以下主要进程"><a href="#1-包含以下主要进程" class="headerlink" title="1.包含以下主要进程"></a>1.包含以下主要进程</h3><ol><li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个，作用有： <ul><li>负责浏览器的界面展示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将 Render 进程得到的内存中的 Bitmap ，绘制到到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程：每个类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D 绘制等</li><li>浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每一个 Tab 页面一个进程，互不影响。主要作用 <ul><li>页面渲染，脚本执行，事件处理等等</li></ul></li></ol><p>在浏览器打开一个网页，就相当于新启了一个进程（可以通过Chrome的更多工具-》任务管理器自行验证）</p><h3 id="2-浏览器多进程的优势"><a href="#2-浏览器多进程的优势" class="headerlink" title="2.浏览器多进程的优势"></a>2.浏览器多进程的优势</h3><ul><li>避免单个 page crash 影响整个浏览器 </li><li>避免第三方插件 crash 影响整个浏览器 </li><li>多进程充分利用多核优势 </li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<br>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></li></ul><h3 id="3-浏览器内核（渲染进程）"><a href="#3-浏览器内核（渲染进程）" class="headerlink" title="3.浏览器内核（渲染进程）"></a>3.浏览器内核（渲染进程）</h3><p>渲染进程是多线程的，常驻线程如下：</p><ol><li>GUI 渲染线程</li></ol><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行</li><li>GUI渲染进程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><ol start="2"><li>JS引擎线程</li></ol><ul><li>也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>GUI渲染进程和JS引擎线程是互斥的，如果JS执行的时间过长，就会阻塞页面的渲染。</li></ul><ol start="3"><li>事件触发线程</li></ol><ul><li>归属于浏览器而不是JS引擎，用来控制四件循环（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>注意，由于JS的单线程的关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲的时候才会去执行）</li></ul><ol start="4"><li>定时器触发线程</li></ol><ul><li>setInterval 与 setTimeout 所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的（因为Javascript引擎时单线程的，如果处于阻塞线程状态就会影响定时计数器的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li></ul><ol start="5"><li>异步http请求线程</li></ol><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由Javascript引擎执行。</li></ul><p><strong>浏览器内核</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/core.png" alt="image.png"></p><h3 id="4-Browser进程和浏览器内核（Render进程）的通信过程"><a href="#4-Browser进程和浏览器内核（Render进程）的通信过程" class="headerlink" title="4.Browser进程和浏览器内核（Render进程）的通信过程"></a>4.Browser进程和浏览器内核（Render进程）的通信过程</h3><ul><li>Browser 进程收到了用户请求，首先需要获取页面内容（通过网络下载资源），随后将该任务通过RenderHost接口传递给Render进程</li><li>Render进程的Render接口收到消息，简单解释后，交给渲染线程（Render），然后开始渲染 <ul><li>渲染线程（Render）接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM</li><li>最后 Render 进程将结果传递给Browser进程</li></ul></li><li>Browser进程接收到结果并将结果绘制出来</li></ul><h3 id="5-WebWorker"><a href="#5-WebWorker" class="headerlink" title="5.WebWorker"></a>5.WebWorker</h3><p>HTML5 支持了 Web Worker</p><p>MDN 解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Web</span> <span class="hljs-title class_">Worker</span>为<span class="hljs-title class_">Web</span>内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面<br><br>一个worker是使用一个构造函数创建的一个对象(e.<span class="hljs-property">g</span>. <span class="hljs-title class_">Worker</span>()) 运行一个命名的<span class="hljs-title class_">JavaScript</span>文件 <br><br>这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的<span class="hljs-variable language_">window</span><br><br>因此，使用 <span class="hljs-variable language_">window</span>快捷方式获取当前全局的范围 (而不是self) 在一个 <span class="hljs-title class_">Worker</span> 内将返回错误<br></code></pre></td></tr></table></figure><ul><li>创建 Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与主线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，单独开一个Worker线程，这样里面不管如何翻天覆地都不影响JS引擎主线程，只等计算出结果后，将结果通信给主线程即可。</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="6-WebWorker-与-SharedWorker"><a href="#6-WebWorker-与-SharedWorker" class="headerlink" title="6.WebWorker 与 SharedWorker"></a>6.WebWorker 与 SharedWorker</h3><ul><li>WebWorker只属于某个页面，不会和其他页面的Renderer进程共享 <ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li><li>SharedWorker是浏览器所有页面共享，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 <ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul><p>SharedWorker由独立的进程管理，WebWorker只属于render进程下的一个线程</p><h3 id="7-浏览器渲染进程"><a href="#7-浏览器渲染进程" class="headerlink" title="7.浏览器渲染进程"></a>7.浏览器渲染进程</h3><ul><li>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</li><li>浏览器渲染流程开始</li></ul><p>渲染：</p><ol><li>解析html建立dom树</li><li>解析css构建 render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>渲染完成之后就是 load 事件</p><h4 id="1-load事件与DOMContentLoaded事件的先后"><a href="#1-load事件与DOMContentLoaded事件的先后" class="headerlink" title="1.load事件与DOMContentLoaded事件的先后"></a>1.load事件与DOMContentLoaded事件的先后</h4><ul><li>当 DOMContentLoaded 事件出发时，仅当DOM加载完成，不包括样式表，图片。（例如如果有async加载的脚本就不一定完成）</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><p>DOMContentLoaded -&gt; load</p><h4 id="2-css加载是否会阻塞dom树渲染"><a href="#2-css加载是否会阻塞dom树渲染" class="headerlink" title="2.css加载是否会阻塞dom树渲染"></a>2.css加载是否会阻塞dom树渲染</h4><p>此处说的是头部引入css的情况下</p><p>css是由单独的下载线程异步下载的。</p><ul><li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li><li>但会阻塞render树渲染（渲染时需等待css加载完毕，因为render树需要css信息）</li></ul><p>因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h4 id="3-普通图层和复合图层"><a href="#3-普通图层和复合图层" class="headerlink" title="3.普通图层和复合图层"></a>3.普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p><ul><li>普通文档流内可以理解为一个复合图层（这里称为默认复合图层，里面不管添加多少元素，其实都是在同一个复合图层中）</li><li>absolute布局和flex布局，虽然脱离普通文档流，但是仍然属于默认复合层。</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合图层中的回流重绘）</li></ul><p>GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p><h5 id="1-如何变成复合图层（硬件加速）"><a href="#1-如何变成复合图层（硬件加速）" class="headerlink" title="1.如何变成复合图层（硬件加速）"></a>1.如何变成复合图层（硬件加速）</h5><p>将该元素变成一个复合图层，就是硬件加速技术</p><ul><li><p>最常用的方式：translate3d、translateZ </p></li><li><p>opacity 属性&#x2F;过渡动画（需要动画执行过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） </p></li><li><p>will-chang属性，一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）。<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） </p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">webgl</span>&gt;</span>等元素<br></code></pre></td></tr></table></figure></li><li><p>其它，譬如以前的flash插件</p></li></ul><h5 id="2-absolute和硬件加速的区别"><a href="#2-absolute和硬件加速的区别" class="headerlink" title="2.absolute和硬件加速的区别"></a>2.absolute和硬件加速的区别</h5><p>absolute 虽然脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中的render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><h5 id="3-复合图层的作用"><a href="#3-复合图层的作用" class="headerlink" title="3.复合图层的作用"></a>3.复合图层的作用</h5><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但是尽量不要大量使用复合图层，否则由于资源消耗过渡，页面反而会变得更卡</p><h5 id="4-硬件加速时使用index"><a href="#4-硬件加速时使用index" class="headerlink" title="4.硬件加速时使用index"></a>4.硬件加速时使用index</h5><p>使用硬件加速时，尽可能使用z-index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体原理：webkit css3 中，如果整个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其他元素（层级比这个元素高的，或者相同的，并且releative或者absolute属性相同的），会默认变成复合图层渲染，如果处理不当会极大的影响性能</p><p>简单理解：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</p><h2 id="从-Event-Loop谈JS的运行机制"><a href="#从-Event-Loop谈JS的运行机制" class="headerlink" title="从 Event Loop谈JS的运行机制"></a>从 Event Loop谈JS的运行机制</h2><ul><li>JS分为同步任务和异步任务 </li><li>同步任务都在主线程上执行，形成一个执行栈 </li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 </li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到主执行栈中，开始执行 </li><li>异步队列里分为宏任务和微任务 <ul><li>宏任务（macrotask）每次执行栈执行后的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放入执行栈中执行） <ul><li>每一个宏任务都会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始之前，对页面进行重新渲染</li></ul></li><li>微任务（microtask），可以理解是在当前宏任务执行结束后立即执行的任务 <ul><li>在当前宏任务之后，在渲染之前，下一个宏任务之前</li><li>在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（渲染之前）</li></ul></li><li>宏任务：script(整体代码)、setTimeout、setInterval、I&#x2F;O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</li><li>微任务：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</li></ul></li></ul><p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 </p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setTimeout、setInterval是由定时器线程计时的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin&#x27;</span>);<br></code></pre></td></tr></table></figure><p>虽然代码是0毫秒后推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="更新动态列"><a href="#更新动态列" class="headerlink" title="更新动态列"></a>更新动态列</h1><p>在Vue2中使用vxetable组件时，如果不调用clearSort方法而直接修改columns，可能会出现渲染问题。这是因为vxetable组件内部维护了一个状态，用于记录表格的排序状态，当columns发生变化时，如果不正确地更新这个状态，就会导致渲染问题的出现。<br>调用clearSort方法的作用是清除表格的排序状态，这样在更新columns后，vxetable组件会重新根据新的columns进行排序，从而避免渲染问题的出现。<br>具体地，如果不调用clearSort方法，可能会出现以下两种情况：</p><ol><li>表格数据显示不正确：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致表格数据显示不正确，这是因为vxetable组件仍然保留着原来的排序状态，导致新的columns无法正确应用到表格数据上。</li><li>列表头显示异常：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致列表头显示异常，这是因为vxetable组件内部维护的排序状态没有正确更新，导致列表头的渲染出现问题。</li></ol><p>因此，在修改columns时，建议先调用clearSort方法清除排序状态，再进行列属性的更新。这样可以避免渲染问题的出现，确保vxetable组件能够正确地更新和显示数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInViewAnimate</span> = (<span class="hljs-params">el, binding</span>) =&gt; &#123;<br>  <span class="hljs-comment">// check if browser supports IntersectionObserver API</span><br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;IntersectionObserver&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) &#123;<br>    <span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInView</span>(el)) &#123;<br>        el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>        timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// use IntersectionObserver for supported browser</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">[entry]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;<br>      el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>    &#125;<br>  &#125;, &#123;<br>    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span><br>  &#125;);<br>  observer.<span class="hljs-title function_">observe</span>(el);<br><br>  <span class="hljs-comment">// clean up</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    observer.<span class="hljs-title function_">disconnect</span>();<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>      observer.<span class="hljs-title function_">disconnect</span>();<br>    &#125;,<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isInView</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> rect = el.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span> &gt; <span class="hljs-number">100</span>;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>注意点：</p><ul><li>获取排序后的数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; visibleData &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">xxxRef</span>.<span class="hljs-title function_">getTableData</span>()<br><span class="hljs-comment">// visibleData 处理条件之后的全量表体数据（排序后的全量数据）</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/CSS/%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/CSS/%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="瀑布流布局"><a href="#瀑布流布局" class="headerlink" title="瀑布流布局"></a>瀑布流布局</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">4</span>;<span class="hljs-comment">// 想要排列的列数</span><br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">0px</span>;每一列之间的距离<br>  <span class="hljs-selector-class">.item</span> &#123;<br>    agr-<span class="hljs-attribute">break-inside</span>: avoid; <span class="hljs-comment">//禁止在元素内部产生分页行为，防止item元素被分割</span><br>    -webkit-column-<span class="hljs-attribute">break-inside</span>: avoid; <span class="hljs-comment">// 兼容</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="0-5px-完美解决方案"><a href="#0-5px-完美解决方案" class="headerlink" title="0.5px 完美解决方案"></a>0.5px 完美解决方案</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br><span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br><span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>; // 指定变换的原点，防止虚化<br></code></pre></td></tr></table></figure><h1 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h1><h2 id="content-visibility"><a href="#content-visibility" class="headerlink" title="content-visibility"></a>content-visibility</h2><ul><li>优点：<code>content-visibility: auto</code> 跳过屏幕外的内容渲染</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h1><h2 id="cover-view"><a href="#cover-view" class="headerlink" title="cover-view"></a>cover-view</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*  需要添加换行 */</span><br>&#123;<br>  <span class="hljs-attribute">word-break</span>: break-all;<br>  <span class="hljs-attribute">word-wrap</span>: break-word;<br>  <span class="hljs-attribute">white-space</span>: pre-line;<br>&#125;<br></code></pre></td></tr></table></figure><p>不添加有文字重叠或者字符被遮挡一部分的bug</p><h2 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h2><p>不设置 <code>max-length</code> 默认限制140个字符输入</p><h1 id="dom元素"><a href="#dom元素" class="headerlink" title="dom元素"></a>dom元素</h1><h2 id="dom元素获取"><a href="#dom元素获取" class="headerlink" title="dom元素获取"></a>dom元素获取</h2><p>只能获取当前组件或当前页面的dom元素，无法像H5中的<code>document.querySelect()</code>获取整个文档的dom元素<br>滚动demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">uni.<span class="hljs-title function_">createSelectorQuery</span>().<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;.fater&quot;</span>).<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<span class="hljs-comment">//目标节点、也可以是最外层的父级节点</span><br>  uni.<span class="hljs-title function_">createSelectorQuery</span>().<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;.child&quot;</span>).<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<span class="hljs-comment">//最外层盒子节点</span><br>  <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span><br>  uni.<span class="hljs-title function_">pageScrollTo</span>(&#123;<br>  <span class="hljs-attr">duration</span>:<span class="hljs-number">0</span>,<span class="hljs-comment">//过渡时间必须为0，uniapp bug，否则运行到手机会报错</span><br>  <span class="hljs-attr">scrollTop</span>:res.<span class="hljs-property">top</span> - data.<span class="hljs-property">top</span>,<span class="hljs-comment">//滚动到实际距离是元素距离顶部的距离减去最外层盒子的滚动距离</span><br>  &#125;)<br>  &#125;).<span class="hljs-title function_">exec</span>()<br>&#125;).<span class="hljs-title function_">exec</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精确四则运算</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/JavaScript/01.%E7%B2%BE%E7%A1%AE%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/JavaScript/01.%E7%B2%BE%E7%A1%AE%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accAdd</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>    <br>    <span class="hljs-keyword">return</span> ((arg1 * m + arg2 * m) / m).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>&#125; <br><br><span class="hljs-comment">//加法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accAddInt</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>    <br>    <span class="hljs-keyword">return</span> (arg1 * m + arg2 * m) / m;<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个add方法，，使用时直接用 .add 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accAdd</span>(arg, <span class="hljs-variable language_">this</span>);<br>&#125;;<br><br><span class="hljs-comment">//减法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Subtr</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> r1, r2, m, n;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r1 = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>        r2 = <span class="hljs-number">0</span>;<br>    &#125;<br>    m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(r1, r2));<br>     <span class="hljs-comment">//last modify by deeka</span><br>     <span class="hljs-comment">//动态控制精度长度</span><br>    n = (r1 &gt;= r2) ? r1 : r2;<br>    <span class="hljs-keyword">return</span> ((arg1 * m - arg2 * m) / m).<span class="hljs-title function_">toFixed</span>(n);<br>&#125;<br><br><span class="hljs-comment">//给Number类型增加一个add方法，，使用时直接用 .sub 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Subtr</span>(<span class="hljs-variable language_">this</span>, arg);<br>&#125;;<br><br><span class="hljs-comment">//乘法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accMul</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-number">0</span>, s1 = arg1.<span class="hljs-title function_">toString</span>(), s2 = arg2.<span class="hljs-title function_">toString</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        m += s1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m += s2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-title class_">Number</span>(s1.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) * <span class="hljs-title class_">Number</span>(s2.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, m)).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个mul方法，使用时直接用 .mul 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mul</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accMul</span>(arg, <span class="hljs-variable language_">this</span>);<br>&#125;; <br><br><span class="hljs-comment">//除法函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">accDiv</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>    <span class="hljs-keyword">var</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>, r1, r2;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t1 = arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        t2 = arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">with</span> (<span class="hljs-title class_">Math</span>) &#123;<br>        r1 = <span class="hljs-title class_">Number</span>(arg1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>        r2 = <span class="hljs-title class_">Number</span>(arg2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-keyword">return</span> ((r1 / r2) * <span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, t2 - t1)).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125; <br><span class="hljs-comment">//给Number类型增加一个div方法，，使用时直接用 .div 即可完成计算。 </span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">div</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">accDiv</span>(<span class="hljs-variable language_">this</span>, arg);<br>&#125;; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">111</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">// render(h) &#123;</span><br>  <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span><br>  <span class="hljs-comment">// &#125;,</span><br>  <span class="hljs-comment">// template:`&lt;div id=&quot;a&quot;&gt;hello&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="模板编译入口"><a href="#模板编译入口" class="headerlink" title="模板编译入口"></a>模板编译入口</h1><p>传入的 el 或者 template 选项最后都会被解析成 render 函数 这样才能保持模板解析的一致性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-keyword">import</span> &#123; initState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./state&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; compileToFunctions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./compiler/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 这里的this代表调用_init方法的对象(实例对象)</span><br>    <span class="hljs-comment">//  this.$options就是用户new Vue的时候传入的属性</span><br>    vm.<span class="hljs-property">$options</span> = options;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-title function_">initState</span>(vm);<br><br>    <span class="hljs-comment">// 如果有el属性 进行模板渲染</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 这块代码在源码里面的位置其实是放在entry-runtime-with-compiler.js里面</span><br>  <span class="hljs-comment">// 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br><br>    <span class="hljs-comment">// 如果不存在render属性</span><br>    <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>      <span class="hljs-comment">// 如果存在template属性</span><br>      <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br><br>      <span class="hljs-keyword">if</span> (!template &amp;&amp; el) &#123;<br>        <span class="hljs-comment">// 如果不存在render和template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>        template = el.<span class="hljs-property">outerHTML</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>      <span class="hljs-keyword">if</span> (template) &#123;<br>        <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>        options.<span class="hljs-property">render</span> = render;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br>  <br><br></code></pre></td></tr></table></figure><h1 id="模板转化核心方法-compileToFunctions"><a href="#模板转化核心方法-compileToFunctions" class="headerlink" title="模板转化核心方法 compileToFunctions"></a>模板转化核心方法 compileToFunctions</h1><p> 1.生成 ast 2.优化静态节点 3.根据 ast 生成 render 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/index.js</span><br><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./parse&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./codegen&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-comment">// 把html字符串变成render函数</span><br>  <span class="hljs-comment">// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br>  <span class="hljs-comment">// 很多库都运用到了ast 比如 webpack babel eslint等等</span><br>  <span class="hljs-keyword">let</span> ast = <span class="hljs-title function_">parse</span>(template);<br>  <span class="hljs-comment">// 2.优化静态节点</span><br>  <span class="hljs-comment">//   if (options.optimize !== false) &#123;</span><br>  <span class="hljs-comment">//     optimize(ast, options);</span><br>  <span class="hljs-comment">//   &#125;</span><br><br>  <span class="hljs-comment">// 3.通过ast 重新生成代码</span><br>  <span class="hljs-comment">// 最后生成的代码需要和render函数一样</span><br>  <span class="hljs-comment">// 类似_c(&#x27;div&#x27;,&#123;id:&quot;app&quot;&#125;,_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br>  <span class="hljs-comment">// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解析-html-并生成-ast"><a href="#解析-html-并生成-ast" class="headerlink" title="解析 html 并生成 ast"></a>解析 html 并生成 ast</h1><p>利用正则 匹配 html 字符串 遇到开始标签 结束标签和文本 解析完毕之后生成对应的 ast 并建立相应的父子关联 不断的 advance 截取剩余的字符串 直到 html 全部解析完毕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/parse.js</span><br><br><span class="hljs-comment">// 以下为源码的正则  对正则表达式不清楚的同学可以参考小编之前写的文章(前端进阶高薪必看 - 正则篇);</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; <span class="hljs-comment">//匹配标签名 形如 abc-123</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span>; <span class="hljs-comment">//匹配特殊标签 形如 abc:234 前面的abc:可有可无</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="hljs-comment">// 匹配标签开始 形如 &lt;abc-123 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span>; <span class="hljs-comment">// 匹配标签结束  &gt;</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="hljs-comment">// 匹配标签结尾 如 &lt;/abc-123&gt; 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="hljs-comment">// 匹配属性  形如 id=&quot;app&quot;</span><br><br><span class="hljs-keyword">let</span> root, currentParent; <span class="hljs-comment">//代表根节点 和当前父节点</span><br><span class="hljs-comment">// 栈结构 来表示开始和结束标签</span><br><span class="hljs-keyword">let</span> stack = [];<br><span class="hljs-comment">// 标识元素和文本type</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ELEMENT_TYPE</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 生成ast方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createASTElement</span>(<span class="hljs-params">tagName, attrs</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tag</span>: tagName,<br>    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ELEMENT_TYPE</span>,<br>    <span class="hljs-attr">children</span>: [],<br>    attrs,<br>    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 对开始标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStartTag</span>(<span class="hljs-params">&#123; tagName, attrs &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> element = <span class="hljs-title function_">createASTElement</span>(tagName, attrs);<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    root = element;<br>  &#125;<br>  currentParent = element;<br>  stack.<span class="hljs-title function_">push</span>(element);<br>&#125;<br><br><span class="hljs-comment">// 对结束标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEndTag</span>(<span class="hljs-params">tagName</span>) &#123;<br>  <span class="hljs-comment">// 栈结构 []</span><br>  <span class="hljs-comment">// 比如 &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 当遇到第一个结束标签&lt;/span&gt;时 会匹配到栈顶&lt;span&gt;元素对应的ast 并取出来</span><br>  <span class="hljs-keyword">let</span> element = stack.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-comment">// 当前父元素就是栈顶的上一个元素 在这里就类似div</span><br>  currentParent = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  <span class="hljs-comment">// 建立parent和children关系</span><br>  <span class="hljs-keyword">if</span> (currentParent) &#123;<br>    element.<span class="hljs-property">parent</span> = currentParent;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对文本进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChars</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-comment">// 去掉空格</span><br>  text = text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (text) &#123;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TEXT_TYPE</span>,<br>      text,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析标签生成ast核心</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>) &#123;<br>  <span class="hljs-keyword">while</span> (html) &#123;<br>    <span class="hljs-comment">// 查找&lt;</span><br>    <span class="hljs-keyword">let</span> textEnd = html.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>    <span class="hljs-comment">// 如果&lt;在第一个 那么证明接下来就是一个标签 不管是开始还是结束标签</span><br>    <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果开始标签解析有结果</span><br>      <span class="hljs-keyword">const</span> startTagMatch = <span class="hljs-title function_">parseStartTag</span>();<br>      <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br>        <span class="hljs-comment">// 把解析好的标签名和属性解析生成ast</span><br>        <span class="hljs-title function_">handleStartTag</span>(startTagMatch);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 匹配结束标签&lt;/</span><br>      <span class="hljs-keyword">const</span> endTagMatch = html.<span class="hljs-title function_">match</span>(endTag);<br>      <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>        <span class="hljs-title function_">advance</span>(endTagMatch[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        <span class="hljs-title function_">handleEndTag</span>(endTagMatch[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> text;<br>    <span class="hljs-comment">// 形如 hello&lt;div&gt;&lt;/div&gt;</span><br>    <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 获取文本</span><br>      text = html.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, textEnd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (text) &#123;<br>      <span class="hljs-title function_">advance</span>(text.<span class="hljs-property">length</span>);<br>      <span class="hljs-title function_">handleChars</span>(text);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 匹配开始标签</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseStartTag</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = html.<span class="hljs-title function_">match</span>(startTagOpen);<br><br>    <span class="hljs-keyword">if</span> (start) &#123;<br>      <span class="hljs-keyword">const</span> match = &#123;<br>        <span class="hljs-attr">tagName</span>: start[<span class="hljs-number">1</span>],<br>        <span class="hljs-attr">attrs</span>: [],<br>      &#125;;<br>      <span class="hljs-comment">//匹配到了开始标签 就截取掉</span><br>      <span class="hljs-title function_">advance</span>(start[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br><br>      <span class="hljs-comment">// 开始匹配属性</span><br>      <span class="hljs-comment">// end代表结束符号&gt;  如果不是匹配到了结束标签</span><br>      <span class="hljs-comment">// attr 表示匹配的属性</span><br>      <span class="hljs-keyword">let</span> end, attr;<br>      <span class="hljs-keyword">while</span> (<br>        !(end = html.<span class="hljs-title function_">match</span>(startTagClose)) &amp;&amp;<br>        (attr = html.<span class="hljs-title function_">match</span>(attribute))<br>      ) &#123;<br>        <span class="hljs-title function_">advance</span>(attr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        attr = &#123;<br>          <span class="hljs-attr">name</span>: attr[<span class="hljs-number">1</span>],<br>          <span class="hljs-attr">value</span>: attr[<span class="hljs-number">3</span>] || attr[<span class="hljs-number">4</span>] || attr[<span class="hljs-number">5</span>], <span class="hljs-comment">//这里是因为正则捕获支持双引号 单引号 和无引号的属性值</span><br>        &#125;;<br>        match.<span class="hljs-property">attrs</span>.<span class="hljs-title function_">push</span>(attr);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (end) &#123;<br>        <span class="hljs-comment">//   代表一个标签匹配到结束的&gt;了 代表开始标签解析完毕</span><br>        <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> match;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//截取html字符串 每次匹配到了就往前继续匹配</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">advance</span>(<span class="hljs-params">n</span>) &#123;<br>    html = html.<span class="hljs-title function_">substring</span>(n);<br>  &#125;<br>  <span class="hljs-comment">//   返回生成的ast</span><br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据-ast-重新生成代码"><a href="#根据-ast-重新生成代码" class="headerlink" title="根据 ast 重新生成代码"></a>根据 ast 重新生成代码</h1><p>拿到生成好的 ast 之后 需要把 ast 转化成类似_c(‘div’,{id:”app”},_c(‘div’,undefined,_v(“hello”+_s(name)),_c(‘span’,undefined,_v(“world”))))这样的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/codegen.js</span><br><br><span class="hljs-keyword">const</span> defaultTagRE = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>; <span class="hljs-comment">//匹配花括号 &#123;&#123;  &#125;&#125; 捕获花括号里面的内容</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 判断节点类型</span><br>  <span class="hljs-comment">// 主要包含处理文本核心</span><br>  <span class="hljs-comment">// 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式&#123;&#123;&#125;&#125;的处理</span><br><br>  <span class="hljs-comment">// 如果是元素类型</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//   递归创建</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">generate</span>(node);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   如果是文本节点</span><br>    <span class="hljs-keyword">let</span> text = node.<span class="hljs-property">text</span>;<br>    <span class="hljs-comment">// 不存在花括号变量表达式</span><br>    <span class="hljs-keyword">if</span> (!defaultTagRE.<span class="hljs-title function_">test</span>(text)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(text)&#125;</span>)`</span>;<br>    &#125;<br>    <span class="hljs-comment">// 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug</span><br>    <span class="hljs-keyword">let</span> lastIndex = (defaultTagRE.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> tokens = [];<br>    <span class="hljs-keyword">let</span> match, index;<br><br>    <span class="hljs-keyword">while</span> ((match = defaultTagRE.<span class="hljs-title function_">exec</span>(text))) &#123;<br>      <span class="hljs-comment">// index代表匹配到的位置</span><br>      index = match.<span class="hljs-property">index</span>;<br>      <span class="hljs-keyword">if</span> (index &gt; lastIndex) &#123;<br>        <span class="hljs-comment">//   匹配到的&#123;&#123;位置  在tokens里面放入普通文本</span><br>        tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex, index)));<br>      &#125;<br>      <span class="hljs-comment">//   放入捕获到的变量内容</span><br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-string">`_s(<span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>].trim()&#125;</span>)`</span>);<br>      <span class="hljs-comment">//   匹配指针后移</span><br>      lastIndex = index + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push</span><br>    <span class="hljs-keyword">if</span> (lastIndex &lt; text.<span class="hljs-property">length</span>) &#123;<br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex)));<br>    &#125;<br>    <span class="hljs-comment">// _v表示创建文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;tokens.join(<span class="hljs-string">&quot;+&quot;</span>)&#125;</span>)`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理attrs属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genProps</span>(<span class="hljs-params">attrs</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; attrs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> attr = attrs[i];<br>    <span class="hljs-comment">// 对attrs属性里面的style做特殊处理</span><br>    <span class="hljs-keyword">if</span> (attr.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>      attr.<span class="hljs-property">value</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;;&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>);<br>        obj[key] = value;<br>      &#125;);<br>      attr.<span class="hljs-property">value</span> = obj;<br>    &#125;<br>    str += <span class="hljs-string">`<span class="hljs-subst">$&#123;attr.name&#125;</span>:<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;str.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>&#125;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 生成子节点 调用gen函数进行递归创建</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildren</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> children = el.<span class="hljs-property">children</span>;<br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;children.map((c) =&gt; gen(c)).join(<span class="hljs-string">&quot;,&quot;</span>)&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 递归创建生成code</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title function_">getChildren</span>(el);<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-string">`_c(&#x27;<span class="hljs-subst">$&#123;el.tag&#125;</span>&#x27;,<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    el.attrs.length ? <span class="hljs-string">`<span class="hljs-subst">$&#123;genProps(el.attrs)&#125;</span>`</span> : <span class="hljs-string">&quot;undefined&quot;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;</span><span class="hljs-subst">$&#123;children ? <span class="hljs-string">`,<span class="hljs-subst">$&#123;children&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>)`</span>;<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="code-字符串生成-render-函数"><a href="#code-字符串生成-render-函数" class="headerlink" title="code 字符串生成 render 函数"></a>code 字符串生成 render 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">// 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值 比如 name值就变成了this.name</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="组件挂载入口"><a href="#组件挂载入口" class="headerlink" title="组件挂载入口"></a>组件挂载入口</h1><p>模板编译解析生成了render函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>  el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>  <br>  <span class="hljs-comment">// 如果不存在 render 属性</span><br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>    <span class="hljs-comment">// 如果存在 template 属性</span><br>    <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br>    <br>    <span class="hljs-keyword">if</span> (!templage &amp;&amp; el) &#123;<br>      <span class="hljs-comment">// 如果不存在 render 和 template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>      template = el.<span class="hljs-property">outerHTML</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>    <span class="hljs-keyword">if</span> (template) &#123;<br>      <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>      options.<span class="hljs-property">render</span> = render;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将当前组件实例挂载到真实的el节点上面</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountComponent</span>(vm, el);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-函数-gt-虚拟-dom-render"><a href="#render-函数-gt-虚拟-dom-render" class="headerlink" title="render 函数 -&gt; 虚拟 dom  _render"></a>render 函数 -&gt; 虚拟 dom  _render</h1><p>执行vm._render()方法 调用生成的render函数 生成虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/render.js</span><br><span class="hljs-keyword">import</span> &#123; createElement, createTextNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/index&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取模板编译生成的render方法</span><br>    <span class="hljs-keyword">const</span> &#123; render &#125; = vm.<span class="hljs-property">$options</span>;<br>    <span class="hljs-comment">// 生成 vnode 虚拟dom</span><br>    <span class="hljs-keyword">const</span> vnode = render.<span class="hljs-title function_">call</span>(vm);<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br><br>  <span class="hljs-comment">// render函数里面有_c _v _s方法需要定义</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_c</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(...args);<br>  &#125;;<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_v</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_s</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-comment">// 如果模板里面的是一个对象  需要JSON.stringify</span><br>    <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span><br>      ? <span class="hljs-string">&quot;&quot;</span><br>      : <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;object&quot;</span><br>      ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(val)<br>      : val;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/index.js</span><br><br><span class="hljs-comment">// 定义Vnode类</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vnode</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, data, key, children, text</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建元素vnode 等于render函数里面的 h=&gt;h(App)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag, data = &#123;&#125;, ...children</span>) &#123;<br>  <span class="hljs-keyword">let</span> key = data.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(tag, data, key, children);<br>&#125;<br><br><span class="hljs-comment">// 创建文本vnode</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, text);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="虚拟dom-gt-真实-dom-update"><a href="#虚拟dom-gt-真实-dom-update" class="headerlink" title="虚拟dom -&gt;真实 dom   _update"></a>虚拟dom -&gt;真实 dom   _update</h1><p>_update 核心方法就是 patch 初始渲染和后续更新都是共用这一个方法 只是传入的第一个参数不同 初始渲染总体思路就是根据虚拟 dom(vnode) 调用原生 js 方法创建真实 dom 节点并替换掉 el 选项的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><br><span class="hljs-keyword">import</span> &#123; patch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/patch&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-comment">// 把_update挂载在Vue的原型</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// patch是渲染vnode为真实dom核心</span><br>    vm.<span class="hljs-property">$el</span> = <span class="hljs-title function_">patch</span>(vm.<span class="hljs-property">$el</span>, vnode)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/patch.js</span><br><span class="hljs-comment">// patch 用来渲染和更新视图 （此处仅包含初次渲染的逻辑）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode</span>) &#123;<br>  <span class="hljs-comment">// 判断传入的oldVnode是否是一个真实元素</span><br>  <span class="hljs-comment">// 这里很关键 初次渲染 传入的vm.$el就是咱们传入的el选项  所以是真实dom</span><br>  <span class="hljs-comment">// 如果不是初始渲染而是视图更新的时候  vm.$el就被替换成了更新之前的老的虚拟dom</span><br>  <span class="hljs-keyword">const</span> isRealElement = oldVnode.<span class="hljs-property">nodeType</span>;<br>  <span class="hljs-keyword">if</span> (isRealElement) &#123;<br>    <span class="hljs-comment">// 这里是初次渲染的逻辑</span><br>    <span class="hljs-keyword">const</span> oldElm = oldVnode;<br>    <span class="hljs-keyword">const</span> parentElm = oldElm.<span class="hljs-property">parentNode</span>;<br>    <span class="hljs-comment">// 将虚拟dom转化成真实dom节点</span><br>    <span class="hljs-keyword">let</span> el = <span class="hljs-title function_">createElm</span>(vnode);<br>    <span class="hljs-comment">// 插入到 老的el节点下一个节点的前面 就相当于插入到老的el节点的后面</span><br>    <span class="hljs-comment">// 这里不直接使用父元素appendChild是为了不破坏替换的位置</span><br>    parentElm.<span class="hljs-title function_">insertBefore</span>(el, oldElm.<span class="hljs-property">nextSibling</span>);<br>    <span class="hljs-comment">// 删除老的el节点</span><br>    parentElm.<span class="hljs-title function_">removeChild</span>(oldVnode);<br>    <span class="hljs-keyword">return</span> el;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 虚拟 dom 转成真实 dom 就是调用原生方法生成 dom 树</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; tag, data, key, children, text &#125; = vnode;<br>  <span class="hljs-comment">//   判断虚拟dom 是元素节点还是文本节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   虚拟dom的el属性指向真实dom</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);<br>    <span class="hljs-comment">// 解析虚拟dom属性</span><br>    <span class="hljs-title function_">updateProperties</span>(vnode);<br>    <span class="hljs-comment">// 如果有子节点就递归插入到父节点里面</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElm</span>(child));<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   文本节点</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析vnode的data属性 映射到真实dom上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProperties</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> newProps = vnode.<span class="hljs-property">data</span> || &#123;&#125;;<br>  <span class="hljs-keyword">let</span> el = vnode.<span class="hljs-property">el</span>; <span class="hljs-comment">//真实节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-comment">// style需要特殊处理下</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> newProps.<span class="hljs-property">style</span>) &#123;<br>        el.<span class="hljs-property">style</span>[styleName] = newProps.<span class="hljs-property">style</span>[styleName];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;class&quot;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = newProps.<span class="hljs-property">class</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 给这个元素添加属性 值就是对应的值</span><br>      el.<span class="hljs-title function_">setAttribute</span>(key, newProps[key]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mountComponent-挂载"><a href="#mountComponent-挂载" class="headerlink" title="mountComponent 挂载"></a>mountComponent 挂载</h1><p>使用vm._update()方法把虚拟dom渲染到页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">// 上一步模板编译解析生成了render函数</span><br>  <span class="hljs-comment">// 下一步就是执行vm._render()方法 调用生成的render函数 生成虚拟dom</span><br>  <span class="hljs-comment">// 最后使用vm._update()方法把虚拟dom渲染到页面</span><br>  <span class="hljs-comment">// 真实的el选项赋值给实例的$el属性 为之后虚拟dom产生的新的dom替换老的dom做铺垫</span><br>  vm.<span class="hljs-property">$el</span> = el;<br>  <span class="hljs-comment">// _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-和-update-原型方法的混入"><a href="#render-和-update-原型方法的混入" class="headerlink" title="_render 和 _update 原型方法的混入"></a>_render 和 _update 原型方法的混入</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lifecycle&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./render&quot;</span>;<br><span class="hljs-comment">// Vue就是一个构造函数 通过new关键字进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 这里开始进行Vue初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载需要传入Vue</span><br><span class="hljs-comment">// 此做法有利于代码分割</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><br><span class="hljs-comment">// 混入_render</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-comment">// 混入_update</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello &#123;&#123;a&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们在这里模拟更新</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">a</span> = <span class="hljs-number">456</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 此方法是刷新视图的核心</span></span><br><span class="language-javascript">    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在数据变动的时候自动去更新视图</p><h1 id="定义-Watcher"><a href="#定义-Watcher" class="headerlink" title="定义 Watcher"></a>定义 Watcher</h1><p>在 observer 文件夹下新建 watcher.js 代表和观察者相关 可以把 Watcher 当做观察者 它需要订阅数据的变动 当数据变动之后 通知它去执行某些方法 其实本质就是一个构造函数 初始化的时候会去执行 get 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><span class="hljs-comment">// 全局变量id 每次 new Watcher 都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建渲染-Watcher"><a href="#创建渲染-Watcher" class="headerlink" title="创建渲染 Watcher"></a>创建渲染 Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">//   _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br><br>  <span class="hljs-comment">// 引入watcher的概念 这里注册一个渲染watcher 执行vm._update(vm._render())方法渲染视图</span><br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;刷新页面&quot;</span>);<br>    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>  &#125;;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="定义-Dep"><a href="#定义-Dep" class="headerlink" title="定义 Dep"></a>定义 Dep</h1><p>Dep 也是一个构造函数 可以把他理解为观察者模式里面的被观察者 在 subs 里面收集 watcher 当数据变动的时候通知自身 subs 所有的 watcher 更新<br>Dep.target 是一个全局 Watcher 指向 初始状态是 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h1 id="对象的依赖收集"><a href="#对象的依赖收集" class="headerlink" title="对象的依赖收集"></a>对象的依赖收集</h1><p>依赖收集和派发更新的核心 其实就是在数据被访问的时候 把我们定义好的渲染 Watcher 放到 dep 的 subs 数组里面 同时把 dep 实例对象也放到渲染 Watcher 里面去 数据更新时就可以通知 dep 的 subs 存储的 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value);<br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-watcher"><a href="#完善-watcher" class="headerlink" title="完善 watcher"></a>完善 watcher</h1><p>watcher 在调用 getter 方法前后分别把自身赋值给 Dep.target 方便进行依赖收集 update 方法用来更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dep&quot;</span>;<br><br><span class="hljs-comment">// 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []; <span class="hljs-comment">//存放dep的容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">//用来去重dep</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>(); <span class="hljs-comment">//如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-keyword">let</span> id = dep.<span class="hljs-property">id</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">add</span>(id);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);<br>      <span class="hljs-comment">//   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-dep"><a href="#完善-dep" class="headerlink" title="完善 dep"></a>完善 dep</h1><p>定义相关的方法把收集依赖的同时把自身也放到 watcher 的 deps 容器里面去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   如果当前存在watcher</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 把自身-dep实例存放在watcher里面</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   依次执行subs里面的watcher更新方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">watcher</span>) =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-comment">//   把watcher加入到自身的subs容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的依赖收集"><a href="#数组的依赖收集" class="headerlink" title="数组的依赖收集"></a>数组的依赖收集</h1><p>如果对象属性的值是一个数组 那么执行 childOb.dep.depend()收集数组的依赖 如果数组里面还包含数组 需要递归遍历收集 因为只有访问数据触发了 get 才会去收集依赖 一开始只是递归对数据进行响应式处理无法收集依赖 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// childOb就是Observer实例</span><br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          <span class="hljs-comment">// 这里表示 属性的值依然是一个对象 包含数组和对象 childOb指代的就是Observer实例对象  里面的dep进行依赖收集</span><br>          <span class="hljs-comment">// 比如&#123;a:[1,2,3]&#125; 属性a对应的值是一个数组 观测数组的返回值就是对应数组的Observer实例对象</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果数据结构类似 &#123;a:[1,2,[3,4,[5,6]]]&#125; 这种数组多层嵌套  数组包含数组的情况  那么我们访问a的时候 只是对第一层的数组进行了依赖收集 里面的数组因为没访问到  所以五大收集依赖  但是如果我们改变了a里面的第二层数组的值  是需要更新页面的  所以需要对数组递归进行依赖收集</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>              <span class="hljs-comment">// 如果内部还是数组</span><br>              <span class="hljs-title function_">dependArray</span>(value); <span class="hljs-comment">// 不停的进行依赖收集</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 递归收集数组依赖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dependArray</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e, i = <span class="hljs-number">0</span>, l = value.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    e = value[i];<br>    <span class="hljs-comment">// e.__ob__代表e已经被响应式观测了 但是没有收集依赖 所以把他们收集到自己的Observer实例的dep里面</span><br>    e &amp;&amp; e.<span class="hljs-property">__ob__</span> &amp;&amp; e.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(e)) &#123;<br>      <span class="hljs-comment">// 如果数组里面还有数组  就递归去收集依赖</span><br>      <span class="hljs-title function_">dependArray</span>(e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的派发更新"><a href="#数组的派发更新" class="headerlink" title="数组的派发更新"></a>数组的派发更新</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/array.js</span><br><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">//   这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 这句话是关键</span><br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性代表的是该数据已经被响应式观察过了 __ob__对象指的就是Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted); <span class="hljs-comment">// 对新增的每一项进行观测</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">//数组派发更新 ob指的就是数组对应的Observer实例 我们在get的时候判断如果属性的值还是对象那么就在Observer实例的dep收集依赖 所以这里是一一对应的  可以直接更新</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>watch</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/</url>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>侦听属性的写法很多 可以写成 字符串 函数 数组 以及对象 对于对象的写法自己可以增加一些 options 用来增强功能 侦听属性的特点是监听的值发生了变化之后可以执行用户传入的自定义方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;&#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">aa</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#x27;doSomething&#x27;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: [&#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;]</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">aa</span> = <span class="hljs-number">1111</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 统一初始化数据的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-title function_">initWatch</span>(vm);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 watch</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> watch = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">watch</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> watch) &#123;<br>    <span class="hljs-keyword">const</span> handler = watch[k]; <span class="hljs-comment">// 用户自定义 watch 的写法，可能是数组 对象 函数 字符串</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;<br>      <span class="hljs-comment">// 如果是数组就遍历进行创建</span><br>      handler.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">handle</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, k, handle);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, k, handler);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建watcher的核心</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span>(<span class="hljs-params">vm, exprOrFn, handler, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    options = handler; <span class="hljs-comment">//保存用户传入的对象</span><br>    handler = handler.<span class="hljs-property">handler</span>; <span class="hljs-comment">//这个代表真正用户传入的函数</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   代表传入的是定义好的methods方法</span><br>    handler = vm[handler];<br>  &#125;<br>  <span class="hljs-comment">//   调用vm.$watch创建用户watcher</span><br>  <span class="hljs-keyword">return</span> vm.$watch(exprOrFn, handler, options);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h1><p>原型方法$watch 就是创建自定义 watch 的核心方法 把用户定义的 options 和 user:true 传给构造函数 Watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observer/watcher&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">experOrFn, cb, option</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">let</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, exprOrFn, cb, &#123; ...options, <span class="hljs-attr">user</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-comment">// 如果有immediate属性 代表需要立即执行回调</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">cb</span>(); <span class="hljs-comment">// 如果立刻执行</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; isObject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = options.<span class="hljs-property">user</span>; <span class="hljs-comment">//标识用户watcher</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>        <span class="hljs-keyword">let</span> path = exprOrFn.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">let</span> obj = vm;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>          obj = obj[path[i]]; <span class="hljs-comment">//vm.a.a.a.a.b</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就进行一次取值操作 进行依赖收集过程</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-comment">//   get() &#123;</span><br>  <span class="hljs-comment">//     pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>  <span class="hljs-comment">//     const res = this.getter.call(this.vm); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>  <span class="hljs-comment">//     popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  <span class="hljs-comment">//     return res;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-comment">//   update() &#123;</span><br>  <span class="hljs-comment">//     // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>  <span class="hljs-comment">//     if (this.lazy) &#123;</span><br>  <span class="hljs-comment">//       this.dirty = true;</span><br>  <span class="hljs-comment">//     &#125;else&#123;</span><br>  <span class="hljs-comment">//       // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>  <span class="hljs-comment">//       // 异步队列机制</span><br>  <span class="hljs-comment">//       queueWatcher(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   depend()&#123;</span><br>  <span class="hljs-comment">//     // 计算属性的watcher存储了依赖项的dep</span><br>  <span class="hljs-comment">//     let i=this.deps.length</span><br>  <span class="hljs-comment">//     while(i--)&#123;</span><br>  <span class="hljs-comment">//       this.deps[i].depend() //调用依赖项的dep去收集渲染watcher</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newVal = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">//新值</span><br>    <span class="hljs-keyword">const</span> oldVal = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">//老值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = newVal; <span class="hljs-comment">//现在的新值将成为下一次变化的老值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>      <span class="hljs-comment">// 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址</span><br>      <span class="hljs-keyword">if</span> (newVal !== oldVal || <span class="hljs-title function_">isObject</span>(newVal)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, newVal, oldVal);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 渲染watcher</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>在两秒之后改变了模板里面的 cc 但是计算属性依赖的 aa 和 bb 都没变化 所以计算属性不会重新计算 还是保留的上次计算结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">cc</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;computedName&#125;&#125;&#123;&#123;cc&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">computedName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">aa</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bb</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-comment">// 当我们每一次改变数据的时候  渲染watcher都会执行一次 这个是影响性能的</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">cc</span> = <span class="hljs-number">4</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">2000</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="计算属性的初始化"><a href="#计算属性的初始化" class="headerlink" title="计算属性的初始化"></a>计算属性的初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">const</span> computed = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">computed</span>;<br>  <span class="hljs-keyword">const</span> watchers = (vm.<span class="hljs-property">_computedWatchers</span> = &#123;&#125;); <span class="hljs-comment">// 用来存放计算 watcher</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> coumputed) &#123;<br>    <span class="hljs-keyword">const</span> userEdf = computed[k]; <span class="hljs-comment">// 获取用户定义的计算属性</span><br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span>;<span class="hljs-comment">//创建计算属性watcher使用</span><br>    <span class="hljs-comment">// 创建计算watcher lazy设置为true</span><br>    watchers[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, <span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;);<br>    <span class="hljs-title function_">defineComputed</span>(vm, k, userDef);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对计算属性进行属性劫持"><a href="#对计算属性进行属性劫持" class="headerlink" title="对计算属性进行属性劫持"></a>对计算属性进行属性劫持</h1><p><code>defineComputed</code> 方法主要是重新定义计算属性 其实最主要的是劫持 get 方法 也就是计算属性依赖的值。<br>需要根据依赖值是否发生变化来判断计算属性是否需要重新计算<br><code>createComputedGetter</code> 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 <code>Watcher</code> 增加 <code>dirty</code> 标志位 如果标志变为 <code>true</code> 代表需要调用 <code>watcher.evaluate</code> 来进行重新计算了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 定义普通对象用来劫持计算属性</span><br><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;<br><span class="hljs-comment">// 重新定义计算属性 对 get 和 set 劫持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key, userDef</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果是一个函数  需要手动赋值到get上</span><br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = userDef.<span class="hljs-property">set</span>;<br>  &#125;<br>  <span class="hljs-comment">//   利用Object.defineProperty来对计算属性的get和set进行劫持</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition);<br>&#125;<br><span class="hljs-comment">// 重写计算属性的 get 方法，来判断是否需要进行重新计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]; <span class="hljs-comment">//获取对应的计算属性watcher</span><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;<br>        watcher.evaluate(); <span class="hljs-comment">//计算属性取值的时候 如果是脏的  需要重新求值</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>1.实例化的时候如果是计算属性 不会去调用 get 方法访问值进行依赖收集<br>2.update 方法只是把计算 watcher 的 dirty 标识为 true 只有当下次访问到了计算属性的时候才会重新计算<br>3.新增 evaluate 方法专门用于计算属性重新计算<br>4.新增 depend 方法 让计算属性的依赖值收集外层 watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-comment">// import &#123; pushTarget, popTarget &#125; from &quot;./dep&quot;;</span><br><span class="hljs-comment">// import &#123; queueWatcher &#125; from &quot;./scheduler&quot;;</span><br><span class="hljs-comment">// import &#123;isObject&#125; from &#x27;../util/index&#x27;</span><br><span class="hljs-comment">// // 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-comment">// let id = 0;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br>    <span class="hljs-comment">// this.user = options.user; //标识用户watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//标识计算属性watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//dirty可变  表示计算watcher是否需要重新计算 默认值是true</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-comment">// if (typeof exprOrFn === &quot;function&quot;) &#123;</span><br>    <span class="hljs-comment">//   this.getter = exprOrFn;</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//   this.getter = function () &#123;</span><br>    <span class="hljs-comment">//     //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>    <span class="hljs-comment">//     let path = exprOrFn.split(&quot;.&quot;);</span><br>    <span class="hljs-comment">//     let obj = vm;</span><br>    <span class="hljs-comment">//     for (let i = 0; i &lt; path.length; i++) &#123;</span><br>    <span class="hljs-comment">//       obj = obj[path[i]]; //vm.a.a.a.a.b</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return obj;</span><br>    <span class="hljs-comment">//   &#125;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>); <span class="hljs-comment">//计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>      <span class="hljs-comment">// 异步队列机制</span><br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   计算属性重新进行计算 并且计算完成把dirty置为false</span><br>  <span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性的watcher存储了依赖项的dep</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">//调用依赖项的dep去收集渲染watcher</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   run() &#123;</span><br>  <span class="hljs-comment">//     const newVal = this.get(); //新值</span><br>  <span class="hljs-comment">//     const oldVal = this.value; //老值</span><br>  <span class="hljs-comment">//     this.value = newVal; //跟着之后  老值就成为了现在的值</span><br>  <span class="hljs-comment">//     if (this.user) &#123;</span><br>  <span class="hljs-comment">//       if(newVal!==oldVal||isObject(newVal))&#123;</span><br>  <span class="hljs-comment">//         this.cb.call(this.vm, newVal, oldVal);</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     &#125; else &#123;</span><br>  <span class="hljs-comment">//       // 渲染watcher</span><br>  <span class="hljs-comment">//       this.cb.call(this.vm);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="外层-Watcher-的依赖收集"><a href="#外层-Watcher-的依赖收集" class="headerlink" title="外层 Watcher 的依赖收集"></a>外层 Watcher 的依赖收集</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-comment">//   return function () &#123;</span><br><span class="hljs-comment">//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher</span><br><span class="hljs-comment">//     if (watcher) &#123;</span><br><span class="hljs-comment">//       if (watcher.dirty) &#123;</span><br><span class="hljs-comment">//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-comment">// 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集</span><br>          watcher.<span class="hljs-title function_">depend</span>()<br>        &#125;<br><span class="hljs-comment">//       &#125;</span><br><span class="hljs-comment">//       return watcher.value;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性依赖的值发生了改变 这时候 watcher 的 dirty 为 true 下次访问计算属性 ,此时数据改变了，但是还没触发视图更新<br>因为模板里面只有计算属性 而计算属性的依赖值的 dep 里面只收集了计算 watcher 的依赖 。<br>自身变化也只是通知了计算 watcher 调用 update 把 dirty 置为 true 。<br>所以需要把计算属性的依赖项也添加渲染 watcher 的依赖。<br>让自身变化之后首先通知计算 watcher 进行重新计算 然后通知渲染 watcher 进行视图更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>可见最初设计存放 watcher 的容器就是一个栈结构。<br>因为整个 Vue 生命周期的过程中会存在很多的 watcher 比如渲染 watcher 计算 watcher 侦听 watcher 等。<br>而每个 watcher 在调用了自身的 get 方法前后会分别调用 pushTarget 入栈和 popTarget 出栈。<br>这样子当计算属性重新计算之后就立马会出栈 那么外层的 watcher 就会成为新的 Dep.target。<br>使用 watcher.depend 方法让计算属性依赖的值收集一遍外层的渲染 watcher 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="header-body"><a href="#header-body" class="headerlink" title="header + body"></a>header + body</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">起始行+头部+空行+实体<br></code></pre></td></tr></table></figure><h4 id="请求报文的结构"><a href="#请求报文的结构" class="headerlink" title="请求报文的结构"></a>请求报文的结构</h4><h5 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/home</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p>方法 + 路径 + http 版本</p><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>请求体</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><ul><li>GET <ul><li>通常用来获取资源</li></ul></li><li>HEAD <ul><li>获取资源的元信息</li></ul></li><li>POST <ul><li>上传数据</li><li>会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body 部分。(火狐浏览器除外，他的 POST 请求只发一个 TCP 包)</li></ul></li><li>PUT <ul><li>修改完整数据</li></ul></li><li>PATCH <ul><li>修改部分数据</li></ul></li><li>DELETE <ul><li>删除资源</li></ul></li><li>CONNECT <ul><li>建立连接隧道，用于代理服务器</li></ul></li><li>OPTIONS <ul><li>列出可对资源实行的请求方法，用来跨域请求</li></ul></li><li>TRACE <ul><li>追求请求-响应传输的路径</li></ul></li></ul><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p>URI(Uniform Resource Identifier) 统一资源标识符，作用：区分互联网上不同的资源</p><p>网址：URL，URI 包含了 URL 和 URN 两个部分，</p><h6 id="URI的结构："><a href="#URI的结构：" class="headerlink" title="URI的结构："></a>URI的结构：</h6><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" alt="image.png"></p><p><strong>scheme</strong> 表示协议名，比如 http, https, file 等等。后面必须和:&#x2F;&#x2F;连在一起</p><p>**user:password@**表示登录主机时的用户信息，很不安全，不推荐使用，不常用</p><p><strong>host:port</strong>表示主机名和端口</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为key&#x3D;val这种形式，多个键值对之间用&amp;隔开</p><p><strong>fagment</strong>表示 URI 所定位的资源内的一个 <strong>锚点</strong>，浏览器可以通过这个锚点跳转到对于的 位置</p><h5 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h5><p><strong>URI</strong> 只能使用 <strong>ASCII</strong>，<strong>ASCLII</strong>之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错</p><p>因此，<strong>URI</strong> 引入了编码机制，将所有 <strong>非 ASSCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个 <strong>%</strong></p><p>例：空格转义为**%20**</p><h4 id="响应报文的结构"><a href="#响应报文的结构" class="headerlink" title="响应报文的结构"></a>响应报文的结构</h4><h5 id="起始行也叫状态行"><a href="#起始行也叫状态行" class="headerlink" title="起始行也叫状态行"></a>起始行也叫状态行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><p>http 版本 + 状态码 + 原因</p><h5 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h5><ul><li><strong>1xx：</strong>表示目前是协议处理中的中间状态，还需要后续操作。 <ul><li><strong>101 Switching Protocols</strong> 在 HTTP 升级为 webSocket 的时候，如果服务器同意变更，就会发送状态码 101</li></ul></li><li><strong>2xx：</strong>  表示成功状态。 <ul><li><strong>200 OK</strong> 成功状态码，响应体中有数据。</li><li><strong>204 No Content</strong> 成功状态码，响应体中无数据。</li><li><strong>206 Partial Content</strong> 表示部分内容，使用场景为：HTTP 分块下载和断点续传，会带上相应的响应头字段 Content-Range。</li></ul></li><li><strong>3xx：</strong>重定向状态，资源位置发生变动，需要重新请求 <ul><li><strong>301 Moved Permanently</strong> 永久重定向 </li><li><strong>302 Found</strong> 临时重定向<br>例：<br> 以前的站点再也不用了返回 301，浏览器会默认做优化缓存，在第二次访问的时候自动访问重定向的那个地址。<br> 以前的站点暂时不可用，直接返回 302 ，浏览器不会做缓存优化 </li><li><strong>304 Not Modified</strong> 当协商缓存命中时会返回这个状态码。</li></ul></li><li><strong>4xx：</strong>请求报文有误 <ul><li><strong>400 Bad Request</strong> 服务器无法理解该请求 可能是语法错误。</li><li><strong>403 Forbidden</strong> 服务器禁止访问。</li><li><strong>404 Not Found</strong> 资源未找到，没在服务器上找到相应的资源。</li><li><strong>405 Method Not Allowed</strong> 请求方法不被服务器允许。</li><li><strong>406 Not Acceptable</strong> 资源无法满足客户端的条件。</li><li><strong>408 Request Timeout</strong> 服务器等待了太长时间。</li><li><strong>409 Conflict</strong> 多个请求发生了冲突。</li><li><strong>413 Request Entity Too Large</strong> 请求体的数据过大。</li></ul></li><li><strong>5xx</strong> <ul><li><strong>500 Internal Server Error</strong> 服务器出错</li><li><strong>501 Not Implemented</strong> 客户端请求的功能还不支持。</li><li><strong>502 Bad Gateway</strong> 服务器自身是正常的，但是访问的时候出错了。</li><li><strong>503 Service Unavailable</strong> 服务器当前很忙，暂时无法响应服务。</li></ul></li><li><strong>5xx：</strong>服务端发生错误</li></ul><h3 id="HTTP特点以及缺点"><a href="#HTTP特点以及缺点" class="headerlink" title="HTTP特点以及缺点"></a>HTTP特点以及缺点</h3><h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><ol><li>灵活可拓展 <ol><li>语义上自由，只有基本格式没有严格限制</li><li>传输形式多样性，可以传输文本、图片、视频等任意数据</li></ol></li><li>可靠传输，HTTP基于 TCP&#x2F;IP ，这是 TCP 的特性</li><li>请求-应答，一发一收、有来有回。</li><li>无状态，状态：通信过程的上下文信息，每次 http 请求都是独立、无关的，默认不需要保留状态信息</li></ol><h4 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h4><ol><li>无状态</li></ol><ul><li>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，此时是缺点</li><li>在只是获取一些数据的场景中，不需要保存连接上下文信息，无状态减少了网络开销，此时是优点</li></ul><ol start="2"><li>明文传输<br>协议里的报文（主要指头部）不使用二进制数据，而是文本形式<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<strong>WIFI陷阱</strong> 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。 </li><li>队头阻塞问题</li></ol><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><h3 id="Accept-系列字段"><a href="#Accept-系列字段" class="headerlink" title="Accept 系列字段"></a>Accept 系列字段</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>发送端：Content-Type 字段</p><p>接收端：Accept 字段</p><p>取值：</p><pre><code class="hljs">text： text/html, text/plain, text/css 等image: image/gif, image/jpeg, image/png 等audio/video: audio/mpeg, video/mp4 等application: application/json, application/javascript, application/pdf, application/octet-stream</code></pre><h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>发送方：Content-Encoding</p><p>接受方：Accept-Encoding</p><p>取值:</p><pre><code class="hljs">gzip:最流行的压缩格式deflate:另一种著名的压缩格式br:一种专门为 HTTP 发明的压缩算法</code></pre><h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>发送端：Content-Language</p><p>接收方：Accept-Language</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>发送方：Content-Type:charset&#x3D;utf-8</p><p>接收端：Accept-Charset:charset&#x3D;utf-8</p><h3 id="HTTP对定长和不定长数据传输的处理"><a href="#HTTP对定长和不定长数据传输的处理" class="headerlink" title="HTTP对定长和不定长数据传输的处理"></a>HTTP对定长和不定长数据传输的处理</h3><h4 id="定长包"><a href="#定长包" class="headerlink" title="定长包"></a>定长包</h4><p>发送端带上Content-length</p><h4 id="不定长包"><a href="#不定长包" class="headerlink" title="不定长包"></a>不定长包</h4><p>发送端带上 Transfer-Encoding: chunked</p><p>表示分块传输数据，设置这个字段后会自动产生两个效果</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推动动态内容</li></ul><h3 id="HTTP-处理大文件传输"><a href="#HTTP-处理大文件传输" class="headerlink" title="HTTP 处理大文件传输"></a>HTTP 处理大文件传输</h3><p>采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分</p><p>服务端发送：</p><p>添加上 Accept-Ranges:none 响应头，来告诉客户端这边年支持范围请求</p><p>客户端：</p><p>Range 字段拆解，客户端需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes&#x3D;x-y</p><p>Range 的书写格式：</p><pre><code class="hljs">0-499 表示从开始到第 499 个字节。500- 表示从第 500 字节到文件终点。-100 表示文件最后 100 个字节。</code></pre><p>服务端接收：</p><pre><code class="hljs">接受到请求之后，先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码同时服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同而又所差异</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// 单段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9<br>// 多段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9, 30-39<br></code></pre></td></tr></table></figure><h3 id="HTTP1-1解决HTTP队头阻塞问题"><a href="#HTTP1-1解决HTTP队头阻塞问题" class="headerlink" title="HTTP1.1解决HTTP队头阻塞问题"></a>HTTP1.1解决HTTP队头阻塞问题</h3><p>HTTP传输基于 请求-应答的模式进行，传输任务是放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p><h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>一个域名可以并发 6 个长连接，多分几个域名</p><p>这样一个 baidu.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>HTTP是无状态的协议，需要保存状态就引入了Cookie</p><p>Cookie 本身是浏览器里面存储的一个很小的本地文件，内部以键值对的方式存储。同一个域名下发送请求，都会携带相同的 Cookie ，服务器拿到 Cookie 进行解析，就可以拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 请求头<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>a=xxx;b=xxx<br>// 响应头<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>a=xxx<br><span class="hljs-attribute">set-Cookie</span><span class="hljs-punctuation">: </span>b=xxx<br></code></pre></td></tr></table></figure><h4 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h4><p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置</p><ul><li>Expires 即过期时间</li><li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算</li></ul><p>若Cookie过期，则这个Cookie会被删除，并不会发送给服务端</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域有两个属性：Domain和path，都给Cookie绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上Cookie。对于路径来说，&#x2F;表示域名下的任意路径都允许使用Cookie。</p><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果带上Secure，说明只能通过 HTTPS 传输 cookie。</p><p>如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p><p>CSRF攻击的预防可以通过SameSite属性。</p><p>SameSite 可以设置为三个值：Strict、Lax和None。</p><ol><li>在 Strict 模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>baidu.com</code>网站只能在<code>baidu.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</li><li>在 Lax 模式下，宽松一点，只能在 get 方法提交表单 或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li><li>在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ol><h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ol><li>容量缺陷 体积上限是 4kB</li><li>性能缺陷 Cookie紧跟域名，不管域名下面的某一个子域名需不需要这个 Cookie 请求都会携带上完整的Cookie，请求数量一多会照成巨大的性能浪费，可以通过 Domain 和 Path 指定作用域来解决。</li><li>安全缺陷，由于 Cookie 以纯文本的形式传递很容易被非法用户截获，然后进行一系列篡改，在Cookie的有效期内重新推送给服务器，在 HttpOnly 为 false 的情况下，Cookie信息能直接通过 JS 脚本来读取。</li></ol><h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><p>HTTP基于请求-响应模型的协议，一般由客户端发请求，服务器来响应</p><p>如果有代理服务器，引入代理之后，作为代理的服务器相当与一个中间人的角色，对于客户端表现为服务器进行响应，对于源服务器表现为客户端发起请求，具有双重身份。</p><h4 id="HTTP-代理的功能"><a href="#HTTP-代理的功能" class="headerlink" title="HTTP 代理的功能"></a>HTTP 代理的功能</h4><ol><li><strong>负载均衡</strong>： <ol><li>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li></ol></li><li><strong>保障安全:</strong> <ol><li>利用心跳机制监控后台服务器，一旦发现故障机就将其踢出集群，并且对于上下行的数据进行过滤，对于非法IP限流，这些都是代理服务器的工作</li></ol></li><li><strong>缓存代理：</strong> <ol><li>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得，而不用到的源服务器那里获得。</li></ol></li></ol><h4 id="相关头字段"><a href="#相关头字段" class="headerlink" title="相关头字段"></a>相关头字段</h4><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><pre><code class="hljs">代理服务器通过 Via 字段在 HTTP 传输中留下自己的痕迹Via中的代理的顺序即为在 HTTP 传输中报文传达的顺序</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器<br>// 源服务器收到请求后，请求头<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>proxy_server1,proxy_server2<br>// 源服务器响应时候，客户端的响应头<br>Via:proxy_server2,proxr_server1<br></code></pre></td></tr></table></figure><h5 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h5><pre><code class="hljs">为谁转发，记录的是请求方的IP地址</code></pre><h5 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h5><pre><code class="hljs">获取用户真实IP的字段，不管中间经过了多少代理，这个字段始终记录最初客户端的IP对应的有 **X-Forwarded-Host** 和 **X-forwarded-Proto**，分别记录客户端(不包括代理)的域名和协议名</code></pre><h5 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h5><pre><code class="hljs">此字段是记录请求方的IP，意味着每经过一个不同的代理，这个字段的名字都要改变，从客户端到代理1，这个字段是客户端的IP，从代理1到代理2，这个字段变成了代理1的IP</code></pre><p>意味着会产生两个问题：</p><ol><li>代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降</li><li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的</li></ol><p>由此产生了 <strong>代理协议</strong> ，一般使用明文版本，只需要在HTTP请求行上面加上这样格式的文本即可:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接受端口<br>PREOXY TCP4 0.0.0.1 0.0.0.2 1111 2222<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以解决X-Forwarded-For产生的问题</p><h3 id="HTTP缓存及缓存代理"><a href="#HTTP缓存及缓存代理" class="headerlink" title="HTTP缓存及缓存代理"></a>HTTP缓存及缓存代理</h3><h4 id="关于-强缓存-和-协商缓存"><a href="#关于-强缓存-和-协商缓存" class="headerlink" title="关于 强缓存 和 协商缓存"></a>关于 <strong>强缓存</strong> 和 <strong>协商缓存</strong></h4><p>首先通过 Cache-Control 验证强缓存是否可用</p><ul><li>如果强缓存可用，直接使用</li><li>否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新 <ul><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存中获取资源</li></ul></li></ul><h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><p>对于服务器来说，也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的</p><p>由此引入了缓存代理的机制，让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候就能明显降低源服务器的压力</p><h5 id="代理缓存的实现："><a href="#代理缓存的实现：" class="headerlink" title="代理缓存的实现："></a>代理缓存的实现：</h5><ul><li>代理缓存的控制分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制</li></ul><h6 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h6><p><strong>private 和 public</strong></p><p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入priivate或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。</p><p>对于一些比较私密的数据，如果缓存到代理服务器上，比如直接访问代理就可以直接拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头的Cache-Control设为private，而不是public</p><p><strong>proxy-revalidate</strong></p><p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取</p><p><strong>s-maxage</strong></p><p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:public,max-age=1000,s-maxage=2000<br></code></pre></td></tr></table></figure><p>相当于源服务器说：我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理服务器中拿，并且客户端的缓存时间为1000秒，在代理服务器中的缓存时间为2000秒</p><h6 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h6><h6 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h6><p>在客户端的请求头中，可以加入两个字段，来对代理服务器上的缓存进行宽容和限制的操作</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">max-stale:5<br></code></pre></td></tr></table></figure><p>表示客户端到代理服务器上那缓存的时候，即使缓存过期了也不要紧，只要在过期时间在5秒之内，还可以从代理中获取的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">min-fresh:5<br></code></pre></td></tr></table></figure><p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前5秒之前的时间拿，否则拿不到</p><h6 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h6><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>因为浏览器遵循同源政策(协议、主机和端口都相同则为同源)。非同源站点有这样一些限制:</p><ul><li>不能读取和修改对方的DOM</li><li>不能访问对方的Cookie、IndexDb和LocalStorage</li><li>限制XMLHttpRequest请求。</li></ul><p>当浏览器向着目标URI发出Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被称为跨域请求。</p><p>跨域请求的响应会被浏览器所拦截，响应是成功到达客户端了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>跨域资源共享</p><p>它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头</p><p><strong>简单请求</strong></p><ul><li>请求方法为GET、POST或者HEAD </li><li>请求头的取值范围：Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain) </li><li>简单请求跨域处理 <ul><li><p>请求发出去前，在请求头中添加一个Origin字段，说明请求来自于哪个源。服务器拿到请求之后，在回应时对应地添加<strong>Access-Control-Allow-Origin</strong>字段，如果Origin不在这个字段范围内，浏览器就会将响应拦截。 </p></li><li><p><strong>Access-Control-Allow-Credentials</strong> 字段 是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器这个字段默认值设为false，如果需要拿到浏览器的Cookie，添加此字段并设置为true，并且在前端也需要设置withCredentials属性：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>Access-Control-Expose-Headers</strong> 这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）还能拿到这个字段生命的响应头字段，例子：</p></li></ul></li></ul><p>前端可以通过XMLHttpRequest.getResponseHeader(‘aaa’)拿到 aaa这个字段的值。 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: aaa<br></code></pre></td></tr></table></figure><p><strong>非简单请求</strong></p><ul><li>除简单请求之外的请求都是非简单请求 </li><li>浏览器以及跨域处理 <ul><li>预检请求和响应字段 <ul><li>发送非简单请求之前要先发送预检请求<br>预检请求的方法是OPTIONS，同时加上Origin源地址和Host目标地址，同时也加上两个关键字段 <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>当前地址<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><ul><li>Access-Control-Request-Method，列出请求用到哪个HTTP方法</li><li>Access-Control-Request-Headers，指定CORS请求将要加上什么请求头</li><li>响应字段 </li><li>预检查的响应</li></ul></li></ul></li></ul></li></ul><p><strong>Access-Control-Allow-Origin</strong>: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。<br><strong>Access-Control-Allow-Methods</strong>: 表示允许的请求方法列表。<br><strong>Access-Control-Allow-Credentials</strong>: 简单请求中已经介绍。<br><strong>Access-Control-Allow-Headers</strong>: 表示允许发送的请求头字段<br><strong>Access-Control-Max-Age</strong>: 预检请求的有效期，在此期间，不用发出另外一条预检请求。<br>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS请求</strong>也不会发出去了。 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br></code></pre></td></tr></table></figure><pre><code class="hljs">     -  CORS的响应         - 现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。</code></pre><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">jsonp</span> = (<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateURL</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;<br>    &#125;<br>    dataStr += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化回调函数名称</span><br>    callbackName = callbackName || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-property">toString</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <br>    <span class="hljs-comment">// 创建 script 元素并加入到当前文档中</span><br>    <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    scriptEle.<span class="hljs-property">src</span> = <span class="hljs-title function_">generateURL</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(scriptEle);<br>    <span class="hljs-comment">// 绑定到 window 上，为了后面调用</span><br>    <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>      <span class="hljs-comment">// script 执行完了，成为无用元素，需要清除</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(scriptEle);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; a, b, callback &#125; = req.<span class="hljs-property">query</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 2</span><br>  <span class="hljs-comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>前端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 拿到数据进行处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 数据包</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>Nginx反向代理<br><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network02.png" alt="image.png"></p><p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p><p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p><p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p><p>解决跨域：</p><p>例子：客户端域名为client.con，服务器域名为server.com</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server &#123;<br>  listen  <span class="hljs-number">80</span>;<br>  server_name  client.<span class="hljs-property">com</span>;<br>  location /api &#123;<br>    proxy_pass server.<span class="hljs-property">com</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手其实就是建立一个TCP连接时，需要客户端和服务器总共发3个包。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>SYN（Synchronize同步的缩写）表示建立连接</p><p>ACK （acknowledge character 确认字符的缩写）表示响应</p><p>具体过程：</p><p>刚开始客户端处于Closed的状态，服务端处于Listen状态。进行三次握手</p><ul><li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND（同步已发送）状态。 <ul><li>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</li></ul></li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的SYN报文作为答应，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN（初始序列号seq）+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD（同步收到）的状态。 <ul><li>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</li></ul></li><li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED（已建立连接）状态。服务器收到ACK报文之后，也处于ESTABLISHED（已建立连接）状态，此时，双方已建立起了连接。 <ul><li>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号</li></ul></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在 socket 编程中，客户端执行 connect() 时，将触发三次握手</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network03.png" alt="image.png"></p><h4 id="半连接队列-x2F-全连接队列"><a href="#半连接队列-x2F-全连接队列" class="headerlink" title="半连接队列&#x2F;全连接队列"></a>半连接队列&#x2F;全连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong></p><p>就是已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ol><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network04.png" alt="image.png"></p><p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p><blockquote><p>LISTEN - 侦听来自远方TCP端口的连接请求；</p></blockquote><blockquote><p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p></blockquote><blockquote><p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p></blockquote><blockquote><p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p></blockquote><blockquote><p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><blockquote><p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p></blockquote><blockquote><p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p></blockquote><blockquote><p>CLOSING -等待远程TCP对连接中断的确认；</p></blockquote><blockquote><p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><blockquote><p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><blockquote><p>CLOSED - 没有任何连接状态；</p></blockquote><h3 id="HTTP-x2F-2的改进"><a href="#HTTP-x2F-2的改进" class="headerlink" title="HTTP&#x2F;2的改进"></a>HTTP&#x2F;2的改进</h3><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>在HTTP&#x2F;1.1及以前的时代，请求头一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，如果请求字段非常复杂的时候，尤其是GET请求，请求报文几乎全是请求头，这个时候优化空间很大，</p><p>而HTTP&#x2F;2针对头部字段，采用了对应的压缩算法-HPACK，对请求头进行压缩。</p><p>HPACK算法的两个亮点</p><ul><li>首先是在服务端和客户端之前建立哈希表，将用到的字段存放在这张表中，那么在传输的时候，对于之前出现过的值，只需要传递索引给对方即可，对方拿到索引查表就可以了</li><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network05.png" alt="image.png"></p><p>HTTP&#x2F;2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><h6 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h6><p>根本原因是HTTP基于<code>请求-响应</code>的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞</p><p>虽然<code>并发连接</code>和<code>域名分片</code>的方式来解决这个问题，但是并没有真正从HTTP本身的层面解决问题，只是增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争 <strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理</p><p>HTTP&#x2F;2从HTTP协议本身解决了<code>队头阻塞</code>问题。这里指的并不是<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code></p><ul><li>TCP队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给HTTP</li><li>HTTP队头阻塞是在HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住</li></ul><p><strong>HTTP&#x2F;2解决队头阻塞</strong></p><ol><li>二进制分帧 <ol><li>首先，HTTP&#x2F;2认为明文传输对机器而言解析太麻烦，因为文本有很多多义性的字符串，比如回车换行到底是内容还是分隔符号，在内部需要用到状态机去识别，效率很低，于是HTTP&#x2F;2把报文全部换成二进制格式，全部传输01串，方便了机器的解析</li><li>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据，分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也不会排队等待，也就没有了HTTP的队头阻塞问题</li><li>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫<code>流(Stream)</code>HTTP&#x2F;2用<code>流</code>来在一个TCP连接上进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念</li><li>乱序首发，乱序是指不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按照顺序传输的，二进制帧到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他的字段，实现了 <strong>优先级</strong>和 <strong>流量控制</strong> 等功能。</li></ol></li></ol><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>在HTTP&#x2F;2中，服务器不再是完全被动地接受请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如：在浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP&#x2F;2完全兼容HTTP的语法和语义</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network06.png" alt="image.png"></p><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>设置请求优先级</li><li>服务器推送</li></ul><h4 id="二进制帧的设计"><a href="#二进制帧的设计" class="headerlink" title="二进制帧的设计"></a>二进制帧的设计</h4><h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><p>HTTP&#x2F;2中传输的帧结构如下图</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network07.png" alt="image.png"></p><p>每个帧分为帧头和帧体。显示三个字节的帧长度，这个长度表示的是帧体的长度。</p><p>然后是帧的类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧存放HTTP报文，控制帧管理<code>流</code>的传输。</p><p>接下来的第一个字节是<strong>帧标志</strong>，这里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束</p><p>后4个字节是Stream ID，也就是流标识符，有了它，接收方就能从乱序的二进制帧中选出 ID 相同的帧，然后按照顺序组装成请求&#x2F;响应报文</p><h5 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h5><p>根据帧的标志位来实现具体的状态改变。</p><p>例子：普通的请求-响应过程</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network08.png" alt="image.png"></p><ul><li>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</li><li>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</li><li>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</li><li>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个</li></ul><h5 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h5><ul><li>并发性，一个HTTP&#x2F;2连接上可以同时发多个帧，这一点和HTTP&#x2F;1不同，这也是实现多路复用的基础</li><li>自增性，流 ID 是不可重用的，会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li><li>双向性，客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</li><li>可以设置优先级，可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/</url>
    
    <content type="html"><![CDATA[<h1 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h1><p><code>Vue</code> 实例化过程，<code>Vue</code> 为一个构造函数，传入的参数是一个对象，可称之为 <code>options</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就是初始化 Vue 工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-comment">// Vue 就是一个构造函数 通过 new 关键字 进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 进行 Vue 初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init 方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载，需要传入 Vue 对象</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure><p>initMixin 把 _init 方法挂载在 Vue 原型 供 Vue 实例调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">import</span> &#123; observe &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./observer/index.js&quot;</span>;<br><span class="hljs-comment">// 初始化状态</span><br><span class="hljs-comment">// 初始化的顺序依次是 prop &gt; methods &gt; data &gt; watch</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-title function_">initProps</span>(vm)  <br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) &#123;<br>    <span class="hljs-title function_">initMethod</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) &#123;<br>    <span class="hljs-title function_">initComputed</span>(vm);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 data 数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 实例的_data熟悉就是传入的data</span><br>  <span class="hljs-comment">// vue 组件的 data 之所以要使用函数，是为了私有化数据，js 只有函数作用域</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span> ? data.<span class="hljs-title function_">call</span>(vm) : data || &#123;&#125;;<br>  <br>  <span class="hljs-comment">// 把 data 数据代理到 vm 也就是 Vue实例上面 我们可以使用this.a 来访问 this._data.a</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>  &#125;<br>  <span class="hljs-comment">// 对数据进行观测 -- 响应式数据核心</span><br>  <span class="hljs-title function_">observe</span>(data);<br>&#125;<br><span class="hljs-comment">// 数据代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">object, sourceKey, key</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(object, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> object[sourceKey][key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      object[sourceKey][key] = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的数据劫持"><a href="#对象的数据劫持" class="headerlink" title="对象的数据劫持"></a>对象的数据劫持</h1><p>defineReactive 函数 主要使用<code>Object.defineProperty</code>来对数据 get 和 set 进行劫持 这里知道了为啥数据变动了会自动更新视图 -&gt; 可以在 set 里面去通知视图更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 对象上所有的属性依次进行观测</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> key = keys[i];<br>      <span class="hljs-keyword">let</span> value = data[key];<br>      <span class="hljs-title function_">defineReactive</span>(data, key, value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Object.defineProperty 数据劫持核心 兼容性在 ie9 及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, keym value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归</span><br>  <span class="hljs-comment">// 如果 value 还是对象就递归，直到 value 不是对象为止</span><br>  <span class="hljs-comment">// 如果 Vue 数据嵌套层级过深 会有性能影响</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取值&#x27;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置值&#x27;</span>);<br>      value = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 如果传过来的是对象或者数组，进行属性劫持</span><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ||<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的观测"><a href="#数组的观测" class="headerlink" title="数组的观测"></a>数组的观测</h1><p>数组元素过多，使用递归根据下标直接修改数据太消耗性能了，不可能为每个元素下标都添加 get 和 set 方法。<br />所以通过重写数组原型方法来对数组的七种方法进行拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>     <span class="hljs-comment">// 通过重写数组原型方法来对数组的七种方法进行拦截</span><br>     value.<span class="hljs-property">__proto__</span> = arrayMethods;<br>     <span class="hljs-comment">// 如果数组里面还包含数组 需要递归判断</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>   &#125;<br> &#125;<br>  <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">observe</span>(items[i])  <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这段代码给每个响应式数据增加了一个不可枚举的__ob__属性 并且指向了 Observer 实例 那么我们首先可以根据这个属性来防止已经被响应式观察的数据反复被观测 其次 响应式数据可以使用__ob__来获取 Observer 实例的相关方法 这对数组很关键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, &#123;<br>      <span class="hljs-comment">// 值指 Observer 的实例</span><br>      <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,<br>      <span class="hljs-comment">// 不可枚举</span><br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/array.js</span><br><span class="hljs-comment">// 先保留数据原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 然后将 arrayMethods 继承自数组原型</span><br><span class="hljs-comment">// 这里是面向切片编程思想（AOP）：不破坏封装的前提下，动态扩展功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-keyword">let</span> methodsToPath = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>];<br>methodsToPath.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-comment">// 这里的标志就是代表数组有新增操作</span><br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<br>    <span class="hljs-comment">// 在这里就可以检测到数据变化了</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p><code>**Object.defineProperty(obj, prop, descriptor)**</code>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><ul><li>obj：要定义属性的对象</li><li>prop：要定义或修改的 属性名称 或 Symbol</li><li>descriptor：要定义或修改的 属性描述符</li></ul><h3 id="本身的限制"><a href="#本身的限制" class="headerlink" title="本身的限制"></a>本身的限制</h3><ul><li>目标只是对象的属性，而不是整个对象</li><li>一次只能 定义或者修改一个属性</li></ul><h3 id="在-Vue2-中的缺陷"><a href="#在-Vue2-中的缺陷" class="headerlink" title="在 Vue2 中的缺陷"></a>在 Vue2 中的缺陷</h3><ul><li>只能拦截对象属性的<code>get</code>和<code>set</code>操作，比如无法拦截<code>delete</code>、<code>in</code>、<code>方法调用</code>等操作</li><li>动态添加新属性（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新属性</li></ul></li><li>通过<code>delete</code>删除属性（响应式丢失）<ul><li>使用<code>this.$delete()</code>删除属性</li></ul></li><li>使用数组索引 <code>替换/新增</code>元素（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新元素</li></ul></li><li>使用数组<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>等原生方法改变原数组时（响应式丢失）<ul><li>使用重写后<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>方法</li></ul></li><li>一次只能对一个属性实现 数据劫持，需要遍历对所有属性进行劫持</li><li>数据结构复杂时（属性值为 引用类型数据），需要通过 递归 进行处理</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>**Proxy**</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><code>new Proxy(target, handler)</code>针对整个对象进行代理</li><li>代理对象的属性拥有读取、修改、删除、新增、是否存在属性，等相应的捕捉器<ul><li><code>get()</code>：<code>读取</code>操作的捕捉器</li><li><code>get()</code>：<code>设置</code>操作的捕捉器</li><li><code>deleteProperty()</code>：<code>删除</code>操作的捕捉器</li><li><code>ownKeys()</code>：<code>Object.getOwnPropertyNames</code>方法和<code>Object.getOwnPropertySymbols</code>方法的捕捉器</li><li><code>has()</code>：<code>in</code>操作符的捕捉器</li></ul></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>**Reflect**</code>是一个内置的对象，它提供拦截 <code>**JavaScript**</code> 操作的方法，这些方法与 <code>Proxy handlers</code> 提供的的方法是一一对应的，且 <code>**Reflect**</code> 不是一个函数对象，即不能进行实例化，其所有属性和方法都是静态的（就像是<code>Math</code>对象）。</p><ul><li><code>Reflect.get(target, propertyKey[, receiver]) </code>获取对象身上某个属性的值，类似于 <code>target[name]</code></li><li><code>Reflect.set(target, propertyKey, value[, receiver]) </code>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code></li><li><code>Reflect.deleteProperty(target, propertyKey) </code>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code></li><li><code>Reflect.ownKeys(target) </code>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code> 影响)</li><li><code>Reflect.has(target, propertyKey) </code>判断一个对象是否存在某个属性，和<code>in</code>运算符 的功能完全相同</li></ul><h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span></span>) &#123;<br><span class="hljs-comment">// 若目标对象是响应式的只读对象，则直接返回</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isReadonly</span>(target)) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 否则将目标数据尝试变成响应式数据</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createdReactiveObject</span>(<br>    target,<br>    <span class="hljs-literal">false</span>,<br>    mutableHandlers, <span class="hljs-comment">// 对象类型的 handlers</span><br>    mutableCollectionHandlers, <span class="hljs-comment">// 集合类型的 handlers</span><br>    reacitveMap<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject()"></a>createReactiveObject()</h3><p>主要是做前置处理</p><ul><li>目标数据为 原始值类型，返回 原数据</li><li>目标数据的<code>__v_raw</code>属性为<code>true</code>，且是非响应式数据，或 不是通过调用<code>readonly()</code>方法，则直接返回原数据</li><li>目标数据已存在相应的<code>proxy</code>代理对象，则直接返回代理对象</li><li>目标数据不存在对应的 白名单数据类型中，则直接返回原数据，支持响应式的数据类型如下<ul><li>可扩展的对象（是否可以先加新属性）</li><li><code>__v_skip</code>属性不存在或者值为 false 的对象</li><li>数据类型为<code>Object</code>，<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>WeakMap</code>，<code>WeakSet</code>的对象</li><li>其他数据都统一被认为是无效的响应式数据对象</li></ul></li><li>通过<code>Proxy</code>创建代理对象，根据目标数据类型选择不同的<code>Proxy handlers</code>（捕获器）</li></ul><p>具体的实现在对应数据类型的 捕获器 中，即下面源码中的<code>collectionHandlers</code>和<code>baseHandlers</code>，而它们则对应的是上述<code>reactive()</code>函数中的<code>createReactiveObject()</code>函数传递的<code>mutableCollectionHandlers</code>和<code>mutableHandlers</code>参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: Target,</span><br><span class="hljs-params">  isReadonly: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  baseHanlders: ProxyHandle&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  collectionHandlers: ProxyHandler&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  proxyMap: <span class="hljs-built_in">WeakMap</span>&lt;Target, <span class="hljs-built_in">any</span>&gt;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 非对象类型直接返回</span><br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>    <span class="hljs-keyword">if</span>(__DEV__) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`value cannot be made reactive: <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(target)&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 目标数据的 __v_raw 属性若为 true，且是【非响应式数据】或 不是通过调用 readonly() 方法，则直接返回</span><br>  <span class="hljs-keyword">if</span> (<br>    target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span>] &amp;&amp;<br>    !(isReadonly &amp;&amp; target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>])<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br><br>  <span class="hljs-comment">// 目标对象已存在相应的 proxy 代理对象，则直接返回</span><br>  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>    <span class="hljs-keyword">return</span> existingProxy<br>  &#125;<br>  <br><span class="hljs-comment">// 只有在白名单中的值类型才可以被代理监测，否则直接返回</span><br>  <span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)<br>  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>) &#123;<br>    <span class="hljs-keyword">return</span> target     <br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建代理对象</span><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<br>    target,<br>    <span class="hljs-comment">// 若目标对象是集合类型（Set、Map）则使用集合类型对应的捕获器，否则使用基础捕获器</span><br>    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers <br>  )<br><br>  <span class="hljs-comment">// 将对应的代理对象存储在 proxyMap 中</span><br>  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捕获器-Handles"><a href="#捕获器-Handles" class="headerlink" title="捕获器 Handles"></a>捕获器 Handles</h3><h4 id="对象类型（Object类型不包括Array）的捕获器-mutableHandlers"><a href="#对象类型（Object类型不包括Array）的捕获器-mutableHandlers" class="headerlink" title="对象类型（Object类型不包括Array）的捕获器 mutableHandlers"></a>对象类型（Object类型不包括Array）的捕获器 <code>mutableHandlers</code></h4><p><code>baseHandles.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">mutableHandlers</span>: <span class="hljs-title class_">ProxyHandle</span>&lt;<span class="hljs-built_in">object</span>&gt; = &#123;<br>  get,<br>  set,<br>  deleteProperty,<br>  has,<br>  ownKeys,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get-捕获器"><a href="#get-捕获器" class="headerlink" title="get 捕获器"></a>get 捕获器</h5><ul><li>当前数据对象为 数组，重写 数组对应方法</li><li>当前数据对象为普通对象，且非 只读 的则通过<code>track(target, TrackOptypes.GET, key)</code>进行依赖收集<ul><li>当前数据对象为浅层响应，直接返回其对应的属性值</li><li>当前数据对象为 ref 类型，自动脱 ref</li></ul></li><li>当前数据对象属性值是对象类型<ul><li>当前数据对象为 只读的，则通过 <code>readonly(res)</code>向外返回其结果</li><li>否则将当前属性值以<code>reactive(res)</code>向外返回 proxy 代理对象</li></ul></li><li>否则直接向外返回对应的 属性值 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span>, shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target: Target, key: <span class="hljs-built_in">string</span> | sysbol, receiver: <span class="hljs-built_in">object</span></span>) &#123;<br>    <span class="hljs-comment">// 当直接通过指定 key 访问 vue 内置自定义的对象属性时，返回其对应的值</span><br>    <span class="hljs-keyword">if</span>(key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) &#123;<br>      <span class="hljs-keyword">return</span> !isReadonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_READONLY</span>) &#123;<br>      <span class="hljs-keyword">return</span> isRedaonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFLags</span>.<span class="hljs-property">IS_SHALLOW</span>) &#123;<br>      <span class="hljs-keyword">return</span> shallow<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span> &amp;&amp;<br>      receiver ===<br>        (<br>          isReadonly<br>            ? shallow<br>              ? shallowReadonlyMap<br>              : readonlyMap<br>            : shallow<br>            ? shallowReactiveMap<br>            : reactiveMap<br>        ).<span class="hljs-title function_">get</span>(target)<br>    ) &#123;<br>      <span class="hljs-keyword">return</span> target<br>    &#125;<br>     <span class="hljs-comment">// 判断是否为数组类型</span><br>    <span class="hljs-keyword">const</span> targetIsArray = <span class="hljs-title function_">isArray</span>(target)<br><br>    <span class="hljs-comment">// 数组对象</span><br>    <span class="hljs-keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="hljs-title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;<br>      <span class="hljs-comment">// 重写/增强数组的方法： </span><br>      <span class="hljs-comment">//  - 查找方法：includes、indexOf、lastIndexOf</span><br>      <span class="hljs-comment">//  - 修改原数组的方法：push、pop、unshift、shift、splice</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)<br>    &#125;<br>    <span class="hljs-comment">// 获取对应属性值</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSymbol</span>(key) ? builtInSymbols.<span class="hljs-title function_">has</span>(key) : <span class="hljs-title function_">isNonTrackableKeys</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// 依赖收集</span><br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 浅层响应</span><br>    <span class="hljs-keyword">if</span> (shallow) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 若是 ref 类型响应式数据，会进行【自动脱 ref】，但不支持【数组】+【索引】的访问方式</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(res)) &#123;<br>      <span class="hljs-keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="hljs-title function_">isIntegerKey</span>(key)<br>      <span class="hljs-keyword">return</span> shouldUnwrap ? res.<span class="hljs-property">value</span> : res<br>    &#125;<br>    <span class="hljs-comment">// 属性值是对象类型：</span><br>    <span class="hljs-comment">//  - 是只读属性，则通过 readonly() 返回结果，</span><br>    <span class="hljs-comment">//  - 且是非只读属性，则递归调用 reactive 向外返回 proxy 代理对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(res)) &#123;<br>      <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="set捕获器"><a href="#set捕获器" class="headerlink" title="set捕获器"></a><code>set</code>捕获器</h5><p>边界值处理，以及<strong>更新属性值，并通过</strong><code>**targger()**</code>触发依赖更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span><br><span class="hljs-params">    value: <span class="hljs-built_in">unknown</span>,</span><br><span class="hljs-params">    receiver: <span class="hljs-built_in">object</span></span><br><span class="hljs-params">  </span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-comment">// 保存旧的数据</span><br>    <span class="hljs-keyword">let</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br><br>    <span class="hljs-comment">// 若原数据值属于 只读 且 ref 类型，并且新数据值不属于 ref 类型，则意味着修改失败</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!shallow &amp;&amp; !<span class="hljs-title function_">isReadonly</span>(value)) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isShallow</span>(value)) &#123;<br>        value = <span class="hljs-title function_">toRaw</span>(value)<br>        oldValue = <span class="hljs-title function_">toRaw</span>(oldValue)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>        oldValue.<span class="hljs-property">value</span> = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// in shallow mode, objects are set as-is regardless of reactive or not</span><br>    &#125;<br><br>    <span class="hljs-comment">// 是否存在对应的 key</span><br>    <span class="hljs-keyword">const</span> hadKey =<br>      <span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isIntegerKey</span>(key)<br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span><br>        : <span class="hljs-title function_">hasOwn</span>(target, key)<br><br>    <span class="hljs-comment">// 设置对应值</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br><br>    <span class="hljs-comment">// 若目标对象是原始原型链上的内容（非自定义添加），则不触发依赖更新</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-title function_">toRaw</span>(receiver)) &#123;<br>      <span class="hljs-keyword">if</span> (!hadKey) &#123;<br>        <span class="hljs-comment">// 目标对象不存在对应的 key，则为新增操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>, key, value)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(value, oldValue)) &#123;<br>        <span class="hljs-comment">// 目标对象存在对应的值，则为修改操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>, key, value, oldValue)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回修改结果</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="deleteProperty-amp-has-amp-ownKeys-捕获器"><a href="#deleteProperty-amp-has-amp-ownKeys-捕获器" class="headerlink" title="deleteProperty &amp; has &amp; ownKeys 捕获器"></a><code>deleteProperty</code> &amp; <code>has</code> &amp; <code>ownKeys</code> 捕获器</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> hadKty = <span class="hljs-title function_">hasOwn</span>(target, key)<br>  <span class="hljs-keyword">const</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>  <span class="hljs-comment">// 目标对象存在对应的 key，并且成功删除，才会触发依赖更新</span><br>  <span class="hljs-keyword">if</span> (result &amp;&amp; hadKey) &#123;<br>    <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">DELETE</span>, key, <span class="hljs-literal">undefined</span>, oldValue)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">has</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key)<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSymbol</span>(key) || !builtInSymbols.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">HAS</span>, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span></span>): (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>)[] &#123;<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">ITERATE</span>, <span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">&#x27;length&#x27;</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">REflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="数组类型捕获器-arrayInstrumentations"><a href="#数组类型捕获器-arrayInstrumentations" class="headerlink" title="数组类型捕获器 arrayInstrumentations"></a>数组类型捕获器 <code>arrayInstrumentations</code></h5><p>数组由于<code>index</code>和<code>length</code>会相互影响，所以需要特殊处理</p><ul><li><code>arr[1] = 2</code>会隐式修改<code>length</code>的属性值</li><li><code>arr.lenght = 0</code>会导致原索引位置的值发生变更</li></ul><p>为了能够合理触发和 <code>length</code> 相关副作用函数的执行，在 <code>set()</code> 捕获器中会判断当前操作的类型：</p><ul><li>当<code>Number(key) &lt; target.length</code>证明是修改操作，对应<code>TriggerOptypes.SET</code>类型，即当前操作不会改变<code>length</code>的值，不需要 触发和 <code>length</code>有关副作用函数的执行</li><li>当<code>Number(key) &gt;= target.length</code>证明是新增操作，<code>TriggerOpTypes.ADD</code>类型，即当前操作会改变<code>length</code>的值，需要触发和<code>length</code>相关副作用函数的执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误页面处理</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="error-vue"><a href="#error-vue" class="headerlink" title="error.vue"></a>error.vue</h1><p><code>error.vue</code>必须与项目入口文件<code>app.vue</code>在同级别目录下<br><code>error.vue</code>接受了一个<code>error</code>的<code>props</code></p><h2 id="定制处理"><a href="#定制处理" class="headerlink" title="定制处理"></a>定制处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ErrorPage<br>  :errCode=&quot;error.statusCode&quot;<br>  &gt;<br>  &lt;/ErrorPage&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br><br>const props = defineProps(&#123;<br>  error: Object<br>&#125;)<br>if(props.error.statusCode === 500 &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123;<br>  // 此处可以记录错误日志<br>  useRecordErrorLog(props.error)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>ErrorPage</code>组件为根据错误码定制的页面</p><h2 id="错误日志收集"><a href="#错误日志收集" class="headerlink" title="错误日志收集"></a>错误日志收集</h2><p>存储到项目根目录下的<code>logs/error.log</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> winston <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;winston&#x27;</span>;<br><br><span class="hljs-keyword">const</span> logger = winston.<span class="hljs-title function_">createLogger</span>(&#123;<br>  <span class="hljs-attr">transports</span>: [<br>    <span class="hljs-keyword">new</span> winston.<span class="hljs-property">transports</span>.<span class="hljs-title class_">File</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;logs/error.log&#x27;</span>,<br>      <span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">format</span>: winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">combine</span>(<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">timestamp</span>(&#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;YYYY-MM-DDTHH:mm:ss.SSSZ&#x27;</span> &#125;),<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">json</span>(),<br>      )<br>    &#125;)<br>  ]<br>&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRecordErrorLog</span> = (<span class="hljs-params">error</span>) =&gt; &#123;<br>  logger.<span class="hljs-title function_">error</span>(error)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useRecordErrorLog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/02.HTTPS/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/02.HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong><br><strong>HTTP 明文传输，不安全</strong><br><strong>利用 HTTP 传输数据，利用 SSL&#x2F;TLS 加密数据包</strong></p><h2 id="密码学概念"><a href="#密码学概念" class="headerlink" title="密码学概念"></a>密码学概念</h2><p><strong>明文</strong>：明文指的是未被加密过的原始数据。<br><strong>密文</strong>：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。<br><strong>密钥</strong>：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><p><strong>对称加密（私钥加密）：</strong> 信息的发送方和接收方使用同一个密钥去加密和解密数据。<br>其加密过程如下：<strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文</strong><br>解密过程如下： <strong>密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong><br><strong>优点：</strong>加密和解密速度快，适合于对大数据量进行加密 。<br><strong>缺点：</strong>算法公开， 一旦私钥被泄露，那么密文就很容易被破解  ，密钥安全管理困难  </p><p><strong>非对称加密（公钥加密）：</strong>使用一对密钥（公钥和私钥），服务端保存私钥，客户端保存公钥。私钥不能对外泄漏。公钥任何客户端都可以获取到，用公钥或者私钥中的任何一个进行加密，用另一个进行解密。<br>被公钥加密过的密文只能被私钥解密，过程如下：<br><strong>明文 + 加密算法 + 公钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong><br>被私钥加密过的密文只能被公钥解密，过程如下：<br><strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 公钥 &#x3D;&gt; 明文</strong><br><strong>优点：</strong>安全性高（得不到私钥就无法解密）<br><strong>缺点：</strong>算法公开，加密和解密花费时间长、速度慢，只适合对少量数据进行加密。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><strong>SSL</strong>（Secure Sockets Layer）安全套接层和** TLS<strong>（Transport Layer Security）传输层安全协议其实是</strong>一套东西<strong>。</strong>HTTPS** 需要使用一套 <strong>CA 数字证书，</strong>证书附带了一个<strong>公钥Pub，</strong>与之对应的**私钥 Private **保留在服务端不公开。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>用户在浏览器发起 HTTPS 请求，默认使用服务端的443端口进行连接</li><li>服务端收到请求，返回配置好的包含<strong>公钥Pub的</strong>数字证书返回给客户端</li><li>客户端收到<strong>证书，</strong>校验合法性，主要是：是否在有效期内、证书的域名与请求的域名是否匹配， 上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；  </li><li>客户端生成一个用于对称加密的<strong>随机key</strong>，并用证书内的<strong>公钥Pub</strong>进行非对称加密，发送给服务端</li><li>服务端收到<strong>随机key</strong>的密文，使用与<strong>公钥Pub</strong>配对的<strong>私钥Private</strong>进行解密，得到<strong>随机key</strong>的明文</li><li>服务端使用客户端发送过来的<strong>随机key</strong>对要传输的HTTP数据进行对称加密（加密的私钥就是这个<strong>随机key</strong>），将密文返回给客户端</li><li>客户端使用<strong>随机key</strong>对称解密密文，得到HTTP数据明文</li><li>后续HTTPS请求使用之前交换好的<strong>随机Key</strong>进行对称加解密。<br><img src="/img/%E7%BD%91%E7%BB%9C/HTTPS/https01.png" alt="image.png"></li></ol><h1 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h1><h2 id="HTTPS-中间人攻击"><a href="#HTTPS-中间人攻击" class="headerlink" title="HTTPS 中间人攻击"></a>HTTPS 中间人攻击</h2><p>由于非对称加密的算法都是<strong>公开</strong>的，所有人都可以自己生成一对公钥私钥。<br>例子：<br>当服务端向客户端返回公钥 A1 的时候，<strong>中间人截获</strong>公钥 A1 将其<strong>替换</strong>成自己的公钥 B1 传送给浏览器。<br>此时浏览器拿到的是中间人的公钥 B1 加密了密钥 K 发送给服务端，<strong>再次被中间人截获，</strong>中间人利用自己的私钥 B2 解密，得到密钥 K 在使用之前截获到的公钥 A1 加密传送给服务端，完成了通信，而且服务端和客服的没有任何感知。<br>出现中间人攻击的核心原因就是：<strong>客户端无法确认收到的公钥是不是真的是服务端发来的</strong>。  </p><h2 id="CA-颁发机构"><a href="#CA-颁发机构" class="headerlink" title="CA 颁发机构"></a>CA 颁发机构</h2><p>数字证书颁发（CA）机构是受信任的第三方机构，颁发的数字证书为最终用户数据加密的公共密钥。在这个过程中，CA的责任是确保公司或用户接收一个唯一的证书是一个有效的身份的认证  。<br>（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）  </p><p>服务端在使用 HTTPS 前，去经过认证的 CA 机构申请颁发一份 <strong>数字证书，</strong>数字证书里面包含：证书持有者、证书有效期、公钥等明文信息和<strong>数字签名</strong>，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致以及数字签名一致后再进行后续的加密操作。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>防伪技术，验证数字证书是否被修改过<br>数字签名过程：</p><ul><li>CA机构在颁发证书时对证书明文信息进行<strong>哈希运算</strong>得到<strong>摘要</strong></li><li>将<strong>摘要</strong>用私钥进行<strong>加签（加密），</strong>得到<strong>数字签名</strong></li></ul><h3 id="校验数字证书"><a href="#校验数字证书" class="headerlink" title="校验数字证书"></a>校验数字证书</h3><ul><li>客户端得到证书（明文信息和数字签名）， 用浏览器内置的 CA 机构的根证书校验证书有效性 ，有效才进行下一步</li><li>客户端对证书的明文信息进行<strong>哈希运算</strong>得到<strong>摘要1</strong></li><li>用公钥（<strong>内置的CA机构的公钥</strong>）进行<strong>解签（解密）</strong>，得到<strong>摘要2</strong>（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书（根证书）和公钥信息）</li><li>用证书里声明的哈希算法对明文Text部分进行哈希得到T</li><li>当自己计算得到的哈希值<strong>摘要1</strong>与解密服务端的数字签名得到的哈希值<strong>摘要2，相等</strong>，表示证书可信，<strong>没有被篡改，否则被篡改。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误页面处理</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="存储到项目根目录下的logs-error-log"><a href="#存储到项目根目录下的logs-error-log" class="headerlink" title="存储到项目根目录下的logs/error.log"></a>存储到项目根目录下的<code>logs/error.log</code></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> winston <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;winston&#x27;</span>;<br><br><span class="hljs-keyword">const</span> logger = winston.<span class="hljs-title function_">createLogger</span>(&#123;<br>  <span class="hljs-attr">transports</span>: [<br>    <span class="hljs-keyword">new</span> winston.<span class="hljs-property">transports</span>.<span class="hljs-title class_">File</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;logs/error.log&#x27;</span>,<br>      <span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">format</span>: winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">combine</span>(<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">timestamp</span>(&#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;YYYY-MM-DDTHH:mm:ss.SSSZ&#x27;</span> &#125;),<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">json</span>(),<br>      )<br>    &#125;)<br>  ]<br>&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRecordErrorLog</span> = (<span class="hljs-params">error</span>) =&gt; &#123;<br>  logger.<span class="hljs-title function_">error</span>(error)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useRecordErrorLog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航栏锚点</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="导航栏部分"><a href="#导航栏部分" class="headerlink" title="导航栏部分"></a>导航栏部分</h1><ol><li>利用<code>NuxtLink</code>组件实现跳转<ol><li>注意，如果要跳转到其他项目的地址，此时要给<code>link</code>前面拼接上<code>window.location.origin</code></li></ol></li><li><code>link</code>后添加上对应页面，对应锚点的<code>id</code>，此处可以用<code>#targetID</code>这种形式拼接</li></ol><h2 id="对应页面"><a href="#对应页面" class="headerlink" title="对应页面"></a>对应页面</h2><ol><li>每个锚点添加上<code>id=&quot;xxx&quot;</code></li><li>使用<code>useAnchor()</code></li></ol><h1 id="useAnchor实现"><a href="#useAnchor实现" class="headerlink" title="useAnchor实现"></a>useAnchor实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> targetId = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> targetElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(targetId);<br>    <span class="hljs-keyword">if</span> (targetElement) &#123;<br>      targetElement.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onMounted</span>(scrollToAnchor);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useAnchor;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加百度统计代码</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/04.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/04.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="设置单页面模式"><a href="#设置单页面模式" class="headerlink" title="设置单页面模式"></a>设置单页面模式</h1><ol><li>首先去百度统计PC端首页-&gt;使用规则-&gt;单页设置-&gt;启用单页应用数据统计</li><li>在项目入口文件<code>app.vue</code>引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-title function_">useHead</span>(&#123;<br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span><br>    &#125;<br>  ]<br>&#125;)<br><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (_hmt) &#123;<br>    _hmt.<span class="hljs-title function_">push</span>([<span class="hljs-string">&#x27;_trackPageview&#x27;</span>, route.<span class="hljs-property">path</span>])<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="不设置单页模式"><a href="#不设置单页模式" class="headerlink" title="不设置单页模式"></a>不设置单页模式</h2><ol><li>对应的每个页面引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useHead</span>(&#123;<br><br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span>,<br>      <span class="hljs-attr">bodyClose</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// false 添加到 head标签内</span><br>      <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">defer</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  ]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cdn 方案</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/05.cdn%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/05.cdn%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="基于vite打包"><a href="#基于vite打包" class="headerlink" title="基于vite打包"></a>基于vite打包</h1><h2 id="plugin编写"><a href="#plugin编写" class="headerlink" title="plugin编写"></a>plugin编写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> color = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;picocolors&#x27;</span>)<br><span class="hljs-keyword">const</span> glob  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OSS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ali-oss&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123;<span class="hljs-variable constant_">URL</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> &#123; normalizePath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vite&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">vitePluginAliOss</span> (options) &#123;<br>  <span class="hljs-keyword">let</span> baseConfig = <span class="hljs-string">&#x27;/&#x27;</span><br>  <span class="hljs-keyword">let</span> buildConfig = <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">enabled</span> !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &amp;&amp; !options.<span class="hljs-property">enabled</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vite-plugin-ali-oss&#x27;</span>,<br>    <span class="hljs-attr">enforce</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">apply</span>: <span class="hljs-string">&#x27;build&#x27;</span>,<br>    configResolved (config) &#123;<br>      baseConfig = <span class="hljs-string">&#x27;your oss static url &#x27;</span><br>      <span class="hljs-comment">//  baseConfig = config.base</span><br>      <span class="hljs-comment">//  此处base为相对路径，原因不明，暂时写死</span><br>      buildConfig = config.<span class="hljs-property">build</span><br>    &#125;,<br>    <span class="hljs-keyword">async</span> closeBundle () &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^http/i</span>.<span class="hljs-title function_">test</span>(baseConfig)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;[vite-plugin-ali-oss] base must be a url&#x27;</span>)<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> outDirPath = <span class="hljs-title function_">normalizePath</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">normalizePath</span>(buildConfig.<span class="hljs-property">outDir</span>)))<br><br>      <span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">pathname</span>: ossBasePath, <span class="hljs-attr">origin</span>: ossOrigin&#125; = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(baseConfig)<br><br>      <span class="hljs-keyword">const</span> createOssOption = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, options)<br>      <span class="hljs-keyword">delete</span> createOssOption.<span class="hljs-property">overwrite</span><br>      <span class="hljs-keyword">delete</span> createOssOption.<span class="hljs-property">ignore</span><br>      <span class="hljs-keyword">delete</span> createOssOption.<span class="hljs-property">headers</span><br>      <span class="hljs-keyword">delete</span> createOssOption.<span class="hljs-property">test</span><br>      <span class="hljs-keyword">delete</span> createOssOption.<span class="hljs-property">enabled</span><br><br>      <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title function_">OSS</span>(createOssOption)<br>      <span class="hljs-keyword">const</span> ssrClient = buildConfig.<span class="hljs-property">ssrManifest</span><br>      <span class="hljs-keyword">const</span> ssrServer = buildConfig.<span class="hljs-property">ssr</span><br><br>      <span class="hljs-keyword">const</span> files = <span class="hljs-keyword">await</span> glob.<span class="hljs-title function_">sync</span>(<br>        outDirPath + <span class="hljs-string">&#x27;/**/*&#x27;</span>,<br>        &#123;<br>          <span class="hljs-attr">strict</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">nodir</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">ignore</span>:<br>            <span class="hljs-comment">// custom ignore</span><br>            options.<span class="hljs-property">ignore</span> ? options.<span class="hljs-property">ignore</span> :<br>            <span class="hljs-comment">// ssr client ignore</span><br>            ssrClient ? [<span class="hljs-string">&#x27;**/ssr-manifest.json&#x27;</span>, <span class="hljs-string">&#x27;**/*.html&#x27;</span>] :<br>            <span class="hljs-comment">// ssr server ignore</span><br>            ssrServer ? [<span class="hljs-string">&#x27;**&#x27;</span>] :<br>            <span class="hljs-comment">// default ignore</span><br>            <span class="hljs-string">&#x27;**/*.html&#x27;</span><br>        &#125;<br>      )<br>      <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fileFullPath <span class="hljs-keyword">of</span> files) &#123;<br>        <span class="hljs-keyword">const</span> filePath = fileFullPath.<span class="hljs-title function_">split</span>(outDirPath)[<span class="hljs-number">1</span>] <span class="hljs-comment">// eg: &#x27;/assets/vendor.bfb92b77.js&#x27;</span><br><br>        <span class="hljs-keyword">const</span> ossFilePath = ossBasePath.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">&#x27;&#x27;</span>) + filePath <span class="hljs-comment">// eg: &#x27;/base/assets/vendor.bfb92b77.js&#x27;</span><br><br>        <span class="hljs-keyword">const</span> completePath = ossOrigin + ossFilePath <span class="hljs-comment">// eg: &#x27;https://foo.com/base/assets/vendor.bfb92b77.js&#x27;</span><br><br>        <span class="hljs-keyword">const</span> output = <span class="hljs-string">`<span class="hljs-subst">$&#123;buildConfig.outDir + filePath&#125;</span> =&gt; <span class="hljs-subst">$&#123;color.green(completePath)&#125;</span>`</span><br><br>        <span class="hljs-keyword">if</span> (options.<span class="hljs-property">test</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`test upload path: <span class="hljs-subst">$&#123;output&#125;</span>`</span>)<br>          <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (options.<span class="hljs-property">overwrite</span>) &#123;<br>          <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">put</span>(<br>            ossFilePath,<br>            fileFullPath,<br>            &#123;<br>              <span class="hljs-attr">headers</span>: options.<span class="hljs-property">headers</span> || &#123;&#125;<br>            &#125;<br>          )<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`upload complete: <span class="hljs-subst">$&#123;output&#125;</span>`</span>)<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">head</span>(ossFilePath);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;color.gray(<span class="hljs-string">&#x27;files exists&#x27;</span>)&#125;</span>: <span class="hljs-subst">$&#123;output&#125;</span>`</span>)<br><br>          &#125;  <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;NoSuchKey&#x27;</span>) &#123;<br>              <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">put</span>(<br>                ossFilePath,<br>                fileFullPath,<br>                &#123;<br>                  <span class="hljs-attr">headers</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(options.<span class="hljs-property">headers</span> || &#123;&#125;, &#123; <span class="hljs-string">&#x27;x-oss-forbid-overwrite&#x27;</span>: <span class="hljs-literal">true</span> &#125;)<br>                &#125;<br>              )<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`upload complete: <span class="hljs-subst">$&#123;output&#125;</span>`</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error)<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> duration = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - startTime) / <span class="hljs-number">1000</span><br><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ali oss upload complete ^_^, cost <span class="hljs-subst">$&#123;duration.toFixed(<span class="hljs-number">2</span>)&#125;</span>s`</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="nuxt-config-js"><a href="#nuxt-config-js" class="headerlink" title="nuxt.config.js"></a>nuxt.config.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> vitePluginAliOss <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vite-plugins/vite-plugin-ali-oss&#x27;</span><br><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">region</span>: <span class="hljs-string">&#x27;your region&#x27;</span>,<br>  <span class="hljs-attr">accessKeyId</span>: <span class="hljs-string">&#x27;your accessKeyId&#x27;</span>,<br>  <span class="hljs-attr">accessKeySecret</span>: <span class="hljs-string">&#x27;your accessKeySecret&#x27;</span>,<br>  <span class="hljs-attr">bucket</span>: <span class="hljs-string">&#x27;your bucket&#x27;</span>,<br>  <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/\.(html|map)$/i</span><br>&#125;<br><span class="hljs-keyword">const</span> devPlugins = []<br><span class="hljs-keyword">const</span> proPlugins = [<br>  <span class="hljs-title function_">vitePluginAliOss</span>(options),<br>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">vite</span>: &#123;<br>    <span class="hljs-attr">plugins</span>:  isProd ? proPlugins : devPlugins<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>nuxt3</tag>
      
      <tag>cdn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加环境变量</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/06.%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/06.%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于vite"><a href="#基于vite" class="headerlink" title="基于vite"></a>基于vite</h1><h2 id="nuxt-confit-ts"><a href="#nuxt-confit-ts" class="headerlink" title="nuxt.confit.ts"></a>nuxt.confit.ts</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; loadEnv &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br>interface <span class="hljs-variable constant_">VITE_ENV_CONFIG</span> &#123;<br>  <span class="hljs-attr">VITE_PACK_URL</span>: string<br>&#125;<br><span class="hljs-keyword">const</span> envScript = (process.<span class="hljs-property">env</span> <span class="hljs-keyword">as</span> any).<span class="hljs-property">npm_lifecycle_script</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-keyword">const</span> envName = envScript[envScript.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">const</span> envData = <span class="hljs-title function_">loadEnv</span>(envName, <span class="hljs-string">&#x27;env&#x27;</span>) <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">VITE_ENV_CONFIG</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">vite</span>: &#123;<br>    <span class="hljs-attr">envDir</span>: <span class="hljs-string">&#x27;~/env&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根目录下的env文件夹"><a href="#根目录下的env文件夹" class="headerlink" title="根目录下的env文件夹"></a>根目录下的env文件夹</h2><p>分别新建<code>.env.dev``.env.production``.env.test</code> 分别对应开发环境、生产环境、测试环境<br>文件中可以输入需要的环境变量，例如apipreffix<br><code>.env.dev</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">APIPREFFIX</span> = <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><code>.env.production</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">APIPREFFIX</span> = <span class="hljs-string">&#x27;www.production.com&#x27;</span><br></code></pre></td></tr></table></figure><p><code>.env.test</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">APIPREFFIX</span> = <span class="hljs-string">&#x27;www.test.com&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h2><p>通过 <code>useRuntimeConfig()</code>API读取<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getBaseUrl</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-variable constant_">APIPREFFIX</span> &#125; = <span class="hljs-title function_">useRuntimeConfig</span>()<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">APIPREFFIX</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>nuxt3</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/03.HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/03.HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存概念"><a href="#缓存概念" class="headerlink" title="缓存概念"></a>缓存概念</h1><p>浏览器缓存是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复请求，节省带宽，提高访问速度，降低服务器压力</p><p>HTTP缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag</p><p>HTTP 1.0 协议中就是告诉浏览器在约定的这个时间前可以直接从缓存中获取资源，从而无需跑到服务器去获取</p><p>Expires是对时间设定的，且时间是GMT（格林威治时间），而不是本地时间</p><h1 id="使用缓存流程"><a href="#使用缓存流程" class="headerlink" title="使用缓存流程"></a>使用缓存流程</h1><h2 id="第一次请求资源A"><a href="#第一次请求资源A" class="headerlink" title="第一次请求资源A"></a>第一次请求资源A</h2><p>浏览器请求 -&gt; 无缓存 -&gt; 向 web 服务器请求 -&gt; 请求响应，缓存协商 （是否存在Expires、Cache-Control；缓存时间；Etag；Last-Modified。。。）-&gt; 呈现内容</p><h2 id="第二次请求资源A"><a href="#第二次请求资源A" class="headerlink" title="第二次请求资源A"></a>第二次请求资源A</h2><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98/demo01.png" alt="image.png"></p><h1 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回<code>Status Code:200 OK</code></p><h3 id="缓存到内存中"><a href="#缓存到内存中" class="headerlink" title="缓存到内存中"></a>缓存到内存中</h3><p><code>200 OK (form memory cache) </code>：不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p><h3 id="缓存到硬盘中"><a href="#缓存到硬盘中" class="headerlink" title="缓存到硬盘中"></a>缓存到硬盘中</h3><p><code>200 OK (from disk cache) </code>：不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p><p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p><h3 id="header-参数控制"><a href="#header-参数控制" class="headerlink" title="header 参数控制"></a>header 参数控制</h3><p>Expires:过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p><p>Cache-Control:当值设置为max-age&#x3D;300时，则代表在这个请求正确返回时间（浏览器会记录下来）的5分钟内再次加载资源，就会命中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；<br>public：指示响应可被任何缓存区缓存；<br>private：只能针对个人用户，而不能被代理服务器缓存；<br>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回<span class="hljs-number">304</span>，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上<span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span>:no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。<br>no-store：禁止一切缓存（这个才是响应不被缓存的意思）。<br></code></pre></td></tr></table></figure><p>cache-control是http1.1的头字段，expires是http1.0的头字段,如果expires和cache-control同时存在，cache-control会覆盖expires，建议两个都写。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>向服务器发送请求，服务器会根据这个请求的request header 的一些参数来判断是否命中协商缓存，</p><p>如果命中，则返回304状态码并带上新的 response header 通知浏览器从缓存中读取资源</p><h3 id="header-参数控制-1"><a href="#header-参数控制-1" class="headerlink" title="header 参数控制"></a>header 参数控制</h3><p>Last-Modifed&#x2F;If-Modified-Since和Etag&#x2F;If-None-Match是分别成对出现的，呈一一对应关系</p><h4 id="Etage"><a href="#Etage" class="headerlink" title="Etage"></a>Etage</h4><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的是唯一的。</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>当资源过期时，浏览器发现响应头里有Etag,则再次向服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p><h4 id="Last-Modifed-x2F-If-Modified-Since"><a href="#Last-Modifed-x2F-If-Modified-Since" class="headerlink" title="Last-Modifed&#x2F;If-Modified-Since"></a>Last-Modifed&#x2F;If-Modified-Since</h4><p><strong>Last-Modifed：</strong> 浏览器向服务器发送资源最后的修改时间<br><strong>if-Modifed-Since：</strong> 当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p><ul><li>Last-Modifed&#x2F;If-Modified-Since的时间精度是秒，而Etag可以更精确</li><li>Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag</li><li>Last-Modifed&#x2F;If-Modified-Since是http1.0的头字段</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2023/04/21/web%E5%89%8D%E7%AB%AF/TypeScript/%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/21/web%E5%89%8D%E7%AB%AF/TypeScript/%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p><strong>object 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-built_in">object</span> = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p><strong>boolean 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">isShow</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p><strong>number 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><strong>string 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Bob&quot;</span><br></code></pre></td></tr></table></figure><p><strong>symbol 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> obj = &#123;<br>  [sym] = <span class="hljs-string">&quot;Bob&quot;</span>,<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[sym]);<br></code></pre></td></tr></table></figure><p><strong>undefined 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p><strong>null 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>:<span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><strong>bigint 类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: <span class="hljs-built_in">bigint</span> = <span class="hljs-number">100n</span>;<br></code></pre></td></tr></table></figure><p><strong>number 和 bigint 不能相互赋值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: <span class="hljs-built_in">bigint</span> = <span class="hljs-number">100n</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;<br>big = num;<br>num = big;<br><span class="hljs-comment">// 抛出一个类型不兼容的错误</span><br></code></pre></td></tr></table></figure><p><strong>undefined 和 null 是所有类中的子类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// null和undefined赋值给string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;666&quot;</span>;<br>str = <span class="hljs-literal">null</span><br>str= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给number</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">666</span>;<br>num = <span class="hljs-literal">null</span><br>num= <span class="hljs-literal">undefined</span><br><span class="hljs-comment">// null和undefined赋值给object</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-built_in">object</span> =&#123;&#125;;<br>obj = <span class="hljs-literal">null</span><br>obj= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给Symbol</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sym</span>: <span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;me&quot;</span>); <br>sym = <span class="hljs-literal">null</span><br>sym= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给boolean</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>isDone = <span class="hljs-literal">null</span><br>isDone= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给bigint</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: <span class="hljs-built_in">bigint</span> =  <span class="hljs-number">100n</span>;<br>big = <span class="hljs-literal">null</span><br>big= <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>可以配置 undefined 和 null 不能向上边这样赋值<br>tsconfig.json 里面添加 <code>&quot;strictNullChecks&quot;:true</code>：null 和 undefined 只能赋值给 void 和它们各自的类型。  </p><h2 id="原始类型对应包装对象的对象类型"><a href="#原始类型对应包装对象的对象类型" class="headerlink" title="原始类型对应包装对象的对象类型"></a>原始类型对应包装对象的对象类型</h2><p> <code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code><br>原始类型兼容对应的对象类型，反之不兼容</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Num</span>: <span class="hljs-title class_">Number</span>;<br><span class="hljs-title class_">Num</span> = num; <span class="hljs-comment">// ok</span><br>num = <span class="hljs-title class_">Num</span>; <span class="hljs-comment">// ts(2322)报错</span><br></code></pre></td></tr></table></figure><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>:<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>定义联合类型数组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:&#123;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&#125;[] = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>];<br><span class="hljs-comment">// 数组既可以存储 number 类型，也可以存储 string 类型的数据</span><br></code></pre></td></tr></table></figure><p><strong>定义指定对象成员的数组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Arrobj</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">Arrobj</span>[] = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p><strong>函数声明</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数的形参x和y都是 number 类型，出参也是 number 类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数表达式</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数的形参x和y都是 number 类型，出参也是 number 类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sum</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>,y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>接口定义函数类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SumFunc</span> &#123;<br>  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可选参数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chooseable</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (lastName) &#123;<br>    <span class="hljs-keyword">return</span> fitrstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> firstName;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">TestA</span> = <span class="hljs-title function_">chooseable</span>(<span class="hljs-string">&#x27;Test&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Test</span> = <span class="hljs-title function_">chooseable</span>(<span class="hljs-string">&#x27;Test&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">TestAB</span> = <span class="hljs-title function_">chooseable</span>(<span class="hljs-string">&#x27;Test&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>); <span class="hljs-comment">// 报错，可选参数后不允许出现参数</span><br></code></pre></td></tr></table></figure><p><strong>参数默认值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultParams</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;A&#x27;</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">TestB</span> = <span class="hljs-title function_">chooseable</span>(<span class="hljs-string">&#x27;Test&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">TestA</span> = <span class="hljs-title function_">chooseable</span>(<span class="hljs-string">&#x27;Test&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>剩余参数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">array:<span class="hljs-built_in">any</span>[], ...items: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    array.<span class="hljs-title function_">push</span>(item);<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">let</span> a = [];<br><span class="hljs-title function_">push</span>(a,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure><p><strong>函数重载</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> strOrNum = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">number</span></span>):<span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: strOrNum, b: strOrNum</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> b ==== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>() + b.<span class="hljs-title function_">toString</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组可以简单理解为可以存储不同类型的定长数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1</span>]; <br>x = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// 报错超出长度2</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>]; <span class="hljs-comment">// 报错 类型错误</span><br></code></pre></td></tr></table></figure><p><strong>解构赋值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">employee</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>];<br><span class="hljs-keyword">let</span> [id, username] = employee;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`id: <span class="hljs-subst">$&#123;id&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`username: <span class="hljs-subst">$&#123;username&#125;</span>`</span>);<br><span class="hljs-comment">// id: 1</span><br><span class="hljs-comment">// username: Semlinker</span><br></code></pre></td></tr></table></figure><p><strong>可选元素</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">chooseable</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>?];<br>chooseable = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-literal">true</span>]<br>chooseable = [<span class="hljs-string">&#x27;Bob&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>剩余元素</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> restElement = [<span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">string</span>[]];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">rest</span>: restElement = [<span class="hljs-number">123</span>, <span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;test1&quot;</span>];<br></code></pre></td></tr></table></figure><p><strong>只读元素</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>point[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// Cannot assign to &#x27;0&#x27; because it is a read-only property.</span><br>point.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Property &#x27;push&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br>point.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// Property &#x27;pop&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br>point.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Property &#x27;splice&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br></code></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>表示 没有任何类型，不能直接赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span> = a; <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>在配置文件中的<code>strictNullChecks: false</code>的情况下可以给 <code>void</code>类型赋予 <code>null</code>和<code>undefined</code>。<br>一般用于无返回值的函数类型，如果函数不声明返回值类型回返回<code>undefined</code>类型，如果声明了<code>void</code>类型，就返回<code>void</code></p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>表示用不存在的值的类型：</p><ul><li>异常</li><li>死循环<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 异常</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">err</span>(<span class="hljs-params">err: <span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 死循环</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loopForever</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><code>never</code>类型同<code>null</code>和<code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型。<br>但是没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外），即使<code>any</code>也不可以赋值给<code>never</code><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">never1</span>: <span class="hljs-built_in">never</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">nuver2</span>: <span class="hljs-built_in">never</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">any1</span>: <span class="hljs-built_in">any</span>;<br>never1 = <span class="hljs-number">123</span>; <span class="hljs-comment">// ok</span><br>never1 = never2; <span class="hljs-comment">// ok</span><br>never1 = any1; <span class="hljs-comment">// Error</span><br>never1 = (<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;异常&quot;</span>); &#125;) (); <span class="hljs-comment">// ok</span><br>never1 = (<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;&#125; &#125;)(); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><strong>利用  never 特性对类型实现全面检查</strong><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">controlFooWithNever</span>(<span class="hljs-params">foo: Foo</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 string 类型</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 number 类型</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// foo 在这里是 never</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">check</span>: <span class="hljs-built_in">never</span> = foo;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>** **如果后续修改 Foo 的类型：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span>;<br></code></pre></td></tr></table></figure> 然而他忘记同时修改 <code>controlFooWithNever</code>方法中的控制流程，这时候 <code>else</code> 分支的 <code>foo</code>类型会被收窄为 <code>boolean</code>类型，导致无法赋值给 <code>never</code>类型，这时就会产生一个编译错误。<br><strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></li></ul><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p><code>any</code> 是顶级类型，会绕过类型系统的检查。<br>允许被赋值为任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;a&#x27;</span>;<br>a = <span class="hljs-number">7</span>; <span class="hljs-comment">// TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">666</span>;<br>b = <span class="hljs-string">&quot;any&quot;</span>;<br>b = <span class="hljs-literal">false</span>;<br>b = <span class="hljs-number">66</span><br>b = <span class="hljs-literal">undefined</span><br>b = <span class="hljs-literal">null</span><br>b = []<br>b = &#123;&#125;<br></code></pre></td></tr></table></figure><p> 在any上允许访问任何属性,也允许调用任何方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">anyThing</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anyThing.<span class="hljs-property">myName</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anyThing.<span class="hljs-property">myName</span>.<span class="hljs-property">firstName</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">anyThing</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>anyThing.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br>anyThing.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>).<span class="hljs-title function_">sayHello</span>();<br>anyThing.<span class="hljs-property">myName</span>.<span class="hljs-title function_">setFirstName</span>(<span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> something;<br>something = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">something</span>: <span class="hljs-built_in">any</span>;<br>something = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>是为了解决 <code>any</code>绕过类型系统检查的问题而提出的类型。</p><p>所有的类型都可以分配给<code>unknown</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&#x27;a&#x27;</span><br>notSure = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>但是<code>unknown</code>类型只能赋值给<code>unknown</code>和 <code>any</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">any</span> = notSure; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">unknown</span> = notSure; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">number</span> = notSure; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>使用<code>unknown</code>类型一定要缩小类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">unknown</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;;<br><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">getNum</span>();<br><span class="hljs-comment">// 直接使用</span><br><span class="hljs-keyword">const</span> num_l = num.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// Error</span><br><span class="hljs-comment">// typeof</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> num = <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  <span class="hljs-keyword">const</span> num_l = num.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-comment">// 类型断言</span><br><span class="hljs-keyword">const</span> num_l = (num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// ok </span><br></code></pre></td></tr></table></figure><h2 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h2><p><strong>object</strong><br><code>object</code>是所有非原始类型。<br>不能把 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>等 原始类型赋值给 <code>object</code>。在严格模式下，<code>null</code>和 <code>undefined</code>类型也不能赋给 <code>object</code>。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">lowerCaseObject</span>: <span class="hljs-built_in">object</span>;<br>lowerCaseObject = <span class="hljs-number">1</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p> <strong>Object</strong><br><code>Object</code>是原始类型和非原始类型的集合，并且既是<code>object</code>的父类型，又是<code>object</code>的子类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> isLowerCaseObjectExtendsUpperCaseObject = <span class="hljs-built_in">object</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> isUpperCaseObjectExtendsLowerCaseObject = <span class="hljs-title class_">Object</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br>upperCaseObject = lowerCaseObject; <span class="hljs-comment">// ok</span><br>lowerCaseObject = upperCaseObject; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><code>**&#123;&#125;**</code><br> <code>&#123;&#125;</code>类型和 <code>Object</code>一样，是原始类型和非原始类型的集合， 并且在严格模式下，null 和 undefined 也不能赋给 {}  </p><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p><code>TypeScript</code>会根据上下文环境自动推断出变量的类型，无须再写明类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br>&#125;<br>&#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 等价</span><br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 等价</span><br>  <span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 等价</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-comment">/** 根据参数的类型，推断出返回值的类型也是 number */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">const</span> x1= <span class="hljs-title function_">add1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 推断出 x1 的类型也是 number</span><br>  <br>  <span class="hljs-comment">/** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">const</span> x2 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> x3 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// ts(2345) Argument of type &quot;1&quot; is not assignable to parameter of type &#x27;number | undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 如果定义的时候没有赋值，只会被推断成 <code>any</code>类型，绕过类型检查：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> myFavoriteNumber;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>myFavoriteNumber = <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>开发者告诉 <code>TypeScript</code>当前值得类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 尖括号 语法 尖括号格式会与react中JSX产生语法冲突</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// as 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br><br></code></pre></td></tr></table></figure><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p><code>x!</code>将 <code>x</code>的值域，删除 <code>null</code>和<code>undefined</code>类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">mayNullOrUndefinedOrString</span>: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>;<br>mayNullOrUndefinedOrString!.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span><br>mayNullOrUndefinedOrString.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ts(2531)</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumGenerator</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">numGenerator: NumGenerator | <span class="hljs-literal">undefined</span></span>) &#123;<br>  <span class="hljs-comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span><br>  <span class="hljs-comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span><br>  <span class="hljs-keyword">const</span> num1 = <span class="hljs-title function_">numGenerator</span>(); <span class="hljs-comment">// Error</span><br>  <span class="hljs-keyword">const</span> num2 = numGenerator!(); <span class="hljs-comment">//OK</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h2><p> 允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-title function_">init</span>();<br><br><span class="hljs-comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 通过<code> let x!: number;</code> 确定赋值断言，<code>TypeScript</code>编译器就会知道该属性会被明确地赋值。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x!: <span class="hljs-built_in">number</span>;<br><span class="hljs-title function_">init</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h1><p> 在 <code>TypeScript </code>中，字面量不仅可以表示值，还可以表示类型  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 字符串字面量类型</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedNum</span>: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 数值字面量类型</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedBoolean</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 布尔字面量类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字面量类型是对应类型的子类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;any string&#x27;</span>;<br>  specifiedStr = str; <span class="hljs-comment">// ts(2322) 类型 &#x27;&quot;string&quot;&#x27; 不能赋值给类型 &#x27;this is string&#x27;</span><br>  str = specifiedStr; <span class="hljs-comment">// ok </span><br>&#125;<br></code></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> config &#123;<br>  <span class="hljs-attr">size</span>: <span class="hljs-string">&#x27;small&#x27;</span> | <span class="hljs-string">&#x27;big&#x27;</span>;<br>  <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> | <span class="hljs-number">2</span> | <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-comment">// 限定了 size 属性为字符串字面量类型 &#x27;small&#x27; | &#x27;big&#x27;</span><br><span class="hljs-comment">// margin 属性为数字字面量类型 0 | 2 | 4</span><br></code></pre></td></tr></table></figure><h2 id="类型拓宽（Type-Widening）"><a href="#类型拓宽（Type-Widening）" class="headerlink" title="类型拓宽（Type Widening）"></a>类型拓宽（Type Widening）</h2><p>所有通过 <code>let</code>或<code>var</code>定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显示添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型这就是字面量的类型拓宽。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 类型是 string</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">strFun</span> = (<span class="hljs-params">str = <span class="hljs-string">&#x27;this is string&#x27;</span></span>) =&gt; str; <span class="hljs-comment">// 类型是 (str?: string) =&gt; string;</span><br><span class="hljs-keyword">const</span> specifiedStr = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 类型是 &#x27;this is string&#x27; 因为 const 常量不可变，类型没有拓宽</span><br><span class="hljs-keyword">let</span> str2 = specifiedStr; <span class="hljs-comment">// 类型是 &#x27;string&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">strFun2</span> = (<span class="hljs-params">str = specifiedStr</span>) =&gt; str; <span class="hljs-comment">// 类型是 (str?: string) =&gt; string;</span><br></code></pre></td></tr></table></figure><p><strong>null 和 undefined 的类型拓宽</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类型拓宽成 any</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 类型拓宽成 any</span><br><br>  <span class="hljs-comment">/** -----分界线------- */</span><br>  <span class="hljs-keyword">const</span> z = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类型是 null</span><br><br>  <span class="hljs-comment">/** -----分界线------- */</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">anyFun</span> = (<span class="hljs-params">param = <span class="hljs-literal">null</span></span>) =&gt; param; <span class="hljs-comment">// 形参类型是 null</span><br>  <span class="hljs-keyword">let</span> z2 = z; <span class="hljs-comment">// 类型是 null</span><br>  <span class="hljs-keyword">let</span> x2 = x; <span class="hljs-comment">// 类型是 null</span><br>  <span class="hljs-keyword">let</span> y2 = y; <span class="hljs-comment">// 类型是 undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 在 <code>TypeScript</code>中，对于 <code>obj</code>的类型来说，它可以是 <code>&#123;readonly x：1&#125;</code> 类型，或者是更通用的 <code>&#123;x：number&#125;</code>类型。当然也可能是 <code>&#123;[key: string]: number&#125;</code> 或 <code>object</code> 类型<br>对于对象，<code>TypeScript</code>的拓宽算法会将其内部属性视为将其赋值给 <code>let</code>关键字声明的变量，进而来推断其属性的类型。因此 <code>obj</code>的类型为 <code>&#123;x：number&#125;</code> 。这使得你可以将<code>obj.x</code> 赋值给其他 <code>number</code>类型的变量，而不是 <code>string</code>类型的变量，并且它还会阻止你添加其他属性。</p><p><code>const</code>并不能完全阻止类型拓宽</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>&#125;;<br><br>obj.<span class="hljs-property">x</span> = <span class="hljs-number">6</span>; <span class="hljs-comment">// OK </span><br><br><br><span class="hljs-comment">// Type &#x27;&quot;6&quot;&#x27; is not assignable to type &#x27;number&#x27;.</span><br>obj.<span class="hljs-property">x</span> = <span class="hljs-string">&#x27;6&#x27;</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-comment">// Property &#x27;y&#x27; does not exist on type &#x27;&#123; x: number; &#125;&#x27;.</span><br>obj.<span class="hljs-property">y</span> = <span class="hljs-number">8</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-comment">// Property &#x27;name&#x27; does not exist on type &#x27;&#123; x: number; &#125;&#x27;.</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;semlinker&#x27;</span>; <span class="hljs-comment">// Error</span><br><br></code></pre></td></tr></table></figure><p>使用 <code>as const</code>防止类型拓宽</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// Type is &#123; x: number; y: number; &#125;</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> <br>&#125;; <br><br><span class="hljs-comment">// Type is &#123; x: 1; y: number; &#125;</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,<br>&#125;; <br><br><span class="hljs-comment">// Type is &#123; readonly x: 1; readonly y: 2; &#125;</span><br><span class="hljs-keyword">const</span> obj3 = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> <br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// 当你在一个值之后使用 const 断言时，</span><br><span class="hljs-comment">// TypeScript 将为它推断出最窄的类型，没有拓宽。对于真正的常量，这通常是你想要的。</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// Type is number[]</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br><br><span class="hljs-comment">// Type is readonly [1, 2, 3]</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br></code></pre></td></tr></table></figure><h2 id="类型缩小（Type-Narrowing）"><a href="#类型缩小（Type-Narrowing）" class="headerlink" title="类型缩小（Type Narrowing）"></a>类型缩小（Type Narrowing）</h2><p> 在 <code>TypeScript </code>中，我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，这就是 <code>&quot;Type Narrowing&quot;</code>。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">anything: <span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 string </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 number</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params">name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt; &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>给类型取名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[];<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">message: Message</span>) =&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h1><p>将多个类型合并成为一个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IntersectionType</span> = &#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; &#125; &amp; &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;;<br> <span class="hljs-keyword">const</span> <span class="hljs-attr">mixed</span>: <span class="hljs-title class_">IntersectionType</span> = &#123;<br>   <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Useless</span> = <span class="hljs-built_in">string</span> &amp; <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// Useless 类型会变成 never</span><br></code></pre></td></tr></table></figure><h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Jak</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jak&#x27;</span><br>&#125;; <span class="hljs-comment">// 报错 不能比接口少属性</span><br><span class="hljs-comment">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bob</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;man&#x27;</span><br>&#125;; <span class="hljs-comment">// 报错 不能比接口多属性</span><br><br><span class="hljs-comment">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span><br></code></pre></td></tr></table></figure><h1 id="可选-只读属性"><a href="#可选-只读属性" class="headerlink" title="可选 | 只读属性"></a>可选 | 只读属性</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">ro</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">number</span>&gt; = a;<br>ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span><br>ro.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span><br>ro.<span class="hljs-property">length</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span><br>a = ro; <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><h1 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h1><p> 一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性。<br> 使用 <strong>索引签名</strong> 的形式 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="hljs-comment">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Index signatures are incompatible.</span><br><span class="hljs-comment">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure><p>任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。<br>**一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：  **</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 这里真实的类型应该为：number | undefined</span><br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="类型别名和接口的区别"><a href="#类型别名和接口的区别" class="headerlink" title="类型别名和接口的区别"></a>类型别名和接口的区别</h1><p>类型别名可以用于 本类型（原始值）、联合类型、元组，接口不可以。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;<br></code></pre></td></tr></table></figure><p>接口可以定义多次，类型别名不可以</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p>两者的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。<br>接口的扩展就是继承，通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><p>K 、V、E 就是抽象类型，只有在调用的时候才确定它的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 显示设置类型</span><br><span class="hljs-keyword">function</span> test &lt;T, U&gt; (<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test&lt;<span class="hljs-title class_">Number</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">// 一一对应</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 编译器自动选择类型</span><br><span class="hljs-keyword">function</span> test &lt;T, U&gt; (<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">// 一一对应</span><br></code></pre></td></tr></table></figure><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sizeable</span> &#123;<br>  <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> trace &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sizeable</span>&gt; (<span class="hljs-attr">arg</span>: T):T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">size</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>主要作用是获取变量或者属性的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 普通类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">man</span>: <span class="hljs-title class_">Person</span> = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;;<br><span class="hljs-keyword">type</span> men = <span class="hljs-keyword">typeof</span> man; <span class="hljs-comment">// type men = Person</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 嵌套的 object 类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Message</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;jimmy&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>      <span class="hljs-attr">province</span>: <span class="hljs-string">&#x27;四川&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;成都&#x27;</span>   <br>    &#125;<br>&#125;<br><span class="hljs-keyword">type</span> message = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Message</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> type message = &#123;</span><br><span class="hljs-comment">    name: string;</span><br><span class="hljs-comment">    age: number;</span><br><span class="hljs-comment">    address: &#123;</span><br><span class="hljs-comment">        province: string;</span><br><span class="hljs-comment">        city: string;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> [x];<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-keyword">typeof</span> test; <span class="hljs-comment">// -&gt; (x:number) =&gt; number[]</span><br></code></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p>作用：获取某种类型的所有键，返回值是联合类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[]; <span class="hljs-comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K3</span> = keyof &#123; [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Person</span> &#125;;  <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><p>首先定义了 T 类型并使用 extends 关键字约束该类型必须是 object 类型的子类型，然后使用 keyof 操作符获取 T 类型的所有键，其返回类型是联合类型，最后利用 extends 关键字约束 K 类型必须为 keyof T 联合类型的子类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 解决的问题</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">obj: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> (obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key];<br>&#125; <span class="hljs-comment">// 使用了 any 非常不推荐</span><br><span class="hljs-keyword">function</span> prop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Todo</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">Todo</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Learn TypeScript keyof&quot;</span>,<br>  <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">function</span> prop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><br><span class="hljs-keyword">const</span> id = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// const id: number</span><br><span class="hljs-keyword">const</span> text = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;text&quot;</span>); <span class="hljs-comment">// const text: string</span><br><span class="hljs-keyword">const</span> done = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;done&quot;</span>); <span class="hljs-comment">// const done: boolean</span><br></code></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>用来遍历枚举类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Keys</span> = <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Obj</span> =  &#123;<br>  [p <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: <span class="hljs-built_in">any</span><br>&#125; <span class="hljs-comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span><br></code></pre></td></tr></table></figure><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p> 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p> 以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。  </p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>添加泛型约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Length</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> logLengthNumber&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>)<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-title function_">loggingIdentity</span>(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><p>给键值对类型的数据中的键添加类型约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> getValues&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">person</span>: T, <span class="hljs-attr">keys</span>: K[]): T[K][] &#123;<br>  <span class="hljs-keyword">return</span> keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> person[key]);<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;musion&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">35</span><br>&#125;<br><span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-comment">// [&#x27;musion&#x27;]</span><br><span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;gender&#x27;</span>]) <span class="hljs-comment">// 报错：</span><br><span class="hljs-comment">// Argument of Type &#x27;&quot;gender&quot;[]&#x27; is not assignable to parameter of type &#x27;(&quot;name&quot; | &quot;age&quot;)[]&#x27;.</span><br><span class="hljs-comment">// Type &quot;gender&quot; is not assignable to type &quot;name&quot; | &quot;age&quot;.</span><br></code></pre></td></tr></table></figure><p> 编译器会检查传入的值是否是Person的一部分。通过下面的概念来理解上面的代码：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// T[K]表示对象T的属性K所表示的类型，在上述例子中，T[K][] 表示变量T取属性K的值的数组</span><br>/ 通过[]索引类型访问操作符, 我们就能得到某个索引的类型<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span>;<br> &#125;<br> <span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;name&#x27;</span>];  <span class="hljs-comment">//Person中name的类型为string type MyType = string</span><br><br></code></pre></td></tr></table></figure><h1 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h1><p>根据旧类型创建出新的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-comment">// 通过+/-来指定添加还是删除</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionTest</span>&lt;T&gt; = &#123;<br>  [p <span class="hljs-keyword">in</span> keyof T]+?:T[p]<br>&#125;<br><span class="hljs-keyword">type</span> newTest = <span class="hljs-title class_">OptionalTest</span>&lt;<span class="hljs-title class_">Test</span>&gt;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// type newTest = &#123;</span><br><span class="hljs-comment">//    name?:string,</span><br><span class="hljs-comment">//    age?:number</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h2 id="内置的工具类型"><a href="#内置的工具类型" class="headerlink" title="内置的工具类型"></a>内置的工具类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial&lt;T&gt;</code> 将类型的属性变成可选,<br>但是仅支持处理第一层属性<br>本质:  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NewUserInfo</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">UserInfo</span>&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">xiaoming</span>: <span class="hljs-title class_">NewUserInfo</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>&#125;<br><span class="hljs-comment">// NewUserInfo 等价于</span><br><span class="hljs-comment">// interface NewUserInfo &#123;</span><br><span class="hljs-comment">//    id?: string;</span><br><span class="hljs-comment">//    name?: string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="实现对多层的处理"><a href="#实现对多层的处理" class="headerlink" title="实现对多层的处理"></a>实现对多层的处理</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPartial</span>&lt;T&gt; = &#123;<br>     <span class="hljs-comment">// 如果是 object，则递归类型</span><br>    [U <span class="hljs-keyword">in</span> keyof T]?: T[U] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span><br>      ? <span class="hljs-title class_">DeepPartial</span>&lt;T[U]&gt;<br>      : T[U]<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialedWindow</span> = <span class="hljs-title class_">DeepPartial</span>&lt;T&gt;; <span class="hljs-comment">// 现在T上所有属性都变成了可选</span><br></code></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>将类型的属性变成必选<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = &#123; <br>    [P <span class="hljs-keyword">in</span> keyof T]-?: T[P] <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p>某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p>从某个类型中挑出一些属性出来<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> K]:T[P];<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;completed&quot;</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">TodoPreview</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Clean room&quot;</span>,<br>  <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><code>ecord&lt;K extends keyof any, T&gt;</code> 的作用是将 K 中所有的属性的值转化为 T 类型。<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> K]: T;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Page</span> = <span class="hljs-string">&quot;home&quot;</span> | <span class="hljs-string">&quot;about&quot;</span> | <span class="hljs-string">&quot;contact&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Page</span>, <span class="hljs-title class_">PageInfo</span>&gt; = &#123;<br>  <span class="hljs-attr">about</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;about&quot;</span> &#125;,<br>  <span class="hljs-attr">contact</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;contact&quot;</span> &#125;,<br>  <span class="hljs-attr">home</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;home&quot;</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>用来得到一个函数的返回值类型<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R<br>  ? R<br>  : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p><code>infer</code>在这里用于提取函数类型的返回值类型。<code>ReturnType&lt;T&gt;</code> 只是将<code> infer R</code> 从参数位置移动到返回值位置，因此此时 R 即是表示待推断的返回值类型。  </p><h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p><code>Extract&lt;T, U&gt;</code> 的作用是从<code>T</code> 中提取出<code>U</code>。<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;f&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;a&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// () =&gt; void</span><br></code></pre></td></tr></table></figure><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><p><code>Omit&lt;T, K extends keyof any&gt;</code>的作用是使用 <code>T</code> 类型中除了 <code>K</code> 类型的所有属性，来构造一个新的类型。<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;description&quot;</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">TodoPreview</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Clean room&quot;</span>,<br>  <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><p><code>NonNullable&lt;T&gt;</code> 的作用是用来过滤类型中的 <code>null</code>及 <code>undefined</code>类型.<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">never</span> : T;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// string | number</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// string[]</span><br></code></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p><code>Parameters&lt;T&gt;</code> 的作用是用于获得函数的参数类型组成的元组类型。<br>本质:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span><br>? P : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span><span class="hljs-built_in">void</span>&gt;; <span class="hljs-comment">// []</span><br><span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Parameters</span>&lt;typeofArray.<span class="hljs-property">isArray</span>&gt;; <span class="hljs-comment">// [any]</span><br><span class="hljs-keyword">type</span> C = <span class="hljs-title class_">Parameters</span>&lt;typeofparseInt&gt;; <span class="hljs-comment">// [string, (number | undefined)?]</span><br><span class="hljs-keyword">type</span> D = <span class="hljs-title class_">Parameters</span>&lt;typeofMath.<span class="hljs-property">max</span>&gt;; <span class="hljs-comment">// number[]</span><br></code></pre></td></tr></table></figure><h1 id="tsconfig-json-配置文件"><a href="#tsconfig-json-配置文件" class="headerlink" title="tsconfig.json 配置文件"></a>tsconfig.json 配置文件</h1><p>如果一个目录下存在一个 tsconfig.json 文件，那么往往意味着这个目录就是 TypeScript 项目的根目录。<br>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。  </p><h2 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>  <br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-string">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-string">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-string">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-string">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-string">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-string">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-string">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-string">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-string">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-string">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-string">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-string">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-string">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-string">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-string">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-string">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-string">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器与js</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/01.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Ejs/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器与JS"><a href="#浏览器与JS" class="headerlink" title="浏览器与JS"></a>浏览器与JS</h1><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p>进程是 cpu 资源分配的最小单位（系统会给他分配内存），进程之间相互独立（也可以相互通信，但是代价很大）。</p><p>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程），线程之间有共享空间。</p><p>区别：</p><ol><li>每启动一个进程，这个进程至少得有一个线程。</li><li>进程本身只是一个资源单位，并不是真正执行，进程内的线程才是执行单位。</li><li>一个进程内可以有多个线程，进程在内存中相互隔离，而同一个进程内的线程是共享资源的，各线程之间地位平等。</li><li>进程更消耗资源，而线程开销小，是在已有的进程内占用。</li></ol><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2><h3 id="1-包含以下主要进程"><a href="#1-包含以下主要进程" class="headerlink" title="1.包含以下主要进程"></a>1.包含以下主要进程</h3><ol><li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个，作用有： <ul><li>负责浏览器的界面展示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将 Render 进程得到的内存中的 Bitmap ，绘制到到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程：每个类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D 绘制等</li><li>浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每一个 Tab 页面一个进程，互不影响。主要作用 <ul><li>页面渲染，脚本执行，事件处理等等</li></ul></li></ol><p>在浏览器打开一个网页，就相当于新启了一个进程（可以通过Chrome的更多工具-》任务管理器自行验证）</p><h3 id="2-浏览器多进程的优势"><a href="#2-浏览器多进程的优势" class="headerlink" title="2.浏览器多进程的优势"></a>2.浏览器多进程的优势</h3><ul><li>避免单个 page crash 影响整个浏览器 </li><li>避免第三方插件 crash 影响整个浏览器 </li><li>多进程充分利用多核优势 </li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<br>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></li></ul><h3 id="3-浏览器内核（渲染进程）"><a href="#3-浏览器内核（渲染进程）" class="headerlink" title="3.浏览器内核（渲染进程）"></a>3.浏览器内核（渲染进程）</h3><p>渲染进程是多线程的，常驻线程如下：</p><ol><li>GUI 渲染线程</li></ol><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行</li><li>GUI渲染进程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><ol start="2"><li>JS引擎线程</li></ol><ul><li>也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>GUI渲染进程和JS引擎线程是互斥的，如果JS执行的时间过长，就会阻塞页面的渲染。</li></ul><ol start="3"><li>事件触发线程</li></ol><ul><li>归属于浏览器而不是JS引擎，用来控制四件循环（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>注意，由于JS的单线程的关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲的时候才会去执行）</li></ul><ol start="4"><li>定时器触发线程</li></ol><ul><li>setInterval 与 setTimeout 所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的（因为Javascript引擎时单线程的，如果处于阻塞线程状态就会影响定时计数器的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li></ul><ol start="5"><li>异步http请求线程</li></ol><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由Javascript引擎执行。</li></ul><p><strong>浏览器内核</strong></p><p><img src="/img/web%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/core.png" alt="image.png"></p><h3 id="4-Browser进程和浏览器内核（Render进程）的通信过程"><a href="#4-Browser进程和浏览器内核（Render进程）的通信过程" class="headerlink" title="4.Browser进程和浏览器内核（Render进程）的通信过程"></a>4.Browser进程和浏览器内核（Render进程）的通信过程</h3><ul><li>Browser 进程收到了用户请求，首先需要获取页面内容（通过网络下载资源），随后将该任务通过RenderHost接口传递给Render进程</li><li>Render进程的Render接口收到消息，简单解释后，交给渲染线程（Render），然后开始渲染 <ul><li>渲染线程（Render）接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM</li><li>最后 Render 进程将结果传递给Browser进程</li></ul></li><li>Browser进程接收到结果并将结果绘制出来</li></ul><h3 id="5-WebWorker"><a href="#5-WebWorker" class="headerlink" title="5.WebWorker"></a>5.WebWorker</h3><p>HTML5 支持了 Web Worker</p><p>MDN 解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Web</span> <span class="hljs-title class_">Worker</span>为<span class="hljs-title class_">Web</span>内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面<br><br>一个worker是使用一个构造函数创建的一个对象(e.<span class="hljs-property">g</span>. <span class="hljs-title class_">Worker</span>()) 运行一个命名的<span class="hljs-title class_">JavaScript</span>文件 <br><br>这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的<span class="hljs-variable language_">window</span><br><br>因此，使用 <span class="hljs-variable language_">window</span>快捷方式获取当前全局的范围 (而不是self) 在一个 <span class="hljs-title class_">Worker</span> 内将返回错误<br></code></pre></td></tr></table></figure><ul><li>创建 Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与主线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，单独开一个Worker线程，这样里面不管如何翻天覆地都不影响JS引擎主线程，只等计算出结果后，将结果通信给主线程即可。</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="6-WebWorker-与-SharedWorker"><a href="#6-WebWorker-与-SharedWorker" class="headerlink" title="6.WebWorker 与 SharedWorker"></a>6.WebWorker 与 SharedWorker</h3><ul><li>WebWorker只属于某个页面，不会和其他页面的Renderer进程共享 <ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li><li>SharedWorker是浏览器所有页面共享，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 <ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul><p>SharedWorker由独立的进程管理，WebWorker只属于render进程下的一个线程</p><h3 id="7-浏览器渲染进程"><a href="#7-浏览器渲染进程" class="headerlink" title="7.浏览器渲染进程"></a>7.浏览器渲染进程</h3><ul><li>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</li><li>浏览器渲染流程开始</li></ul><p>渲染：</p><ol><li>解析html建立dom树</li><li>解析css构建 render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>渲染完成之后就是 load 事件</p><h4 id="1-load事件与DOMContentLoaded事件的先后"><a href="#1-load事件与DOMContentLoaded事件的先后" class="headerlink" title="1.load事件与DOMContentLoaded事件的先后"></a>1.load事件与DOMContentLoaded事件的先后</h4><ul><li>当 DOMContentLoaded 事件出发时，仅当DOM加载完成，不包括样式表，图片。（例如如果有async加载的脚本就不一定完成）</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><p>DOMContentLoaded -&gt; load</p><h4 id="2-css加载是否会阻塞dom树渲染"><a href="#2-css加载是否会阻塞dom树渲染" class="headerlink" title="2.css加载是否会阻塞dom树渲染"></a>2.css加载是否会阻塞dom树渲染</h4><p>此处说的是头部引入css的情况下</p><p>css是由单独的下载线程异步下载的。</p><ul><li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li><li>但会阻塞render树渲染（渲染时需等待css加载完毕，因为render树需要css信息）</li></ul><p>因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h4 id="3-普通图层和复合图层"><a href="#3-普通图层和复合图层" class="headerlink" title="3.普通图层和复合图层"></a>3.普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p><ul><li>普通文档流内可以理解为一个复合图层（这里称为默认复合图层，里面不管添加多少元素，其实都是在同一个复合图层中）</li><li>absolute布局和flex布局，虽然脱离普通文档流，但是仍然属于默认复合层。</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合图层中的回流重绘）</li></ul><p>GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p><h5 id="1-如何变成复合图层（硬件加速）"><a href="#1-如何变成复合图层（硬件加速）" class="headerlink" title="1.如何变成复合图层（硬件加速）"></a>1.如何变成复合图层（硬件加速）</h5><p>将该元素变成一个复合图层，就是硬件加速技术</p><ul><li><p>最常用的方式：translate3d、translateZ </p></li><li><p>opacity 属性&#x2F;过渡动画（需要动画执行过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） </p></li><li><p>will-chang属性，一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）。<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） </p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">webgl</span>&gt;</span>等元素<br></code></pre></td></tr></table></figure></li><li><p>其它，譬如以前的flash插件</p></li></ul><h5 id="2-absolute和硬件加速的区别"><a href="#2-absolute和硬件加速的区别" class="headerlink" title="2.absolute和硬件加速的区别"></a>2.absolute和硬件加速的区别</h5><p>absolute 虽然脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中的render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><h5 id="3-复合图层的作用"><a href="#3-复合图层的作用" class="headerlink" title="3.复合图层的作用"></a>3.复合图层的作用</h5><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但是尽量不要大量使用复合图层，否则由于资源消耗过渡，页面反而会变得更卡</p><h5 id="4-硬件加速时使用index"><a href="#4-硬件加速时使用index" class="headerlink" title="4.硬件加速时使用index"></a>4.硬件加速时使用index</h5><p>使用硬件加速时，尽可能使用z-index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体原理：webkit css3 中，如果整个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其他元素（层级比这个元素高的，或者相同的，并且releative或者absolute属性相同的），会默认变成复合图层渲染，如果处理不当会极大的影响性能</p><p>简单理解：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</p><h2 id="从-Event-Loop谈JS的运行机制"><a href="#从-Event-Loop谈JS的运行机制" class="headerlink" title="从 Event Loop谈JS的运行机制"></a>从 Event Loop谈JS的运行机制</h2><ul><li>JS分为同步任务和异步任务 </li><li>同步任务都在主线程上执行，形成一个执行栈 </li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 </li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到主执行栈中，开始执行 </li><li>异步队列里分为宏任务和微任务 <ul><li>宏任务（macrotask）每次执行栈执行后的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放入执行栈中执行） <ul><li>每一个宏任务都会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始之前，对页面进行重新渲染</li></ul></li><li>微任务（microtask），可以理解是在当前宏任务执行结束后立即执行的任务 <ul><li>在当前宏任务之后，在渲染之前，下一个宏任务之前</li><li>在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（渲染之前）</li></ul></li><li>宏任务：script(整体代码)、setTimeout、setInterval、I&#x2F;O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</li><li>微任务：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</li></ul></li></ul><p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 </p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setTimeout、setInterval是由定时器线程计时的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin&#x27;</span>);<br></code></pre></td></tr></table></figure><p>虽然代码是0毫秒后推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E7%94%9F%E6%80%81/vxe-table/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="更新动态列"><a href="#更新动态列" class="headerlink" title="更新动态列"></a>更新动态列</h1><p>在Vue2中使用vxetable组件时，如果不调用clearSort方法而直接修改columns，可能会出现渲染问题。这是因为vxetable组件内部维护了一个状态，用于记录表格的排序状态，当columns发生变化时，如果不正确地更新这个状态，就会导致渲染问题的出现。<br>调用clearSort方法的作用是清除表格的排序状态，这样在更新columns后，vxetable组件会重新根据新的columns进行排序，从而避免渲染问题的出现。<br>具体地，如果不调用clearSort方法，可能会出现以下两种情况：</p><ol><li>表格数据显示不正确：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致表格数据显示不正确，这是因为vxetable组件仍然保留着原来的排序状态，导致新的columns无法正确应用到表格数据上。</li><li>列表头显示异常：当使用动态列配置时，如果不调用clearSort方法就直接修改columns，可能会导致列表头显示异常，这是因为vxetable组件内部维护的排序状态没有正确更新，导致列表头的渲染出现问题。</li></ol><p>因此，在修改columns时，建议先调用clearSort方法清除排序状态，再进行列属性的更新。这样可以避免渲染问题的出现，确保vxetable组件能够正确地更新和显示数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInViewAnimate</span> = (<span class="hljs-params">el, binding</span>) =&gt; &#123;<br>  <span class="hljs-comment">// check if browser supports IntersectionObserver API</span><br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;IntersectionObserver&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) &#123;<br>    <span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInView</span>(el)) &#123;<br>        el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>        timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, listener);<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// use IntersectionObserver for supported browser</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">[entry]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;<br>      el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(binding.<span class="hljs-property">value</span>);<br>    &#125;<br>  &#125;, &#123;<br>    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span><br>  &#125;);<br>  observer.<span class="hljs-title function_">observe</span>(el);<br><br>  <span class="hljs-comment">// clean up</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    observer.<span class="hljs-title function_">disconnect</span>();<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;<br>      observer.<span class="hljs-title function_">disconnect</span>();<br>    &#125;,<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simulate intersection observer for unsupported browser</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isInView</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> rect = el.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> - rect.<span class="hljs-property">top</span> &gt; <span class="hljs-number">100</span>;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>生态</category>
      
      <category>vxe-table</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>vxe-table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/02.template/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例化</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">111</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">// render(h) &#123;</span><br>  <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span><br>  <span class="hljs-comment">// &#125;,</span><br>  <span class="hljs-comment">// template:`&lt;div id=&quot;a&quot;&gt;hello&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="模板编译入口"><a href="#模板编译入口" class="headerlink" title="模板编译入口"></a>模板编译入口</h1><p>传入的 el 或者 template 选项最后都会被解析成 render 函数 这样才能保持模板解析的一致性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-keyword">import</span> &#123; initState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./state&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; compileToFunctions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./compiler/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 这里的this代表调用_init方法的对象(实例对象)</span><br>    <span class="hljs-comment">//  this.$options就是用户new Vue的时候传入的属性</span><br>    vm.<span class="hljs-property">$options</span> = options;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-title function_">initState</span>(vm);<br><br>    <span class="hljs-comment">// 如果有el属性 进行模板渲染</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 这块代码在源码里面的位置其实是放在entry-runtime-with-compiler.js里面</span><br>  <span class="hljs-comment">// 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br><br>    <span class="hljs-comment">// 如果不存在render属性</span><br>    <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>      <span class="hljs-comment">// 如果存在template属性</span><br>      <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br><br>      <span class="hljs-keyword">if</span> (!template &amp;&amp; el) &#123;<br>        <span class="hljs-comment">// 如果不存在render和template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>        template = el.<span class="hljs-property">outerHTML</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>      <span class="hljs-keyword">if</span> (template) &#123;<br>        <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>        options.<span class="hljs-property">render</span> = render;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br>  <br><br></code></pre></td></tr></table></figure><h1 id="模板转化核心方法-compileToFunctions"><a href="#模板转化核心方法-compileToFunctions" class="headerlink" title="模板转化核心方法 compileToFunctions"></a>模板转化核心方法 compileToFunctions</h1><p> 1.生成 ast 2.优化静态节点 3.根据 ast 生成 render 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/index.js</span><br><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./parse&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./codegen&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-comment">// 把html字符串变成render函数</span><br>  <span class="hljs-comment">// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br>  <span class="hljs-comment">// 很多库都运用到了ast 比如 webpack babel eslint等等</span><br>  <span class="hljs-keyword">let</span> ast = <span class="hljs-title function_">parse</span>(template);<br>  <span class="hljs-comment">// 2.优化静态节点</span><br>  <span class="hljs-comment">//   if (options.optimize !== false) &#123;</span><br>  <span class="hljs-comment">//     optimize(ast, options);</span><br>  <span class="hljs-comment">//   &#125;</span><br><br>  <span class="hljs-comment">// 3.通过ast 重新生成代码</span><br>  <span class="hljs-comment">// 最后生成的代码需要和render函数一样</span><br>  <span class="hljs-comment">// 类似_c(&#x27;div&#x27;,&#123;id:&quot;app&quot;&#125;,_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br>  <span class="hljs-comment">// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解析-html-并生成-ast"><a href="#解析-html-并生成-ast" class="headerlink" title="解析 html 并生成 ast"></a>解析 html 并生成 ast</h1><p>利用正则 匹配 html 字符串 遇到开始标签 结束标签和文本 解析完毕之后生成对应的 ast 并建立相应的父子关联 不断的 advance 截取剩余的字符串 直到 html 全部解析完毕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/parse.js</span><br><br><span class="hljs-comment">// 以下为源码的正则  对正则表达式不清楚的同学可以参考小编之前写的文章(前端进阶高薪必看 - 正则篇);</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; <span class="hljs-comment">//匹配标签名 形如 abc-123</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span>; <span class="hljs-comment">//匹配特殊标签 形如 abc:234 前面的abc:可有可无</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="hljs-comment">// 匹配标签开始 形如 &lt;abc-123 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span>; <span class="hljs-comment">// 匹配标签结束  &gt;</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="hljs-comment">// 匹配标签结尾 如 &lt;/abc-123&gt; 捕获里面的标签名</span><br><span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="hljs-comment">// 匹配属性  形如 id=&quot;app&quot;</span><br><br><span class="hljs-keyword">let</span> root, currentParent; <span class="hljs-comment">//代表根节点 和当前父节点</span><br><span class="hljs-comment">// 栈结构 来表示开始和结束标签</span><br><span class="hljs-keyword">let</span> stack = [];<br><span class="hljs-comment">// 标识元素和文本type</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ELEMENT_TYPE</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 生成ast方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createASTElement</span>(<span class="hljs-params">tagName, attrs</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tag</span>: tagName,<br>    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ELEMENT_TYPE</span>,<br>    <span class="hljs-attr">children</span>: [],<br>    attrs,<br>    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 对开始标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStartTag</span>(<span class="hljs-params">&#123; tagName, attrs &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> element = <span class="hljs-title function_">createASTElement</span>(tagName, attrs);<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    root = element;<br>  &#125;<br>  currentParent = element;<br>  stack.<span class="hljs-title function_">push</span>(element);<br>&#125;<br><br><span class="hljs-comment">// 对结束标签进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEndTag</span>(<span class="hljs-params">tagName</span>) &#123;<br>  <span class="hljs-comment">// 栈结构 []</span><br>  <span class="hljs-comment">// 比如 &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 当遇到第一个结束标签&lt;/span&gt;时 会匹配到栈顶&lt;span&gt;元素对应的ast 并取出来</span><br>  <span class="hljs-keyword">let</span> element = stack.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-comment">// 当前父元素就是栈顶的上一个元素 在这里就类似div</span><br>  currentParent = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  <span class="hljs-comment">// 建立parent和children关系</span><br>  <span class="hljs-keyword">if</span> (currentParent) &#123;<br>    element.<span class="hljs-property">parent</span> = currentParent;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对文本进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChars</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-comment">// 去掉空格</span><br>  text = text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (text) &#123;<br>    currentParent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TEXT_TYPE</span>,<br>      text,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析标签生成ast核心</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>) &#123;<br>  <span class="hljs-keyword">while</span> (html) &#123;<br>    <span class="hljs-comment">// 查找&lt;</span><br>    <span class="hljs-keyword">let</span> textEnd = html.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>    <span class="hljs-comment">// 如果&lt;在第一个 那么证明接下来就是一个标签 不管是开始还是结束标签</span><br>    <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果开始标签解析有结果</span><br>      <span class="hljs-keyword">const</span> startTagMatch = <span class="hljs-title function_">parseStartTag</span>();<br>      <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br>        <span class="hljs-comment">// 把解析好的标签名和属性解析生成ast</span><br>        <span class="hljs-title function_">handleStartTag</span>(startTagMatch);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 匹配结束标签&lt;/</span><br>      <span class="hljs-keyword">const</span> endTagMatch = html.<span class="hljs-title function_">match</span>(endTag);<br>      <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>        <span class="hljs-title function_">advance</span>(endTagMatch[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        <span class="hljs-title function_">handleEndTag</span>(endTagMatch[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> text;<br>    <span class="hljs-comment">// 形如 hello&lt;div&gt;&lt;/div&gt;</span><br>    <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 获取文本</span><br>      text = html.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, textEnd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (text) &#123;<br>      <span class="hljs-title function_">advance</span>(text.<span class="hljs-property">length</span>);<br>      <span class="hljs-title function_">handleChars</span>(text);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 匹配开始标签</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseStartTag</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = html.<span class="hljs-title function_">match</span>(startTagOpen);<br><br>    <span class="hljs-keyword">if</span> (start) &#123;<br>      <span class="hljs-keyword">const</span> match = &#123;<br>        <span class="hljs-attr">tagName</span>: start[<span class="hljs-number">1</span>],<br>        <span class="hljs-attr">attrs</span>: [],<br>      &#125;;<br>      <span class="hljs-comment">//匹配到了开始标签 就截取掉</span><br>      <span class="hljs-title function_">advance</span>(start[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br><br>      <span class="hljs-comment">// 开始匹配属性</span><br>      <span class="hljs-comment">// end代表结束符号&gt;  如果不是匹配到了结束标签</span><br>      <span class="hljs-comment">// attr 表示匹配的属性</span><br>      <span class="hljs-keyword">let</span> end, attr;<br>      <span class="hljs-keyword">while</span> (<br>        !(end = html.<span class="hljs-title function_">match</span>(startTagClose)) &amp;&amp;<br>        (attr = html.<span class="hljs-title function_">match</span>(attribute))<br>      ) &#123;<br>        <span class="hljs-title function_">advance</span>(attr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);<br>        attr = &#123;<br>          <span class="hljs-attr">name</span>: attr[<span class="hljs-number">1</span>],<br>          <span class="hljs-attr">value</span>: attr[<span class="hljs-number">3</span>] || attr[<span class="hljs-number">4</span>] || attr[<span class="hljs-number">5</span>], <span class="hljs-comment">//这里是因为正则捕获支持双引号 单引号 和无引号的属性值</span><br>        &#125;;<br>        match.<span class="hljs-property">attrs</span>.<span class="hljs-title function_">push</span>(attr);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (end) &#123;<br>        <span class="hljs-comment">//   代表一个标签匹配到结束的&gt;了 代表开始标签解析完毕</span><br>        <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> match;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//截取html字符串 每次匹配到了就往前继续匹配</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">advance</span>(<span class="hljs-params">n</span>) &#123;<br>    html = html.<span class="hljs-title function_">substring</span>(n);<br>  &#125;<br>  <span class="hljs-comment">//   返回生成的ast</span><br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据-ast-重新生成代码"><a href="#根据-ast-重新生成代码" class="headerlink" title="根据 ast 重新生成代码"></a>根据 ast 重新生成代码</h1><p>拿到生成好的 ast 之后 需要把 ast 转化成类似_c(‘div’,{id:”app”},_c(‘div’,undefined,_v(“hello”+_s(name)),_c(‘span’,undefined,_v(“world”))))这样的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/compiler/codegen.js</span><br><br><span class="hljs-keyword">const</span> defaultTagRE = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>; <span class="hljs-comment">//匹配花括号 &#123;&#123;  &#125;&#125; 捕获花括号里面的内容</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 判断节点类型</span><br>  <span class="hljs-comment">// 主要包含处理文本核心</span><br>  <span class="hljs-comment">// 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式&#123;&#123;&#125;&#125;的处理</span><br><br>  <span class="hljs-comment">// 如果是元素类型</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//   递归创建</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">generate</span>(node);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   如果是文本节点</span><br>    <span class="hljs-keyword">let</span> text = node.<span class="hljs-property">text</span>;<br>    <span class="hljs-comment">// 不存在花括号变量表达式</span><br>    <span class="hljs-keyword">if</span> (!defaultTagRE.<span class="hljs-title function_">test</span>(text)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(text)&#125;</span>)`</span>;<br>    &#125;<br>    <span class="hljs-comment">// 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug</span><br>    <span class="hljs-keyword">let</span> lastIndex = (defaultTagRE.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> tokens = [];<br>    <span class="hljs-keyword">let</span> match, index;<br><br>    <span class="hljs-keyword">while</span> ((match = defaultTagRE.<span class="hljs-title function_">exec</span>(text))) &#123;<br>      <span class="hljs-comment">// index代表匹配到的位置</span><br>      index = match.<span class="hljs-property">index</span>;<br>      <span class="hljs-keyword">if</span> (index &gt; lastIndex) &#123;<br>        <span class="hljs-comment">//   匹配到的&#123;&#123;位置  在tokens里面放入普通文本</span><br>        tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex, index)));<br>      &#125;<br>      <span class="hljs-comment">//   放入捕获到的变量内容</span><br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-string">`_s(<span class="hljs-subst">$&#123;match[<span class="hljs-number">1</span>].trim()&#125;</span>)`</span>);<br>      <span class="hljs-comment">//   匹配指针后移</span><br>      lastIndex = index + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push</span><br>    <span class="hljs-keyword">if</span> (lastIndex &lt; text.<span class="hljs-property">length</span>) &#123;<br>      tokens.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(text.<span class="hljs-title function_">slice</span>(lastIndex)));<br>    &#125;<br>    <span class="hljs-comment">// _v表示创建文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">$&#123;tokens.join(<span class="hljs-string">&quot;+&quot;</span>)&#125;</span>)`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理attrs属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genProps</span>(<span class="hljs-params">attrs</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; attrs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> attr = attrs[i];<br>    <span class="hljs-comment">// 对attrs属性里面的style做特殊处理</span><br>    <span class="hljs-keyword">if</span> (attr.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>      attr.<span class="hljs-property">value</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;;&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>);<br>        obj[key] = value;<br>      &#125;);<br>      attr.<span class="hljs-property">value</span> = obj;<br>    &#125;<br>    str += <span class="hljs-string">`<span class="hljs-subst">$&#123;attr.name&#125;</span>:<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;str.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>&#125;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 生成子节点 调用gen函数进行递归创建</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildren</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> children = el.<span class="hljs-property">children</span>;<br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;children.map((c) =&gt; gen(c)).join(<span class="hljs-string">&quot;,&quot;</span>)&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 递归创建生成code</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title function_">getChildren</span>(el);<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-string">`_c(&#x27;<span class="hljs-subst">$&#123;el.tag&#125;</span>&#x27;,<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    el.attrs.length ? <span class="hljs-string">`<span class="hljs-subst">$&#123;genProps(el.attrs)&#125;</span>`</span> : <span class="hljs-string">&quot;undefined&quot;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;</span><span class="hljs-subst">$&#123;children ? <span class="hljs-string">`,<span class="hljs-subst">$&#123;children&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span>)`</span>;<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="code-字符串生成-render-函数"><a href="#code-字符串生成-render-函数" class="headerlink" title="code 字符串生成 render 函数"></a>code 字符串生成 render 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compileToFunctions</span>(<span class="hljs-params">template</span>) &#123;<br>  <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">generate</span>(ast);<br>  <span class="hljs-comment">// 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值 比如 name值就变成了this.name</span><br>  <span class="hljs-keyword">let</span> renderFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`with(this)&#123;return <span class="hljs-subst">$&#123;code&#125;</span>&#125;`</span>);<br>  <span class="hljs-keyword">return</span> renderFn;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/03.init%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="组件挂载入口"><a href="#组件挂载入口" class="headerlink" title="组件挂载入口"></a>组件挂载入口</h1><p>模板编译解析生成了render函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/init.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span>;<br>  el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>  <br>  <span class="hljs-comment">// 如果不存在 render 属性</span><br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">render</span>) &#123;<br>    <span class="hljs-comment">// 如果存在 template 属性</span><br>    <span class="hljs-keyword">let</span> template = options.<span class="hljs-property">template</span>;<br>    <br>    <span class="hljs-keyword">if</span> (!templage &amp;&amp; el) &#123;<br>      <span class="hljs-comment">// 如果不存在 render 和 template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）</span><br>      template = el.<span class="hljs-property">outerHTML</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终需要把tempalte模板转化成render函数</span><br>    <span class="hljs-keyword">if</span> (template) &#123;<br>      <span class="hljs-keyword">const</span> render = <span class="hljs-title function_">compileToFunctions</span>(template);<br>      options.<span class="hljs-property">render</span> = render;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将当前组件实例挂载到真实的el节点上面</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountComponent</span>(vm, el);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-函数-gt-虚拟-dom-render"><a href="#render-函数-gt-虚拟-dom-render" class="headerlink" title="render 函数 -&gt; 虚拟 dom  _render"></a>render 函数 -&gt; 虚拟 dom  _render</h1><p>执行vm._render()方法 调用生成的render函数 生成虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/render.js</span><br><span class="hljs-keyword">import</span> &#123; createElement, createTextNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/index&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取模板编译生成的render方法</span><br>    <span class="hljs-keyword">const</span> &#123; render &#125; = vm.<span class="hljs-property">$options</span>;<br>    <span class="hljs-comment">// 生成 vnode 虚拟dom</span><br>    <span class="hljs-keyword">const</span> vnode = render.<span class="hljs-title function_">call</span>(vm);<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br><br>  <span class="hljs-comment">// render函数里面有_c _v _s方法需要定义</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_c</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(...args);<br>  &#125;;<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_v</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-comment">// 创建虚拟dom文本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_s</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-comment">// 如果模板里面的是一个对象  需要JSON.stringify</span><br>    <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span><br>      ? <span class="hljs-string">&quot;&quot;</span><br>      : <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;object&quot;</span><br>      ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(val)<br>      : val;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/index.js</span><br><br><span class="hljs-comment">// 定义Vnode类</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vnode</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, data, key, children, text</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建元素vnode 等于render函数里面的 h=&gt;h(App)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag, data = &#123;&#125;, ...children</span>) &#123;<br>  <span class="hljs-keyword">let</span> key = data.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(tag, data, key, children);<br>&#125;<br><br><span class="hljs-comment">// 创建文本vnode</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vnode</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, text);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="虚拟dom-gt-真实-dom-update"><a href="#虚拟dom-gt-真实-dom-update" class="headerlink" title="虚拟dom -&gt;真实 dom   _update"></a>虚拟dom -&gt;真实 dom   _update</h1><p>_update 核心方法就是 patch 初始渲染和后续更新都是共用这一个方法 只是传入的第一个参数不同 初始渲染总体思路就是根据虚拟 dom(vnode) 调用原生 js 方法创建真实 dom 节点并替换掉 el 选项的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><br><span class="hljs-keyword">import</span> &#123; patch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vdom/patch&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-comment">// 把_update挂载在Vue的原型</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// patch是渲染vnode为真实dom核心</span><br>    vm.<span class="hljs-property">$el</span> = <span class="hljs-title function_">patch</span>(vm.<span class="hljs-property">$el</span>, vnode)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/vdom/patch.js</span><br><span class="hljs-comment">// patch 用来渲染和更新视图 （此处仅包含初次渲染的逻辑）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode</span>) &#123;<br>  <span class="hljs-comment">// 判断传入的oldVnode是否是一个真实元素</span><br>  <span class="hljs-comment">// 这里很关键 初次渲染 传入的vm.$el就是咱们传入的el选项  所以是真实dom</span><br>  <span class="hljs-comment">// 如果不是初始渲染而是视图更新的时候  vm.$el就被替换成了更新之前的老的虚拟dom</span><br>  <span class="hljs-keyword">const</span> isRealElement = oldVnode.<span class="hljs-property">nodeType</span>;<br>  <span class="hljs-keyword">if</span> (isRealElement) &#123;<br>    <span class="hljs-comment">// 这里是初次渲染的逻辑</span><br>    <span class="hljs-keyword">const</span> oldElm = oldVnode;<br>    <span class="hljs-keyword">const</span> parentElm = oldElm.<span class="hljs-property">parentNode</span>;<br>    <span class="hljs-comment">// 将虚拟dom转化成真实dom节点</span><br>    <span class="hljs-keyword">let</span> el = <span class="hljs-title function_">createElm</span>(vnode);<br>    <span class="hljs-comment">// 插入到 老的el节点下一个节点的前面 就相当于插入到老的el节点的后面</span><br>    <span class="hljs-comment">// 这里不直接使用父元素appendChild是为了不破坏替换的位置</span><br>    parentElm.<span class="hljs-title function_">insertBefore</span>(el, oldElm.<span class="hljs-property">nextSibling</span>);<br>    <span class="hljs-comment">// 删除老的el节点</span><br>    parentElm.<span class="hljs-title function_">removeChild</span>(oldVnode);<br>    <span class="hljs-keyword">return</span> el;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 虚拟 dom 转成真实 dom 就是调用原生方法生成 dom 树</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; tag, data, key, children, text &#125; = vnode;<br>  <span class="hljs-comment">//   判断虚拟dom 是元素节点还是文本节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   虚拟dom的el属性指向真实dom</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);<br>    <span class="hljs-comment">// 解析虚拟dom属性</span><br>    <span class="hljs-title function_">updateProperties</span>(vnode);<br>    <span class="hljs-comment">// 如果有子节点就递归插入到父节点里面</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElm</span>(child));<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//   文本节点</span><br>    vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);<br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">el</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析vnode的data属性 映射到真实dom上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProperties</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-keyword">let</span> newProps = vnode.<span class="hljs-property">data</span> || &#123;&#125;;<br>  <span class="hljs-keyword">let</span> el = vnode.<span class="hljs-property">el</span>; <span class="hljs-comment">//真实节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-comment">// style需要特殊处理下</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;style&quot;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> newProps.<span class="hljs-property">style</span>) &#123;<br>        el.<span class="hljs-property">style</span>[styleName] = newProps.<span class="hljs-property">style</span>[styleName];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;class&quot;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = newProps.<span class="hljs-property">class</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 给这个元素添加属性 值就是对应的值</span><br>      el.<span class="hljs-title function_">setAttribute</span>(key, newProps[key]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mountComponent-挂载"><a href="#mountComponent-挂载" class="headerlink" title="mountComponent 挂载"></a>mountComponent 挂载</h1><p>使用vm._update()方法把虚拟dom渲染到页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">// 上一步模板编译解析生成了render函数</span><br>  <span class="hljs-comment">// 下一步就是执行vm._render()方法 调用生成的render函数 生成虚拟dom</span><br>  <span class="hljs-comment">// 最后使用vm._update()方法把虚拟dom渲染到页面</span><br>  <span class="hljs-comment">// 真实的el选项赋值给实例的$el属性 为之后虚拟dom产生的新的dom替换老的dom做铺垫</span><br>  vm.<span class="hljs-property">$el</span> = el;<br>  <span class="hljs-comment">// _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="render-和-update-原型方法的混入"><a href="#render-和-update-原型方法的混入" class="headerlink" title="_render 和 _update 原型方法的混入"></a>_render 和 _update 原型方法的混入</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lifecycle&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./render&quot;</span>;<br><span class="hljs-comment">// Vue就是一个构造函数 通过new关键字进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 这里开始进行Vue初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载需要传入Vue</span><br><span class="hljs-comment">// 此做法有利于代码分割</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><br><span class="hljs-comment">// 混入_render</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-comment">// 混入_update</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update render</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/04.update%20render/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello &#123;&#123;a&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 我们在这里模拟更新</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">a</span> = <span class="hljs-number">456</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 此方法是刷新视图的核心</span></span><br><span class="language-javascript">    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在数据变动的时候自动去更新视图</p><h1 id="定义-Watcher"><a href="#定义-Watcher" class="headerlink" title="定义 Watcher"></a>定义 Watcher</h1><p>在 observer 文件夹下新建 watcher.js 代表和观察者相关 可以把 Watcher 当做观察者 它需要订阅数据的变动 当数据变动之后 通知它去执行某些方法 其实本质就是一个构造函数 初始化的时候会去执行 get 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><span class="hljs-comment">// 全局变量id 每次 new Watcher 都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建渲染-Watcher"><a href="#创建渲染-Watcher" class="headerlink" title="创建渲染 Watcher"></a>创建渲染 Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vm, el</span>) &#123;<br>  <span class="hljs-comment">//   _update和._render方法都是挂载在Vue原型的方法  类似_init</span><br><br>  <span class="hljs-comment">// 引入watcher的概念 这里注册一个渲染watcher 执行vm._update(vm._render())方法渲染视图</span><br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;刷新页面&quot;</span>);<br>    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>());<br>  &#125;;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="定义-Dep"><a href="#定义-Dep" class="headerlink" title="定义 Dep"></a>定义 Dep</h1><p>Dep 也是一个构造函数 可以把他理解为观察者模式里面的被观察者 在 subs 里面收集 watcher 当数据变动的时候通知自身 subs 所有的 watcher 更新<br>Dep.target 是一个全局 Watcher 指向 初始状态是 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h1 id="对象的依赖收集"><a href="#对象的依赖收集" class="headerlink" title="对象的依赖收集"></a>对象的依赖收集</h1><p>依赖收集和派发更新的核心 其实就是在数据被访问的时候 把我们定义好的渲染 Watcher 放到 dep 的 subs 数组里面 同时把 dep 实例对象也放到渲染 Watcher 里面去 数据更新时就可以通知 dep 的 subs 存储的 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value);<br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-watcher"><a href="#完善-watcher" class="headerlink" title="完善 watcher"></a>完善 watcher</h1><p>watcher 在调用 getter 方法前后分别把自身赋值给 Dep.target 方便进行依赖收集 update 方法用来更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dep&quot;</span>;<br><br><span class="hljs-comment">// 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exprOrFn</span> = exprOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb; <span class="hljs-comment">//回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//额外的选项 true代表渲染watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++; <span class="hljs-comment">// watcher的唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []; <span class="hljs-comment">//存放dep的容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">//用来去重dep</span><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就会默认调用get方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>(); <span class="hljs-comment">//如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-keyword">let</span> id = dep.<span class="hljs-property">id</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depsId</span>.<span class="hljs-title function_">add</span>(id);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);<br>      <span class="hljs-comment">//   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完善-dep"><a href="#完善-dep" class="headerlink" title="完善 dep"></a>完善 dep</h1><p>定义相关的方法把收集依赖的同时把自身也放到 watcher 的 deps 容器里面去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// dep和watcher是多对多的关系</span><br><span class="hljs-comment">// 每个属性都有自己的dep</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; <span class="hljs-comment">//dep实例的唯一标识</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 这个是存放watcher的容器</span><br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   如果当前存在watcher</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 把自身-dep实例存放在watcher里面</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//   依次执行subs里面的watcher更新方法</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">watcher</span>) =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-comment">//   把watcher加入到自身的subs容器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的依赖收集"><a href="#数组的依赖收集" class="headerlink" title="数组的依赖收集"></a>数组的依赖收集</h1><p>如果对象属性的值是一个数组 那么执行 childOb.dep.depend()收集数组的依赖 如果数组里面还包含数组 需要递归遍历收集 因为只有访问数据触发了 get 才会去收集依赖 一开始只是递归对数据进行响应式处理无法收集依赖 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/index.js</span><br><br><span class="hljs-comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, value</span>) &#123;<br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// childOb就是Observer实例</span><br><br>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 为每个属性实例化一个Dep</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 页面取值的时候 可以把watcher收集到dep里面--依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 如果有watcher dep就会保存watcher 同时watcher也会保存dep</span><br>        dep.<span class="hljs-title function_">depend</span>();<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          <span class="hljs-comment">// 这里表示 属性的值依然是一个对象 包含数组和对象 childOb指代的就是Observer实例对象  里面的dep进行依赖收集</span><br>          <span class="hljs-comment">// 比如&#123;a:[1,2,3]&#125; 属性a对应的值是一个数组 观测数组的返回值就是对应数组的Observer实例对象</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果数据结构类似 &#123;a:[1,2,[3,4,[5,6]]]&#125; 这种数组多层嵌套  数组包含数组的情况  那么我们访问a的时候 只是对第一层的数组进行了依赖收集 里面的数组因为没访问到  所以五大收集依赖  但是如果我们改变了a里面的第二层数组的值  是需要更新页面的  所以需要对数组递归进行依赖收集</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>              <span class="hljs-comment">// 如果内部还是数组</span><br>              <span class="hljs-title function_">dependArray</span>(value); <span class="hljs-comment">// 不停的进行依赖收集</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 如果赋值的新值也是一个对象  需要观测</span><br>      <span class="hljs-title function_">observe</span>(newValue);<br>      value = newValue;<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知渲染watcher去更新--派发更新</span><br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 递归收集数组依赖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dependArray</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e, i = <span class="hljs-number">0</span>, l = value.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    e = value[i];<br>    <span class="hljs-comment">// e.__ob__代表e已经被响应式观测了 但是没有收集依赖 所以把他们收集到自己的Observer实例的dep里面</span><br>    e &amp;&amp; e.<span class="hljs-property">__ob__</span> &amp;&amp; e.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(e)) &#123;<br>      <span class="hljs-comment">// 如果数组里面还有数组  就递归去收集依赖</span><br>      <span class="hljs-title function_">dependArray</span>(e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的派发更新"><a href="#数组的派发更新" class="headerlink" title="数组的派发更新"></a>数组的派发更新</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/array.js</span><br><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">//   这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 这句话是关键</span><br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性代表的是该数据已经被响应式观察过了 __ob__对象指的就是Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted); <span class="hljs-comment">// 对新增的每一项进行观测</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">//数组派发更新 ob指的就是数组对应的Observer实例 我们在get的时候判断如果属性的值还是对象那么就在Observer实例的dep收集依赖 所以这里是一一对应的  可以直接更新</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>watch</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/05.watch/</url>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>侦听属性的写法很多 可以写成 字符串 函数 数组 以及对象 对于对象的写法自己可以增加一些 options 用来增强功能 侦听属性的特点是监听的值发生了变化之后可以执行用户传入的自定义方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;&#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">aa</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: &#x27;doSomething&#x27;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">// aa: [&#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   handle(newVal， oldVal) &#123;</span></span><br><span class="language-javascript">      <span class="hljs-comment">//     console.log(newVal);</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">      <span class="hljs-comment">//   deep: true</span></span><br><span class="language-javascript">      <span class="hljs-comment">// &#125;]</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">aa</span> = <span class="hljs-number">1111</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 统一初始化数据的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-title function_">initWatch</span>(vm);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 watch</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> watch = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">watch</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> watch) &#123;<br>    <span class="hljs-keyword">const</span> handler = watch[k]; <span class="hljs-comment">// 用户自定义 watch 的写法，可能是数组 对象 函数 字符串</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;<br>      <span class="hljs-comment">// 如果是数组就遍历进行创建</span><br>      handler.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">handle</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, k, handle);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, k, handler);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建watcher的核心</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span>(<span class="hljs-params">vm, exprOrFn, handler, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    options = handler; <span class="hljs-comment">//保存用户传入的对象</span><br>    handler = handler.<span class="hljs-property">handler</span>; <span class="hljs-comment">//这个代表真正用户传入的函数</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//   代表传入的是定义好的methods方法</span><br>    handler = vm[handler];<br>  &#125;<br>  <span class="hljs-comment">//   调用vm.$watch创建用户watcher</span><br>  <span class="hljs-keyword">return</span> vm.$watch(exprOrFn, handler, options);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h1><p>原型方法$watch 就是创建自定义 watch 的核心方法 把用户定义的 options 和 user:true 传给构造函数 Watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observer/watcher&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">experOrFn, cb, option</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">let</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, exprOrFn, cb, &#123; ...options, <span class="hljs-attr">user</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-comment">// 如果有immediate属性 代表需要立即执行回调</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">cb</span>(); <span class="hljs-comment">// 如果立刻执行</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-keyword">import</span> &#123; isObject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/index&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = options.<span class="hljs-property">user</span>; <span class="hljs-comment">//标识用户watcher</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exprOrFn === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>        <span class="hljs-keyword">let</span> path = exprOrFn.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">let</span> obj = vm;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>          obj = obj[path[i]]; <span class="hljs-comment">//vm.a.a.a.a.b</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 实例化就进行一次取值操作 进行依赖收集过程</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-comment">//   get() &#123;</span><br>  <span class="hljs-comment">//     pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>  <span class="hljs-comment">//     const res = this.getter.call(this.vm); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集</span><br>  <span class="hljs-comment">//     popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>  <span class="hljs-comment">//     return res;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-comment">//   update() &#123;</span><br>  <span class="hljs-comment">//     // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>  <span class="hljs-comment">//     if (this.lazy) &#123;</span><br>  <span class="hljs-comment">//       this.dirty = true;</span><br>  <span class="hljs-comment">//     &#125;else&#123;</span><br>  <span class="hljs-comment">//       // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>  <span class="hljs-comment">//       // 异步队列机制</span><br>  <span class="hljs-comment">//       queueWatcher(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   depend()&#123;</span><br>  <span class="hljs-comment">//     // 计算属性的watcher存储了依赖项的dep</span><br>  <span class="hljs-comment">//     let i=this.deps.length</span><br>  <span class="hljs-comment">//     while(i--)&#123;</span><br>  <span class="hljs-comment">//       this.deps[i].depend() //调用依赖项的dep去收集渲染watcher</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newVal = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">//新值</span><br>    <span class="hljs-keyword">const</span> oldVal = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">//老值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = newVal; <span class="hljs-comment">//现在的新值将成为下一次变化的老值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>      <span class="hljs-comment">// 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址</span><br>      <span class="hljs-keyword">if</span> (newVal !== oldVal || <span class="hljs-title function_">isObject</span>(newVal)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, newVal, oldVal);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 渲染watcher</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/06.computed/</url>
    
    <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>在两秒之后改变了模板里面的 cc 但是计算属性依赖的 aa 和 bb 都没变化 所以计算属性不会重新计算 还是保留的上次计算结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// Vue实例化</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">cc</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// render(h) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   return h(&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,&#x27;hello&#x27;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;a&quot;&gt;hello 这是我自己写的Vue&#123;&#123;computedName&#125;&#125;&#123;&#123;cc&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">computedName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">aa</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bb</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-comment">// 当我们每一次改变数据的时候  渲染watcher都会执行一次 这个是影响性能的</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    vm.<span class="hljs-property">cc</span> = <span class="hljs-number">4</span>;</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">2000</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="计算属性的初始化"><a href="#计算属性的初始化" class="headerlink" title="计算属性的初始化"></a>计算属性的初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">const</span> computed = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">computed</span>;<br>  <span class="hljs-keyword">const</span> watchers = (vm.<span class="hljs-property">_computedWatchers</span> = &#123;&#125;); <span class="hljs-comment">// 用来存放计算 watcher</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> coumputed) &#123;<br>    <span class="hljs-keyword">const</span> userEdf = computed[k]; <span class="hljs-comment">// 获取用户定义的计算属性</span><br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span>;<span class="hljs-comment">//创建计算属性watcher使用</span><br>    <span class="hljs-comment">// 创建计算watcher lazy设置为true</span><br>    watchers[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, <span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;);<br>    <span class="hljs-title function_">defineComputed</span>(vm, k, userDef);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对计算属性进行属性劫持"><a href="#对计算属性进行属性劫持" class="headerlink" title="对计算属性进行属性劫持"></a>对计算属性进行属性劫持</h1><p><code>defineComputed</code> 方法主要是重新定义计算属性 其实最主要的是劫持 get 方法 也就是计算属性依赖的值。<br>需要根据依赖值是否发生变化来判断计算属性是否需要重新计算<br><code>createComputedGetter</code> 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 <code>Watcher</code> 增加 <code>dirty</code> 标志位 如果标志变为 <code>true</code> 代表需要调用 <code>watcher.evaluate</code> 来进行重新计算了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-comment">// 定义普通对象用来劫持计算属性</span><br><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;<br><span class="hljs-comment">// 重新定义计算属性 对 get 和 set 劫持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key, userDef</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果是一个函数  需要手动赋值到get上</span><br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-title function_">createComputedGetter</span>(key);<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = userDef.<span class="hljs-property">set</span>;<br>  &#125;<br>  <span class="hljs-comment">//   利用Object.defineProperty来对计算属性的get和set进行劫持</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition);<br>&#125;<br><span class="hljs-comment">// 重写计算属性的 get 方法，来判断是否需要进行重新计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]; <span class="hljs-comment">//获取对应的计算属性watcher</span><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;<br>        watcher.evaluate(); <span class="hljs-comment">//计算属性取值的时候 如果是脏的  需要重新求值</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>1.实例化的时候如果是计算属性 不会去调用 get 方法访问值进行依赖收集<br>2.update 方法只是把计算 watcher 的 dirty 标识为 true 只有当下次访问到了计算属性的时候才会重新计算<br>3.新增 evaluate 方法专门用于计算属性重新计算<br>4.新增 depend 方法 让计算属性的依赖值收集外层 watcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/watcher.js</span><br><br><span class="hljs-comment">// import &#123; pushTarget, popTarget &#125; from &quot;./dep&quot;;</span><br><span class="hljs-comment">// import &#123; queueWatcher &#125; from &quot;./scheduler&quot;;</span><br><span class="hljs-comment">// import &#123;isObject&#125; from &#x27;../util/index&#x27;</span><br><span class="hljs-comment">// // 全局变量id  每次new Watcher都会自增</span><br><span class="hljs-comment">// let id = 0;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>) &#123;<br>    <span class="hljs-comment">// this.vm = vm;</span><br>    <span class="hljs-comment">// this.exprOrFn = exprOrFn;</span><br>    <span class="hljs-comment">// this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法</span><br>    <span class="hljs-comment">// this.options = options; //额外的选项 true代表渲染watcher</span><br>    <span class="hljs-comment">// this.id = id++; // watcher的唯一标识</span><br>    <span class="hljs-comment">// this.deps = []; //存放dep的容器</span><br>    <span class="hljs-comment">// this.depsId = new Set(); //用来去重dep</span><br>    <span class="hljs-comment">// this.user = options.user; //标识用户watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//标识计算属性watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">//dirty可变  表示计算watcher是否需要重新计算 默认值是true</span><br><br>    <span class="hljs-comment">// 如果表达式是一个函数</span><br>    <span class="hljs-comment">// if (typeof exprOrFn === &quot;function&quot;) &#123;</span><br>    <span class="hljs-comment">//   this.getter = exprOrFn;</span><br>    <span class="hljs-comment">// &#125; else &#123;</span><br>    <span class="hljs-comment">//   this.getter = function () &#123;</span><br>    <span class="hljs-comment">//     //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b</span><br>    <span class="hljs-comment">//     let path = exprOrFn.split(&quot;.&quot;);</span><br>    <span class="hljs-comment">//     let obj = vm;</span><br>    <span class="hljs-comment">//     for (let i = 0; i &lt; path.length; i++) &#123;</span><br>    <span class="hljs-comment">//       obj = obj[path[i]]; //vm.a.a.a.a.b</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return obj;</span><br>    <span class="hljs-comment">//   &#125;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用方法之前先把当前watcher实例推到全局Dep.target上</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>); <span class="hljs-comment">//计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来</span><br>    <span class="hljs-title function_">popTarget</span>(); <span class="hljs-comment">// 在调用方法之后把当前watcher实例从全局Dep.target移除</span><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">//   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次</span><br>  <span class="hljs-comment">//   addDep(dep) &#123;</span><br>  <span class="hljs-comment">//     let id = dep.id;</span><br>  <span class="hljs-comment">//     if (!this.depsId.has(id)) &#123;</span><br>  <span class="hljs-comment">//       this.depsId.add(id);</span><br>  <span class="hljs-comment">//       this.deps.push(dep);</span><br>  <span class="hljs-comment">//       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面</span><br>  <span class="hljs-comment">//       dep.addSub(this);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">//   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用</span><br>      <span class="hljs-comment">// 异步队列机制</span><br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   计算属性重新进行计算 并且计算完成把dirty置为false</span><br>  <span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 计算属性的watcher存储了依赖项的dep</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">//调用依赖项的dep去收集渲染watcher</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   run() &#123;</span><br>  <span class="hljs-comment">//     const newVal = this.get(); //新值</span><br>  <span class="hljs-comment">//     const oldVal = this.value; //老值</span><br>  <span class="hljs-comment">//     this.value = newVal; //跟着之后  老值就成为了现在的值</span><br>  <span class="hljs-comment">//     if (this.user) &#123;</span><br>  <span class="hljs-comment">//       if(newVal!==oldVal||isObject(newVal))&#123;</span><br>  <span class="hljs-comment">//         this.cb.call(this.vm, newVal, oldVal);</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     &#125; else &#123;</span><br>  <span class="hljs-comment">//       // 渲染watcher</span><br>  <span class="hljs-comment">//       this.cb.call(this.vm);</span><br>  <span class="hljs-comment">//     &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="外层-Watcher-的依赖收集"><a href="#外层-Watcher-的依赖收集" class="headerlink" title="外层 Watcher 的依赖收集"></a>外层 Watcher 的依赖收集</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-comment">//   return function () &#123;</span><br><span class="hljs-comment">//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher</span><br><span class="hljs-comment">//     if (watcher) &#123;</span><br><span class="hljs-comment">//       if (watcher.dirty) &#123;</span><br><span class="hljs-comment">//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-comment">// 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集</span><br>          watcher.<span class="hljs-title function_">depend</span>()<br>        &#125;<br><span class="hljs-comment">//       &#125;</span><br><span class="hljs-comment">//       return watcher.value;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>计算属性依赖的值发生了改变 这时候 watcher 的 dirty 为 true 下次访问计算属性 ,此时数据改变了，但是还没触发视图更新<br>因为模板里面只有计算属性 而计算属性的依赖值的 dep 里面只收集了计算 watcher 的依赖 。<br>自身变化也只是通知了计算 watcher 调用 update 把 dirty 置为 true 。<br>所以需要把计算属性的依赖项也添加渲染 watcher 的依赖。<br>让自身变化之后首先通知计算 watcher 进行重新计算 然后通知渲染 watcher 进行视图更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/observer/dep.js</span><br><br><span class="hljs-comment">// 默认Dep.target为null</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 栈结构用来存watcher</span><br><span class="hljs-keyword">const</span> targetStack = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(watcher);<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher; <span class="hljs-comment">// Dep.target指向当前watcher</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当前watcher出栈 拿到上一个watcher</span><br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>可见最初设计存放 watcher 的容器就是一个栈结构。<br>因为整个 Vue 生命周期的过程中会存在很多的 watcher 比如渲染 watcher 计算 watcher 侦听 watcher 等。<br>而每个 watcher 在调用了自身的 get 方法前后会分别调用 pushTarget 入栈和 popTarget 出栈。<br>这样子当计算属性重新计算之后就立马会出栈 那么外层的 watcher 就会成为新的 Dep.target。<br>使用 watcher.depend 方法让计算属性依赖的值收集一遍外层的渲染 watcher 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/"/>
    <url>/2023/04/26/%E7%BD%91%E7%BB%9C/01.HTTP/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><h4 id="header-body"><a href="#header-body" class="headerlink" title="header + body"></a>header + body</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">起始行+头部+空行+实体<br></code></pre></td></tr></table></figure><h4 id="请求报文的结构"><a href="#请求报文的结构" class="headerlink" title="请求报文的结构"></a>请求报文的结构</h4><h5 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/home</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p>方法 + 路径 + http 版本</p><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>请求体</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><ul><li>GET <ul><li>通常用来获取资源</li></ul></li><li>HEAD <ul><li>获取资源的元信息</li></ul></li><li>POST <ul><li>上传数据</li><li>会分成两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发出 body 部分。(火狐浏览器除外，他的 POST 请求只发一个 TCP 包)</li></ul></li><li>PUT <ul><li>修改完整数据</li></ul></li><li>PATCH <ul><li>修改部分数据</li></ul></li><li>DELETE <ul><li>删除资源</li></ul></li><li>CONNECT <ul><li>建立连接隧道，用于代理服务器</li></ul></li><li>OPTIONS <ul><li>列出可对资源实行的请求方法，用来跨域请求</li></ul></li><li>TRACE <ul><li>追求请求-响应传输的路径</li></ul></li></ul><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p>URI(Uniform Resource Identifier) 统一资源标识符，作用：区分互联网上不同的资源</p><p>网址：URL，URI 包含了 URL 和 URN 两个部分，</p><h6 id="URI的结构："><a href="#URI的结构：" class="headerlink" title="URI的结构："></a>URI的结构：</h6><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" alt="image.png"></p><p><strong>scheme</strong> 表示协议名，比如 http, https, file 等等。后面必须和:&#x2F;&#x2F;连在一起</p><p>**user:password@**表示登录主机时的用户信息，很不安全，不推荐使用，不常用</p><p><strong>host:port</strong>表示主机名和端口</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为key&#x3D;val这种形式，多个键值对之间用&amp;隔开</p><p><strong>fagment</strong>表示 URI 所定位的资源内的一个 <strong>锚点</strong>，浏览器可以通过这个锚点跳转到对于的 位置</p><h5 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h5><p><strong>URI</strong> 只能使用 <strong>ASCII</strong>，<strong>ASCLII</strong>之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错</p><p>因此，<strong>URI</strong> 引入了编码机制，将所有 <strong>非 ASSCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个 <strong>%</strong></p><p>例：空格转义为**%20**</p><h4 id="响应报文的结构"><a href="#响应报文的结构" class="headerlink" title="响应报文的结构"></a>响应报文的结构</h4><h5 id="起始行也叫状态行"><a href="#起始行也叫状态行" class="headerlink" title="起始行也叫状态行"></a>起始行也叫状态行</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><p>http 版本 + 状态码 + 原因</p><h5 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h5><ul><li><strong>1xx：</strong>表示目前是协议处理中的中间状态，还需要后续操作。 <ul><li><strong>101 Switching Protocols</strong> 在 HTTP 升级为 webSocket 的时候，如果服务器同意变更，就会发送状态码 101</li></ul></li><li><strong>2xx：</strong>  表示成功状态。 <ul><li><strong>200 OK</strong> 成功状态码，响应体中有数据。</li><li><strong>204 No Content</strong> 成功状态码，响应体中无数据。</li><li><strong>206 Partial Content</strong> 表示部分内容，使用场景为：HTTP 分块下载和断点续传，会带上相应的响应头字段 Content-Range。</li></ul></li><li><strong>3xx：</strong>重定向状态，资源位置发生变动，需要重新请求 <ul><li><strong>301 Moved Permanently</strong> 永久重定向 </li><li><strong>302 Found</strong> 临时重定向<br>例：<br> 以前的站点再也不用了返回 301，浏览器会默认做优化缓存，在第二次访问的时候自动访问重定向的那个地址。<br> 以前的站点暂时不可用，直接返回 302 ，浏览器不会做缓存优化 </li><li><strong>304 Not Modified</strong> 当协商缓存命中时会返回这个状态码。</li></ul></li><li><strong>4xx：</strong>请求报文有误 <ul><li><strong>400 Bad Request</strong> 服务器无法理解该请求 可能是语法错误。</li><li><strong>403 Forbidden</strong> 服务器禁止访问。</li><li><strong>404 Not Found</strong> 资源未找到，没在服务器上找到相应的资源。</li><li><strong>405 Method Not Allowed</strong> 请求方法不被服务器允许。</li><li><strong>406 Not Acceptable</strong> 资源无法满足客户端的条件。</li><li><strong>408 Request Timeout</strong> 服务器等待了太长时间。</li><li><strong>409 Conflict</strong> 多个请求发生了冲突。</li><li><strong>413 Request Entity Too Large</strong> 请求体的数据过大。</li></ul></li><li><strong>5xx</strong> <ul><li><strong>500 Internal Server Error</strong> 服务器出错</li><li><strong>501 Not Implemented</strong> 客户端请求的功能还不支持。</li><li><strong>502 Bad Gateway</strong> 服务器自身是正常的，但是访问的时候出错了。</li><li><strong>503 Service Unavailable</strong> 服务器当前很忙，暂时无法响应服务。</li></ul></li><li><strong>5xx：</strong>服务端发生错误</li></ul><h3 id="HTTP特点以及缺点"><a href="#HTTP特点以及缺点" class="headerlink" title="HTTP特点以及缺点"></a>HTTP特点以及缺点</h3><h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><ol><li>灵活可拓展 <ol><li>语义上自由，只有基本格式没有严格限制</li><li>传输形式多样性，可以传输文本、图片、视频等任意数据</li></ol></li><li>可靠传输，HTTP基于 TCP&#x2F;IP ，这是 TCP 的特性</li><li>请求-应答，一发一收、有来有回。</li><li>无状态，状态：通信过程的上下文信息，每次 http 请求都是独立、无关的，默认不需要保留状态信息</li></ol><h4 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h4><ol><li>无状态</li></ol><ul><li>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，此时是缺点</li><li>在只是获取一些数据的场景中，不需要保存连接上下文信息，无状态减少了网络开销，此时是优点</li></ul><ol start="2"><li>明文传输<br>协议里的报文（主要指头部）不使用二进制数据，而是文本形式<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<strong>WIFI陷阱</strong> 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。 </li><li>队头阻塞问题</li></ol><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><h3 id="Accept-系列字段"><a href="#Accept-系列字段" class="headerlink" title="Accept 系列字段"></a>Accept 系列字段</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>发送端：Content-Type 字段</p><p>接收端：Accept 字段</p><p>取值：</p><pre><code class="hljs">text： text/html, text/plain, text/css 等image: image/gif, image/jpeg, image/png 等audio/video: audio/mpeg, video/mp4 等application: application/json, application/javascript, application/pdf, application/octet-stream</code></pre><h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>发送方：Content-Encoding</p><p>接受方：Accept-Encoding</p><p>取值:</p><pre><code class="hljs">gzip:最流行的压缩格式deflate:另一种著名的压缩格式br:一种专门为 HTTP 发明的压缩算法</code></pre><h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>发送端：Content-Language</p><p>接收方：Accept-Language</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>发送方：Content-Type:charset&#x3D;utf-8</p><p>接收端：Accept-Charset:charset&#x3D;utf-8</p><h3 id="HTTP对定长和不定长数据传输的处理"><a href="#HTTP对定长和不定长数据传输的处理" class="headerlink" title="HTTP对定长和不定长数据传输的处理"></a>HTTP对定长和不定长数据传输的处理</h3><h4 id="定长包"><a href="#定长包" class="headerlink" title="定长包"></a>定长包</h4><p>发送端带上Content-length</p><h4 id="不定长包"><a href="#不定长包" class="headerlink" title="不定长包"></a>不定长包</h4><p>发送端带上 Transfer-Encoding: chunked</p><p>表示分块传输数据，设置这个字段后会自动产生两个效果</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推动动态内容</li></ul><h3 id="HTTP-处理大文件传输"><a href="#HTTP-处理大文件传输" class="headerlink" title="HTTP 处理大文件传输"></a>HTTP 处理大文件传输</h3><p>采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分</p><p>服务端发送：</p><p>添加上 Accept-Ranges:none 响应头，来告诉客户端这边年支持范围请求</p><p>客户端：</p><p>Range 字段拆解，客户端需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes&#x3D;x-y</p><p>Range 的书写格式：</p><pre><code class="hljs">0-499 表示从开始到第 499 个字节。500- 表示从第 500 字节到文件终点。-100 表示文件最后 100 个字节。</code></pre><p>服务端接收：</p><pre><code class="hljs">接受到请求之后，先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码同时服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同而又所差异</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// 单段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9<br>// 多段数据<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-9, 30-39<br></code></pre></td></tr></table></figure><h3 id="HTTP1-1解决HTTP队头阻塞问题"><a href="#HTTP1-1解决HTTP队头阻塞问题" class="headerlink" title="HTTP1.1解决HTTP队头阻塞问题"></a>HTTP1.1解决HTTP队头阻塞问题</h3><p>HTTP传输基于 请求-应答的模式进行，传输任务是放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p><h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>一个域名可以并发 6 个长连接，多分几个域名</p><p>这样一个 baidu.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>HTTP是无状态的协议，需要保存状态就引入了Cookie</p><p>Cookie 本身是浏览器里面存储的一个很小的本地文件，内部以键值对的方式存储。同一个域名下发送请求，都会携带相同的 Cookie ，服务器拿到 Cookie 进行解析，就可以拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 请求头<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>a=xxx;b=xxx<br>// 响应头<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>a=xxx<br><span class="hljs-attribute">set-Cookie</span><span class="hljs-punctuation">: </span>b=xxx<br></code></pre></td></tr></table></figure><h4 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h4><p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置</p><ul><li>Expires 即过期时间</li><li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算</li></ul><p>若Cookie过期，则这个Cookie会被删除，并不会发送给服务端</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域有两个属性：Domain和path，都给Cookie绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上Cookie。对于路径来说，&#x2F;表示域名下的任意路径都允许使用Cookie。</p><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果带上Secure，说明只能通过 HTTPS 传输 cookie。</p><p>如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p><p>CSRF攻击的预防可以通过SameSite属性。</p><p>SameSite 可以设置为三个值：Strict、Lax和None。</p><ol><li>在 Strict 模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>baidu.com</code>网站只能在<code>baidu.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</li><li>在 Lax 模式下，宽松一点，只能在 get 方法提交表单 或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li><li>在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ol><h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ol><li>容量缺陷 体积上限是 4kB</li><li>性能缺陷 Cookie紧跟域名，不管域名下面的某一个子域名需不需要这个 Cookie 请求都会携带上完整的Cookie，请求数量一多会照成巨大的性能浪费，可以通过 Domain 和 Path 指定作用域来解决。</li><li>安全缺陷，由于 Cookie 以纯文本的形式传递很容易被非法用户截获，然后进行一系列篡改，在Cookie的有效期内重新推送给服务器，在 HttpOnly 为 false 的情况下，Cookie信息能直接通过 JS 脚本来读取。</li></ol><h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><p>HTTP基于请求-响应模型的协议，一般由客户端发请求，服务器来响应</p><p>如果有代理服务器，引入代理之后，作为代理的服务器相当与一个中间人的角色，对于客户端表现为服务器进行响应，对于源服务器表现为客户端发起请求，具有双重身份。</p><h4 id="HTTP-代理的功能"><a href="#HTTP-代理的功能" class="headerlink" title="HTTP 代理的功能"></a>HTTP 代理的功能</h4><ol><li><strong>负载均衡</strong>： <ol><li>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li></ol></li><li><strong>保障安全:</strong> <ol><li>利用心跳机制监控后台服务器，一旦发现故障机就将其踢出集群，并且对于上下行的数据进行过滤，对于非法IP限流，这些都是代理服务器的工作</li></ol></li><li><strong>缓存代理：</strong> <ol><li>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得，而不用到的源服务器那里获得。</li></ol></li></ol><h4 id="相关头字段"><a href="#相关头字段" class="headerlink" title="相关头字段"></a>相关头字段</h4><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><pre><code class="hljs">代理服务器通过 Via 字段在 HTTP 传输中留下自己的痕迹Via中的代理的顺序即为在 HTTP 传输中报文传达的顺序</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">// 客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器<br>// 源服务器收到请求后，请求头<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>proxy_server1,proxy_server2<br>// 源服务器响应时候，客户端的响应头<br>Via:proxy_server2,proxr_server1<br></code></pre></td></tr></table></figure><h5 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h5><pre><code class="hljs">为谁转发，记录的是请求方的IP地址</code></pre><h5 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h5><pre><code class="hljs">获取用户真实IP的字段，不管中间经过了多少代理，这个字段始终记录最初客户端的IP对应的有 **X-Forwarded-Host** 和 **X-forwarded-Proto**，分别记录客户端(不包括代理)的域名和协议名</code></pre><h5 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h5><pre><code class="hljs">此字段是记录请求方的IP，意味着每经过一个不同的代理，这个字段的名字都要改变，从客户端到代理1，这个字段是客户端的IP，从代理1到代理2，这个字段变成了代理1的IP</code></pre><p>意味着会产生两个问题：</p><ol><li>代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降</li><li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的</li></ol><p>由此产生了 <strong>代理协议</strong> ，一般使用明文版本，只需要在HTTP请求行上面加上这样格式的文本即可:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接受端口<br>PREOXY TCP4 0.0.0.1 0.0.0.2 1111 2222<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以解决X-Forwarded-For产生的问题</p><h3 id="HTTP缓存及缓存代理"><a href="#HTTP缓存及缓存代理" class="headerlink" title="HTTP缓存及缓存代理"></a>HTTP缓存及缓存代理</h3><h4 id="关于-强缓存-和-协商缓存"><a href="#关于-强缓存-和-协商缓存" class="headerlink" title="关于 强缓存 和 协商缓存"></a>关于 <strong>强缓存</strong> 和 <strong>协商缓存</strong></h4><p>首先通过 Cache-Control 验证强缓存是否可用</p><ul><li>如果强缓存可用，直接使用</li><li>否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新 <ul><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存中获取资源</li></ul></li></ul><h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><p>对于服务器来说，也是有缓存的，比如Redis，Memcache，但对于HTTP缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的</p><p>由此引入了缓存代理的机制，让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候就能明显降低源服务器的压力</p><h5 id="代理缓存的实现："><a href="#代理缓存的实现：" class="headerlink" title="代理缓存的实现："></a>代理缓存的实现：</h5><ul><li>代理缓存的控制分为两个部分，一部分是源服务器端的控制，一部分是客户端的控制</li></ul><h6 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h6><p><strong>private 和 public</strong></p><p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入priivate或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。</p><p>对于一些比较私密的数据，如果缓存到代理服务器上，比如直接访问代理就可以直接拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头的Cache-Control设为private，而不是public</p><p><strong>proxy-revalidate</strong></p><p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取</p><p><strong>s-maxage</strong></p><p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:public,max-age=1000,s-maxage=2000<br></code></pre></td></tr></table></figure><p>相当于源服务器说：我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理服务器中拿，并且客户端的缓存时间为1000秒，在代理服务器中的缓存时间为2000秒</p><h6 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h6><h6 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h6><p>在客户端的请求头中，可以加入两个字段，来对代理服务器上的缓存进行宽容和限制的操作</p><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">max-stale:5<br></code></pre></td></tr></table></figure><p>表示客户端到代理服务器上那缓存的时候，即使缓存过期了也不要紧，只要在过期时间在5秒之内，还可以从代理中获取的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">min-fresh:5<br></code></pre></td></tr></table></figure><p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前5秒之前的时间拿，否则拿不到</p><h6 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h6><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>因为浏览器遵循同源政策(协议、主机和端口都相同则为同源)。非同源站点有这样一些限制:</p><ul><li>不能读取和修改对方的DOM</li><li>不能访问对方的Cookie、IndexDb和LocalStorage</li><li>限制XMLHttpRequest请求。</li></ul><p>当浏览器向着目标URI发出Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被称为跨域请求。</p><p>跨域请求的响应会被浏览器所拦截，响应是成功到达客户端了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>跨域资源共享</p><p>它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头</p><p><strong>简单请求</strong></p><ul><li>请求方法为GET、POST或者HEAD </li><li>请求头的取值范围：Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain) </li><li>简单请求跨域处理 <ul><li><p>请求发出去前，在请求头中添加一个Origin字段，说明请求来自于哪个源。服务器拿到请求之后，在回应时对应地添加<strong>Access-Control-Allow-Origin</strong>字段，如果Origin不在这个字段范围内，浏览器就会将响应拦截。 </p></li><li><p><strong>Access-Control-Allow-Credentials</strong> 字段 是一个布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器这个字段默认值设为false，如果需要拿到浏览器的Cookie，添加此字段并设置为true，并且在前端也需要设置withCredentials属性：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>Access-Control-Expose-Headers</strong> 这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）还能拿到这个字段生命的响应头字段，例子：</p></li></ul></li></ul><p>前端可以通过XMLHttpRequest.getResponseHeader(‘aaa’)拿到 aaa这个字段的值。 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: aaa<br></code></pre></td></tr></table></figure><p><strong>非简单请求</strong></p><ul><li>除简单请求之外的请求都是非简单请求 </li><li>浏览器以及跨域处理 <ul><li>预检请求和响应字段 <ul><li>发送非简单请求之前要先发送预检请求<br>预检请求的方法是OPTIONS，同时加上Origin源地址和Host目标地址，同时也加上两个关键字段 <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>当前地址<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><ul><li>Access-Control-Request-Method，列出请求用到哪个HTTP方法</li><li>Access-Control-Request-Headers，指定CORS请求将要加上什么请求头</li></ul></li><li><h2 id="响应字段-预检查的响应"><a href="#响应字段-预检查的响应" class="headerlink" title="响应字段-  预检查的响应 "></a>响应字段<br>-  预检查的响应 </h2></li></ul></li></ul></li></ul><p><strong>Access-Control-Allow-Origin</strong>: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。<br><strong>Access-Control-Allow-Methods</strong>: 表示允许的请求方法列表。<br><strong>Access-Control-Allow-Credentials</strong>: 简单请求中已经介绍。<br><strong>Access-Control-Allow-Headers</strong>: 表示允许发送的请求头字段<br><strong>Access-Control-Max-Age</strong>: 预检请求的有效期，在此期间，不用发出另外一条预检请求。<br>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS请求</strong>也不会发出去了。 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br></code></pre></td></tr></table></figure><pre><code class="hljs">     -  CORS的响应         - 现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。</code></pre><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">jsonp</span> = (<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateURL</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;<br>    &#125;<br>    dataStr += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化回调函数名称</span><br>    callbackName = callbackName || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-property">toString</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <br>    <span class="hljs-comment">// 创建 script 元素并加入到当前文档中</span><br>    <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    scriptEle.<span class="hljs-property">src</span> = <span class="hljs-title function_">generateURL</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(scriptEle);<br>    <span class="hljs-comment">// 绑定到 window 上，为了后面调用</span><br>    <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>      <span class="hljs-comment">// script 执行完了，成为无用元素，需要清除</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(scriptEle);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; a, b, callback &#125; = req.<span class="hljs-property">query</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 2</span><br>  <span class="hljs-comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>前端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 拿到数据进行处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 数据包</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>Nginx反向代理<br><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network02.png" alt="image.png"></p><p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p><p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p><p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p><p>解决跨域：</p><p>例子：客户端域名为client.con，服务器域名为server.com</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server &#123;<br>  listen  <span class="hljs-number">80</span>;<br>  server_name  client.<span class="hljs-property">com</span>;<br>  location /api &#123;<br>    proxy_pass server.<span class="hljs-property">com</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手其实就是建立一个TCP连接时，需要客户端和服务器总共发3个包。</p><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>SYN（Synchronize同步的缩写）表示建立连接</p><p>ACK （acknowledge character 确认字符的缩写）表示响应</p><p>具体过程：</p><p>刚开始客户端处于Closed的状态，服务端处于Listen状态。进行三次握手</p><ul><li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND（同步已发送）状态。 <ul><li>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</li></ul></li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的SYN报文作为答应，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN（初始序列号seq）+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD（同步收到）的状态。 <ul><li>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</li></ul></li><li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED（已建立连接）状态。服务器收到ACK报文之后，也处于ESTABLISHED（已建立连接）状态，此时，双方已建立起了连接。 <ul><li>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号</li></ul></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在 socket 编程中，客户端执行 connect() 时，将触发三次握手</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network03.png" alt="image.png"></p><h4 id="半连接队列-x2F-全连接队列"><a href="#半连接队列-x2F-全连接队列" class="headerlink" title="半连接队列&#x2F;全连接队列"></a>半连接队列&#x2F;全连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong></p><p>就是已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ol><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network04.png" alt="image.png"></p><p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p><blockquote><p>LISTEN - 侦听来自远方TCP端口的连接请求；</p></blockquote><blockquote><p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p></blockquote><blockquote><p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p></blockquote><blockquote><p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p></blockquote><blockquote><p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><blockquote><p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p></blockquote><blockquote><p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p></blockquote><blockquote><p>CLOSING -等待远程TCP对连接中断的确认；</p></blockquote><blockquote><p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><blockquote><p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><blockquote><p>CLOSED - 没有任何连接状态；</p></blockquote><h3 id="HTTP-x2F-2的改进"><a href="#HTTP-x2F-2的改进" class="headerlink" title="HTTP&#x2F;2的改进"></a>HTTP&#x2F;2的改进</h3><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>在HTTP&#x2F;1.1及以前的时代，请求头一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，如果请求字段非常复杂的时候，尤其是GET请求，请求报文几乎全是请求头，这个时候优化空间很大，</p><p>而HTTP&#x2F;2针对头部字段，采用了对应的压缩算法-HPACK，对请求头进行压缩。</p><p>HPACK算法的两个亮点</p><ul><li>首先是在服务端和客户端之前建立哈希表，将用到的字段存放在这张表中，那么在传输的时候，对于之前出现过的值，只需要传递索引给对方即可，对方拿到索引查表就可以了</li><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051317419-92d7195d-319d-4ea4-9bb4-b3eef2690ff4.png#clientId=u7f18fa48-0703-4&from=paste&height=362&id=uda0be836&originHeight=723&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=373737&status=done&style=none&taskId=u1e40ef98-7257-4c53-a715-16170bc6d04&title=&width=619.5" alt="image.png"></p><p>HTTP&#x2F;2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><h6 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h6><p>根本原因是HTTP基于<code>请求-响应</code>的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞</p><p>虽然<code>并发连接</code>和<code>域名分片</code>的方式来解决这个问题，但是并没有真正从HTTP本身的层面解决问题，只是增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争 <strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理</p><p>HTTP&#x2F;2从HTTP协议本身解决了<code>队头阻塞</code>问题。这里指的并不是<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code></p><ul><li>TCP队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给HTTP</li><li>HTTP队头阻塞是在HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住</li></ul><p><strong>HTTP&#x2F;2解决队头阻塞</strong></p><ol><li>二进制分帧 <ol><li>首先，HTTP&#x2F;2认为明文传输对机器而言解析太麻烦，因为文本有很多多义性的字符串，比如回车换行到底是内容还是分隔符号，在内部需要用到状态机去识别，效率很低，于是HTTP&#x2F;2把报文全部换成二进制格式，全部传输01串，方便了机器的解析</li><li>原来Headers+Body的报文格式如今被拆分成一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据，分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也不会排队等待，也就没有了HTTP的队头阻塞问题</li><li>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫<code>流(Stream)</code>HTTP&#x2F;2用<code>流</code>来在一个TCP连接上进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念</li><li>乱序首发，乱序是指不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按照顺序传输的，二进制帧到达后对方会将Stream ID相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧中还有一些其他的字段，实现了 <strong>优先级</strong>和 <strong>流量控制</strong> 等功能。</li></ol></li></ol><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>在HTTP&#x2F;2中，服务器不再是完全被动地接受请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如：在浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP&#x2F;2完全兼容HTTP的语法和语义</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051333485-a5a5a556-b0f5-44c1-b37a-eaa54527d4aa.png#clientId=u7f18fa48-0703-4&from=paste&height=281&id=u08e3d079&originHeight=561&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277759&status=done&style=none&taskId=u953f5c9b-2efa-4284-8c63-8926ac95bf5&title=&width=602" alt="image.png"></p><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>设置请求优先级</li><li>服务器推送</li></ul><h4 id="二进制帧的设计"><a href="#二进制帧的设计" class="headerlink" title="二进制帧的设计"></a>二进制帧的设计</h4><h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><p>HTTP&#x2F;2中传输的帧结构如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21726284/1647051343631-ba73351b-a10d-47f2-8c24-c5f3193c0cec.png#clientId=u7f18fa48-0703-4&from=paste&height=302&id=u3f786ce7&originHeight=603&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86917&status=done&style=none&taskId=u1c52aedb-496a-4781-a698-ddd6755933e&title=&width=611.5" alt="image.png"></p><p>每个帧分为帧头和帧体。显示三个字节的帧长度，这个长度表示的是帧体的长度。</p><p>然后是帧的类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧存放HTTP报文，控制帧管理<code>流</code>的传输。</p><p>接下来的第一个字节是<strong>帧标志</strong>，这里面一共有8个标志位，常用的有END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束</p><p>后4个字节是Stream ID，也就是流标识符，有了它，接收方就能从乱序的二进制帧中选出 ID 相同的帧，然后按照顺序组装成请求&#x2F;响应报文</p><h5 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h5><p>根据帧的标志位来实现具体的状态改变。</p><p>例子：普通的请求-响应过程</p><p><img src="/img/%E7%BD%91%E7%BB%9C/HTTP/network01.png" alt="image.png"></p><ul><li>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</li><li>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</li><li>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</li><li>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个</li></ul><h5 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h5><ul><li>并发性，一个HTTP&#x2F;2连接上可以同时发多个帧，这一点和HTTP&#x2F;1不同，这也是实现多路复用的基础</li><li>自增性，流 ID 是不可重用的，会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li><li>双向性，客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</li><li>可以设置优先级，可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue2/%E5%8E%9F%E7%90%86/01.observe/</url>
    
    <content type="html"><![CDATA[<h1 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h1><p><code>Vue</code> 实例化过程，<code>Vue</code> 为一个构造函数，传入的参数是一个对象，可称之为 <code>options</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  router,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就是初始化 Vue 工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./init.js&quot;</span>;<br><span class="hljs-comment">// Vue 就是一个构造函数 通过 new 关键字 进行实例化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-comment">// 进行 Vue 初始化工作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options);<br>&#125;<br><span class="hljs-comment">// _init 方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载，需要传入 Vue 对象</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span>;<br></code></pre></td></tr></table></figure><p>initMixin 把 _init 方法挂载在 Vue 原型 供 Vue 实例调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/state.js</span><br><span class="hljs-keyword">import</span> &#123; observe &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./observer/index.js&quot;</span>;<br><span class="hljs-comment">// 初始化状态</span><br><span class="hljs-comment">// 初始化的顺序依次是 prop &gt; methods &gt; data &gt; watch</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-comment">// 获取传入的数据对象</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-title function_">initProps</span>(vm)  <br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) &#123;<br>    <span class="hljs-title function_">initMethod</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) &#123;<br>    <span class="hljs-title function_">initComputed</span>(vm);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span>) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 初始化 data 数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span>(<span class="hljs-params">vm</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 实例的_data熟悉就是传入的data</span><br>  <span class="hljs-comment">// vue 组件的 data 之所以要使用函数，是为了私有化数据，js 只有函数作用域</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span> ? data.<span class="hljs-title function_">call</span>(vm) : data || &#123;&#125;;<br>  <br>  <span class="hljs-comment">// 把 data 数据代理到 vm 也就是 Vue实例上面 我们可以使用this.a 来访问 this._data.a</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>  &#125;<br>  <span class="hljs-comment">// 对数据进行观测 -- 响应式数据核心</span><br>  <span class="hljs-title function_">observe</span>(data);<br>&#125;<br><span class="hljs-comment">// 数据代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">object, sourceKey, key</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(object, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> object[sourceKey][key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      object[sourceKey][key] = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的数据劫持"><a href="#对象的数据劫持" class="headerlink" title="对象的数据劫持"></a>对象的数据劫持</h1><p>defineReactive 函数 主要使用<code>Object.defineProperty</code>来对数据 get 和 set 进行劫持 这里知道了为啥数据变动了会自动更新视图 -&gt; 可以在 set 里面去通知视图更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 对象上所有的属性依次进行观测</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> key = keys[i];<br>      <span class="hljs-keyword">let</span> value = data[key];<br>      <span class="hljs-title function_">defineReactive</span>(data, key, value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Object.defineProperty 数据劫持核心 兼容性在 ie9 及以上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, keym value</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归</span><br>  <span class="hljs-comment">// 如果 value 还是对象就递归，直到 value 不是对象为止</span><br>  <span class="hljs-comment">// 如果 Vue 数据嵌套层级过深 会有性能影响</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取值&#x27;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置值&#x27;</span>);<br>      value = newValue;<br>    &#125;,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 如果传过来的是对象或者数组，进行属性劫持</span><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ||<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的观测"><a href="#数组的观测" class="headerlink" title="数组的观测"></a>数组的观测</h1><p>数组元素过多，使用递归根据下标直接修改数据太消耗性能了，不可能为每个元素下标都添加 get 和 set 方法。<br />所以通过重写数组原型方法来对数组的七种方法进行拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>     <span class="hljs-comment">// 通过重写数组原型方法来对数组的七种方法进行拦截</span><br>     value.<span class="hljs-property">__proto__</span> = arrayMethods;<br>     <span class="hljs-comment">// 如果数组里面还包含数组 需要递归判断</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>   &#125;<br> &#125;<br>  <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">observe</span>(items[i])  <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这段代码给每个响应式数据增加了一个不可枚举的__ob__属性 并且指向了 Observer 实例 那么我们首先可以根据这个属性来防止已经被响应式观察的数据反复被观测 其次 响应式数据可以使用__ob__来获取 Observer 实例的相关方法 这对数组很关键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-comment">// 观测值</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, &#123;<br>      <span class="hljs-comment">// 值指 Observer 的实例</span><br>      <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,<br>      <span class="hljs-comment">// 不可枚举</span><br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/obserber/array.js</span><br><span class="hljs-comment">// 先保留数据原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 然后将 arrayMethods 继承自数组原型</span><br><span class="hljs-comment">// 这里是面向切片编程思想（AOP）：不破坏封装的前提下，动态扩展功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-keyword">let</span> methodsToPath = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>];<br>methodsToPath.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 这里保留原型方法的执行结果</span><br>    <span class="hljs-keyword">const</span> result = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// this代表的就是数据本身 比如数据是&#123;a:[1,2,3]&#125; 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-comment">// 这里的标志就是代表数组有新增操作</span><br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<br>    <span class="hljs-comment">// 在这里就可以检测到数据变化了</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue2</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>observe</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E5%8E%9F%E7%90%86/observe/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p><code>**Object.defineProperty(obj, prop, descriptor)**</code>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><ul><li>obj：要定义属性的对象</li><li>prop：要定义或修改的 属性名称 或 Symbol</li><li>descriptor：要定义或修改的 属性描述符</li></ul><h3 id="本身的限制"><a href="#本身的限制" class="headerlink" title="本身的限制"></a>本身的限制</h3><ul><li>目标只是对象的属性，而不是整个对象</li><li>一次只能 定义或者修改一个属性</li></ul><h3 id="在-Vue2-中的缺陷"><a href="#在-Vue2-中的缺陷" class="headerlink" title="在 Vue2 中的缺陷"></a>在 Vue2 中的缺陷</h3><ul><li>只能拦截对象属性的<code>get</code>和<code>set</code>操作，比如无法拦截<code>delete</code>、<code>in</code>、<code>方法调用</code>等操作</li><li>动态添加新属性（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新属性</li></ul></li><li>通过<code>delete</code>删除属性（响应式丢失）<ul><li>使用<code>this.$delete()</code>删除属性</li></ul></li><li>使用数组索引 <code>替换/新增</code>元素（响应式丢失）<ul><li>使用<code>this.$set()</code>设置新元素</li></ul></li><li>使用数组<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>等原生方法改变原数组时（响应式丢失）<ul><li>使用重写后<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>方法</li></ul></li><li>一次只能对一个属性实现 数据劫持，需要遍历对所有属性进行劫持</li><li>数据结构复杂时（属性值为 引用类型数据），需要通过 递归 进行处理</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>**Proxy**</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><code>new Proxy(target, handler)</code>针对整个对象进行代理</li><li>代理对象的属性拥有读取、修改、删除、新增、是否存在属性，等相应的捕捉器<ul><li><code>get()</code>：<code>读取</code>操作的捕捉器</li><li><code>get()</code>：<code>设置</code>操作的捕捉器</li><li><code>deleteProperty()</code>：<code>删除</code>操作的捕捉器</li><li><code>ownKeys()</code>：<code>Object.getOwnPropertyNames</code>方法和<code>Object.getOwnPropertySymbols</code>方法的捕捉器</li><li><code>has()</code>：<code>in</code>操作符的捕捉器</li></ul></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>**Reflect**</code>是一个内置的对象，它提供拦截 <code>**JavaScript**</code> 操作的方法，这些方法与 <code>Proxy handlers</code> 提供的的方法是一一对应的，且 <code>**Reflect**</code> 不是一个函数对象，即不能进行实例化，其所有属性和方法都是静态的（就像是<code>Math</code>对象）。</p><ul><li><code>Reflect.get(target, propertyKey[, receiver]) </code>获取对象身上某个属性的值，类似于 <code>target[name]</code></li><li><code>Reflect.set(target, propertyKey, value[, receiver]) </code>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code></li><li><code>Reflect.deleteProperty(target, propertyKey) </code>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code></li><li><code>Reflect.ownKeys(target) </code>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code> 影响)</li><li><code>Reflect.has(target, propertyKey) </code>判断一个对象是否存在某个属性，和<code>in</code>运算符 的功能完全相同</li></ul><h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span></span>) &#123;<br><span class="hljs-comment">// 若目标对象是响应式的只读对象，则直接返回</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isReadonly</span>(target)) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 否则将目标数据尝试变成响应式数据</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createdReactiveObject</span>(<br>    target,<br>    <span class="hljs-literal">false</span>,<br>    mutableHandlers, <span class="hljs-comment">// 对象类型的 handlers</span><br>    mutableCollectionHandlers, <span class="hljs-comment">// 集合类型的 handlers</span><br>    reacitveMap<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject()"></a>createReactiveObject()</h3><p>主要是做前置处理</p><ul><li>目标数据为 原始值类型，返回 原数据</li><li>目标数据的<code>__v_raw</code>属性为<code>true</code>，且是非响应式数据，或 不是通过调用<code>readonly()</code>方法，则直接返回原数据</li><li>目标数据已存在相应的<code>proxy</code>代理对象，则直接返回代理对象</li><li>目标数据不存在对应的 白名单数据类型中，则直接返回原数据，支持响应式的数据类型如下<ul><li>可扩展的对象（是否可以先加新属性）</li><li><code>__v_skip</code>属性不存在或者值为 false 的对象</li><li>数据类型为<code>Object</code>，<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>WeakMap</code>，<code>WeakSet</code>的对象</li><li>其他数据都统一被认为是无效的响应式数据对象</li></ul></li><li>通过<code>Proxy</code>创建代理对象，根据目标数据类型选择不同的<code>Proxy handlers</code>（捕获器）</li></ul><p>具体的实现在对应数据类型的 捕获器 中，即下面源码中的<code>collectionHandlers</code>和<code>baseHandlers</code>，而它们则对应的是上述<code>reactive()</code>函数中的<code>createReactiveObject()</code>函数传递的<code>mutableCollectionHandlers</code>和<code>mutableHandlers</code>参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: Target,</span><br><span class="hljs-params">  isReadonly: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  baseHanlders: ProxyHandle&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  collectionHandlers: ProxyHandler&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  proxyMap: <span class="hljs-built_in">WeakMap</span>&lt;Target, <span class="hljs-built_in">any</span>&gt;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 非对象类型直接返回</span><br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>    <span class="hljs-keyword">if</span>(__DEV__) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`value cannot be made reactive: <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(target)&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 目标数据的 __v_raw 属性若为 true，且是【非响应式数据】或 不是通过调用 readonly() 方法，则直接返回</span><br>  <span class="hljs-keyword">if</span> (<br>    target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span>] &amp;&amp;<br>    !(isReadonly &amp;&amp; target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>])<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br><br>  <span class="hljs-comment">// 目标对象已存在相应的 proxy 代理对象，则直接返回</span><br>  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>    <span class="hljs-keyword">return</span> existingProxy<br>  &#125;<br>  <br><span class="hljs-comment">// 只有在白名单中的值类型才可以被代理监测，否则直接返回</span><br>  <span class="hljs-keyword">const</span> targetType = <span class="hljs-title function_">getTargetType</span>(target)<br>  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">INVALID</span>) &#123;<br>    <span class="hljs-keyword">return</span> target     <br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建代理对象</span><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<br>    target,<br>    <span class="hljs-comment">// 若目标对象是集合类型（Set、Map）则使用集合类型对应的捕获器，否则使用基础捕获器</span><br>    targetType === <span class="hljs-title class_">TargetType</span>.<span class="hljs-property">COLLECTION</span> ? collectionHandlers : baseHandlers <br>  )<br><br>  <span class="hljs-comment">// 将对应的代理对象存储在 proxyMap 中</span><br>  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捕获器-Handles"><a href="#捕获器-Handles" class="headerlink" title="捕获器 Handles"></a>捕获器 Handles</h3><h4 id="对象类型（Object类型不包括Array）的捕获器-mutableHandlers"><a href="#对象类型（Object类型不包括Array）的捕获器-mutableHandlers" class="headerlink" title="对象类型（Object类型不包括Array）的捕获器 mutableHandlers"></a>对象类型（Object类型不包括Array）的捕获器 <code>mutableHandlers</code></h4><p><code>baseHandles.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">mutableHandlers</span>: <span class="hljs-title class_">ProxyHandle</span>&lt;<span class="hljs-built_in">object</span>&gt; = &#123;<br>  get,<br>  set,<br>  deleteProperty,<br>  has,<br>  ownKeys,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get-捕获器"><a href="#get-捕获器" class="headerlink" title="get 捕获器"></a>get 捕获器</h5><ul><li>当前数据对象为 数组，重写 数组对应方法</li><li>当前数据对象为普通对象，且非 只读 的则通过<code>track(target, TrackOptypes.GET, key)</code>进行依赖收集<ul><li>当前数据对象为浅层响应，直接返回其对应的属性值</li><li>当前数据对象为 ref 类型，自动脱 ref</li></ul></li><li>当前数据对象属性值是对象类型<ul><li>当前数据对象为 只读的，则通过 <code>readonly(res)</code>向外返回其结果</li><li>否则将当前属性值以<code>reactive(res)</code>向外返回 proxy 代理对象</li></ul></li><li>否则直接向外返回对应的 属性值 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span>, shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target: Target, key: <span class="hljs-built_in">string</span> | sysbol, receiver: <span class="hljs-built_in">object</span></span>) &#123;<br>    <span class="hljs-comment">// 当直接通过指定 key 访问 vue 内置自定义的对象属性时，返回其对应的值</span><br>    <span class="hljs-keyword">if</span>(key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) &#123;<br>      <span class="hljs-keyword">return</span> !isReadonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_READONLY</span>) &#123;<br>      <span class="hljs-keyword">return</span> isRedaonly<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFLags</span>.<span class="hljs-property">IS_SHALLOW</span>) &#123;<br>      <span class="hljs-keyword">return</span> shallow<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">RAW</span> &amp;&amp;<br>      receiver ===<br>        (<br>          isReadonly<br>            ? shallow<br>              ? shallowReadonlyMap<br>              : readonlyMap<br>            : shallow<br>            ? shallowReactiveMap<br>            : reactiveMap<br>        ).<span class="hljs-title function_">get</span>(target)<br>    ) &#123;<br>      <span class="hljs-keyword">return</span> target<br>    &#125;<br>     <span class="hljs-comment">// 判断是否为数组类型</span><br>    <span class="hljs-keyword">const</span> targetIsArray = <span class="hljs-title function_">isArray</span>(target)<br><br>    <span class="hljs-comment">// 数组对象</span><br>    <span class="hljs-keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="hljs-title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;<br>      <span class="hljs-comment">// 重写/增强数组的方法： </span><br>      <span class="hljs-comment">//  - 查找方法：includes、indexOf、lastIndexOf</span><br>      <span class="hljs-comment">//  - 修改原数组的方法：push、pop、unshift、shift、splice</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)<br>    &#125;<br>    <span class="hljs-comment">// 获取对应属性值</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSymbol</span>(key) ? builtInSymbols.<span class="hljs-title function_">has</span>(key) : <span class="hljs-title function_">isNonTrackableKeys</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// 依赖收集</span><br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">GET</span>, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 浅层响应</span><br>    <span class="hljs-keyword">if</span> (shallow) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 若是 ref 类型响应式数据，会进行【自动脱 ref】，但不支持【数组】+【索引】的访问方式</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(res)) &#123;<br>      <span class="hljs-keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="hljs-title function_">isIntegerKey</span>(key)<br>      <span class="hljs-keyword">return</span> shouldUnwrap ? res.<span class="hljs-property">value</span> : res<br>    &#125;<br>    <span class="hljs-comment">// 属性值是对象类型：</span><br>    <span class="hljs-comment">//  - 是只读属性，则通过 readonly() 返回结果，</span><br>    <span class="hljs-comment">//  - 且是非只读属性，则递归调用 reactive 向外返回 proxy 代理对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(res)) &#123;<br>      <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="set捕获器"><a href="#set捕获器" class="headerlink" title="set捕获器"></a><code>set</code>捕获器</h5><p>边界值处理，以及<strong>更新属性值，并通过</strong><code>**targger()**</code>触发依赖更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params">shallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span><br><span class="hljs-params">    value: <span class="hljs-built_in">unknown</span>,</span><br><span class="hljs-params">    receiver: <span class="hljs-built_in">object</span></span><br><span class="hljs-params">  </span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-comment">// 保存旧的数据</span><br>    <span class="hljs-keyword">let</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br><br>    <span class="hljs-comment">// 若原数据值属于 只读 且 ref 类型，并且新数据值不属于 ref 类型，则意味着修改失败</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!shallow &amp;&amp; !<span class="hljs-title function_">isReadonly</span>(value)) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isShallow</span>(value)) &#123;<br>        value = <span class="hljs-title function_">toRaw</span>(value)<br>        oldValue = <span class="hljs-title function_">toRaw</span>(oldValue)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isRef</span>(oldValue) &amp;&amp; !<span class="hljs-title function_">isRef</span>(value)) &#123;<br>        oldValue.<span class="hljs-property">value</span> = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// in shallow mode, objects are set as-is regardless of reactive or not</span><br>    &#125;<br><br>    <span class="hljs-comment">// 是否存在对应的 key</span><br>    <span class="hljs-keyword">const</span> hadKey =<br>      <span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isIntegerKey</span>(key)<br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span><br>        : <span class="hljs-title function_">hasOwn</span>(target, key)<br><br>    <span class="hljs-comment">// 设置对应值</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br><br>    <span class="hljs-comment">// 若目标对象是原始原型链上的内容（非自定义添加），则不触发依赖更新</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-title function_">toRaw</span>(receiver)) &#123;<br>      <span class="hljs-keyword">if</span> (!hadKey) &#123;<br>        <span class="hljs-comment">// 目标对象不存在对应的 key，则为新增操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">ADD</span>, key, value)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(value, oldValue)) &#123;<br>        <span class="hljs-comment">// 目标对象存在对应的值，则为修改操作</span><br>        <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">SET</span>, key, value, oldValue)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回修改结果</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="deleteProperty-amp-has-amp-ownKeys-捕获器"><a href="#deleteProperty-amp-has-amp-ownKeys-捕获器" class="headerlink" title="deleteProperty &amp; has &amp; ownKeys 捕获器"></a><code>deleteProperty</code> &amp; <code>has</code> &amp; <code>ownKeys</code> 捕获器</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> hadKty = <span class="hljs-title function_">hasOwn</span>(target, key)<br>  <span class="hljs-keyword">const</span> oldValue = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key]<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>  <span class="hljs-comment">// 目标对象存在对应的 key，并且成功删除，才会触发依赖更新</span><br>  <span class="hljs-keyword">if</span> (result &amp;&amp; hadKey) &#123;<br>    <span class="hljs-title function_">trigger</span>(target, <span class="hljs-title class_">TriggerOpTypes</span>.<span class="hljs-property">DELETE</span>, key, <span class="hljs-literal">undefined</span>, oldValue)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">has</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span>, key: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key)<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSymbol</span>(key) || !builtInSymbols.<span class="hljs-title function_">has</span>(key)) &#123;<br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">HAS</span>, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target: <span class="hljs-built_in">object</span></span>): (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>)[] &#123;<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">TrackOpTypes</span>.<span class="hljs-property">ITERATE</span>, <span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">&#x27;length&#x27;</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">REflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="数组类型捕获器-arrayInstrumentations"><a href="#数组类型捕获器-arrayInstrumentations" class="headerlink" title="数组类型捕获器 arrayInstrumentations"></a>数组类型捕获器 <code>arrayInstrumentations</code></h5><p>数组由于<code>index</code>和<code>length</code>会相互影响，所以需要特殊处理</p><ul><li><code>arr[1] = 2</code>会隐式修改<code>length</code>的属性值</li><li><code>arr.lenght = 0</code>会导致原索引位置的值发生变更</li></ul><p>为了能够合理触发和 <code>length</code> 相关副作用函数的执行，在 <code>set()</code> 捕获器中会判断当前操作的类型：</p><ul><li>当<code>Number(key) &lt; target.length</code>证明是修改操作，对应<code>TriggerOptypes.SET</code>类型，即当前操作不会改变<code>length</code>的值，不需要 触发和 <code>length</code>有关副作用函数的执行</li><li>当<code>Number(key) &gt;= target.length</code>证明是新增操作，<code>TriggerOpTypes.ADD</code>类型，即当前操作会改变<code>length</code>的值，需要触发和<code>length</code>相关副作用函数的执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误页面处理</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/01.%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="error-vue"><a href="#error-vue" class="headerlink" title="error.vue"></a>error.vue</h1><p><code>error.vue</code>必须与项目入口文件<code>app.vue</code>在同级别目录下<br><code>error.vue</code>接受了一个<code>error</code>的<code>props</code></p><h2 id="定制处理"><a href="#定制处理" class="headerlink" title="定制处理"></a>定制处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ErrorPage<br>  :errCode=&quot;error.statusCode&quot;<br>  &gt;<br>  &lt;/ErrorPage&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br><br>const props = defineProps(&#123;<br>  error: Object<br>&#125;)<br>if(props.error.statusCode === 500 &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123;<br>  // 此处可以记录错误日志<br>  useRecordErrorLog(props.error)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>ErrorPage</code>组件为根据错误码定制的页面</p><h2 id="错误日志收集"><a href="#错误日志收集" class="headerlink" title="错误日志收集"></a>错误日志收集</h2><p>存储到项目根目录下的<code>logs/error.log</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> winston <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;winston&#x27;</span>;<br><br><span class="hljs-keyword">const</span> logger = winston.<span class="hljs-title function_">createLogger</span>(&#123;<br>  <span class="hljs-attr">transports</span>: [<br>    <span class="hljs-keyword">new</span> winston.<span class="hljs-property">transports</span>.<span class="hljs-title class_">File</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;logs/error.log&#x27;</span>,<br>      <span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">format</span>: winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">combine</span>(<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">timestamp</span>(&#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;YYYY-MM-DDTHH:mm:ss.SSSZ&#x27;</span> &#125;),<br>        winston.<span class="hljs-property">format</span>.<span class="hljs-title function_">json</span>(),<br>      )<br>    &#125;)<br>  ]<br>&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRecordErrorLog</span> = (<span class="hljs-params">error</span>) =&gt; &#123;<br>  logger.<span class="hljs-title function_">error</span>(error)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useRecordErrorLog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航栏锚点</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/02.%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%94%9A%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="导航栏部分"><a href="#导航栏部分" class="headerlink" title="导航栏部分"></a>导航栏部分</h1><ol><li>利用<code>NuxtLink</code>组件实现跳转<ol><li>注意，如果要跳转到其他项目的地址，此时要给<code>link</code>前面拼接上<code>window.location.origin</code></li></ol></li><li><code>link</code>后添加上对应页面，对应锚点的<code>id</code>，此处可以用<code>#targetID</code>这种形式拼接</li></ol><h2 id="对应页面"><a href="#对应页面" class="headerlink" title="对应页面"></a>对应页面</h2><ol><li>每个锚点添加上<code>id=&quot;xxx&quot;</code></li><li>使用<code>useAnchor()</code></li></ol><h1 id="useAnchor实现"><a href="#useAnchor实现" class="headerlink" title="useAnchor实现"></a>useAnchor实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToAnchor</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> targetId = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> targetElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(targetId);<br>    <span class="hljs-keyword">if</span> (targetElement) &#123;<br>      targetElement.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onMounted</span>(scrollToAnchor);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useAnchor;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加百度统计代码</title>
    <link href="/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/04/26/web%E5%89%8D%E7%AB%AF/Vue3/%E7%94%9F%E6%80%81/nuxt3/03.%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="设置单页面模式"><a href="#设置单页面模式" class="headerlink" title="设置单页面模式"></a>设置单页面模式</h1><ol><li>首先去百度统计PC端首页-&gt;使用规则-&gt;单页设置-&gt;启用单页应用数据统计</li><li>在项目入口文件<code>app.vue</code>引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-title function_">useHead</span>(&#123;<br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span><br>    &#125;<br>  ]<br>&#125;)<br><span class="hljs-title function_">watch</span>(route, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (_hmt) &#123;<br>    _hmt.<span class="hljs-title function_">push</span>([<span class="hljs-string">&#x27;_trackPageview&#x27;</span>, route.<span class="hljs-property">path</span>])<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="不设置单页模式"><a href="#不设置单页模式" class="headerlink" title="不设置单页模式"></a>不设置单页模式</h2><ol><li>对应的每个页面引入百度统计代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useHead</span>(&#123;<br><br>  <span class="hljs-attr">script</span>: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;https://hm.baidu.com/hm.js?your key&#x27;</span>,<br>      <span class="hljs-attr">bodyClose</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// false 添加到 head标签内</span><br>      <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">defer</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  ]<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
      <category>Vue3</category>
      
      <category>生态</category>
      
      <category>nuxt3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
